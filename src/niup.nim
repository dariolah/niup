import niup/niupc
import std/macros
import strformat


export niupc.PIhandle, # type used in callbacks
  # macros, required
  niupc.Vbox, niupc.Hbox, niupc.Cbox, niupc.FlatTabs, niupc.GridBox, niupc.Menu,
  niupc.MultiBox, niupc.Normalizer, niupc.ParamBox, niupc.Tabs, niupc.Zbox

# re-use types for IUP, IM and CD
include niup/inc/c/im_template
include niup/inc/c/cd_template
include niup/inc/c/iup_template
include niup/inc/c/im_const
include niup/inc/c/cd_const
include niup/inc/c/iup_const

type
  AnimatedLabel_t* = distinct PIhandle
  BackgroundBox_t* = distinct PIhandle
  Button_t* = distinct PIhandle
  Calendar_t* = distinct PIhandle
  Canvas_t* = distinct PIhandle
  Cbox_t* = distinct PIhandle
  Clipboard_t* = distinct PIhandle
  Colorbar_t* = distinct PIhandle
  ColorBrowser_t* = distinct PIhandle
  ColorDlg_t* = distinct PIhandle
  DatePick_t* = distinct PIhandle
  DetachBox_t* = distinct PIhandle
  Dial_t* = distinct PIhandle
  Dialog_t* = distinct PIhandle
  DropButton_t* = distinct PIhandle
  Expander_t* = distinct PIhandle
  FileDlg_t* = distinct PIhandle
  Fill_t* = distinct PIhandle
  FlatButton_t* = distinct PIhandle
  FlatFrame_t* = distinct PIhandle
  FlatLabel_t* = distinct PIhandle
  FlatList_t* = distinct PIhandle
  FlatScrollBox_t* = distinct PIhandle
  FlatSeparator_t* = distinct PIhandle
  FlatTabs_t* = distinct PIhandle
  FlatToggle_t* = distinct PIhandle
  FlatTree_t* = distinct PIhandle
  FlatVal_t* = distinct PIhandle
  FontDlg_t* = distinct PIhandle
  Frame_t* = distinct PIhandle
  Gauge_t* = distinct PIhandle
  GridBox_t* = distinct PIhandle
  Hbox_t* = distinct PIhandle
  Image_t* = distinct PIhandle
  ImageRGB_t* = distinct PIhandle
  ImageRGBA_t* = distinct PIhandle
  Item_t* = distinct PIhandle
  Label_t* = distinct PIhandle
  Link_t* = distinct PIhandle
  List_t* = distinct PIhandle
  Menu_t* = distinct PIhandle
  MessageDlg_t* = distinct PIhandle
  MultiBox_t* = distinct PIhandle
  MultiLine_t* = distinct PIhandle
  Normalizer_t* = distinct PIhandle
  Param_t* = distinct PIhandle
  ParamBox_t* = distinct PIhandle
  ProgressBar_t* = distinct PIhandle
  ProgressDlg_t* = distinct PIhandle
  Radio_t* = distinct PIhandle
  Sbox_t* = distinct PIhandle
  ScrollBox_t* = distinct PIhandle
  Separator_t* = distinct PIhandle
  Space_t* = distinct PIhandle
  Spin_t* = distinct PIhandle
  Spinbox_t* = distinct PIhandle
  Split_t* = distinct PIhandle
  Submenu_t* = distinct PIhandle
  Tabs_t* = distinct PIhandle
  Text_t* = distinct PIhandle
  Thread_t* = distinct PIhandle
  Timer_t* = distinct PIhandle
  Toggle_t* = distinct PIhandle
  Tree_t* = distinct PIhandle
  User_t* = distinct PIhandle
  Val_t* = distinct PIhandle
  Vbox_t* = distinct PIhandle
  Zbox_t* = distinct PIhandle

type IUPhandle_t* = AnimatedLabel_t | BackgroundBox_t | Button_t | Calendar_t | Canvas_t | Cbox_t | Clipboard_t | Colorbar_t | ColorBrowser_t | ColorDlg_t | DatePick_t | DetachBox_t | Dial_t | Dialog_t | DropButton_t | Expander_t | FileDlg_t | Fill_t | FlatButton_t | FlatFrame_t | FlatLabel_t | FlatList_t | FlatScrollBox_t | FlatSeparator_t | FlatTabs_t | FlatToggle_t | FlatTree_t | FlatVal_t | FontDlg_t | Frame_t | Gauge_t | GridBox_t | Hbox_t | Image_t | ImageRGB_t | ImageRGBA_t | Item_t | Label_t | Link_t | List_t | Menu_t | MessageDlg_t | MultiBox_t | MultiLine_t | Normalizer_t | Param_t | ParamBox_t | ProgressBar_t | ProgressDlg_t | Radio_t | Sbox_t | ScrollBox_t | Separator_t | Space_t | Spin_t | Spinbox_t | Split_t | Submenu_t | Tabs_t | Text_t | Thread_t | Timer_t | Toggle_t | Tree_t | User_t | Val_t | Vbox_t | Zbox_t

proc AnimatedLabel*(animation: IUPhandle_t): AnimatedLabel_t {.cdecl.} =
    # Creates an animated label interface element, which displays an
    # image that is changed periodically. It uses an animation that is
    # simply an IupUser with several IupImage as children. It inherits
    # from IupLabel.
    return AnimatedLabel_t(niupc.AnimatedLabel(cast[PIhandle](animation)))

proc `active=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: AnimatedLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `alignment=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"))

proc `animation=`*(ih: AnimatedLabel_t, handle: User_t) {.cdecl.} =
    # ANIMATION: the name of the element that contains the list of
    # images. The value passed must be the name of an IupUser element
    # with several IupImage as children. Use IupSetHandle or
    # IupSetAttributeHandle to associate a child to a name. In Lua you
    # can also use the element reference directly.
    SetAttributeHandle(cast[PIhandle](ih), cstring("ANIMATION"), cast[PIhandle](handle))

proc `animation`*(ih: AnimatedLabel_t, handle: User_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("ANIMATION"), cast[PIhandle](handle))

proc `animation`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ANIMATION"))

# TODO unknown: animatedlabel ANIMATION_HANDLE Unknown Binary
proc `animation_handle`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ANIMATION_HANDLE"))

proc `bgcolor=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: AnimatedLabel_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: AnimatedLabel_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `canfocus=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: AnimatedLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `cpadding=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding=`*(ih: AnimatedLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: AnimatedLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CPADDING"))

proc `dragdrop=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: AnimatedLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: AnimatedLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: AnimatedLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary animatedlabel
proc `dragtypes`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

proc `dropfilestarget=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: AnimatedLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: AnimatedLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary animatedlabel
proc `droptypes`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `ellipsis=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ELLIPSIS"), cstring(value))

proc `ellipsis`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ELLIPSIS"), cstring(value))

proc `ellipsis=`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `ellipsis`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `ellipsis`*(ih: AnimatedLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ELLIPSIS")) == "YES"

proc `expand=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: AnimatedLabel_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: AnimatedLabel_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `fgcolor=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: AnimatedLabel_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: AnimatedLabel_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

proc `first_control_handle`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FIRST_CONTROL_HANDLE"))

proc `floating=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary animatedlabel
proc `font`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary animatedlabel
proc `fontface`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: AnimatedLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: AnimatedLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary animatedlabel
proc `fontstyle`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `framecount`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRAMECOUNT"))

proc `frametime=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    # FRAMETIME: The time between each frame. If the IupUser element
    # has a FRAMETIME attribute it will be used to set the
    # IupAnimatedLabel FRAMETIME attribute, but it can be overwritten
    # later on.
    SetAttribute(cast[PIhandle](ih), cstring("FRAMETIME"), cstring(value))

proc `frametime`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FRAMETIME"), cstring(value))

# TODO ??? String Binary animatedlabel
proc `frametime`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRAMETIME"))

proc `handlename=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary animatedlabel
proc `handlename`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `image=`*(ih: AnimatedLabel_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: AnimatedLabel_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGE"))

proc `iminactive=`*(ih: AnimatedLabel_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMINACTIVE"), cast[PIhandle](handle))

proc `iminactive`*(ih: AnimatedLabel_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMINACTIVE"), cast[PIhandle](handle))

proc `iminactive`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMINACTIVE"))

proc `markup=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKUP"), cstring(value))

proc `markup`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKUP"), cstring(value))

proc `markup=`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKUP"), cstring((if yes: "YES" else: "NO")))

proc `markup`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKUP"), cstring((if yes: "YES" else: "NO")))

proc `markup`*(ih: AnimatedLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MARKUP")) == "YES"

proc `maxsize=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: AnimatedLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: AnimatedLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: AnimatedLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: AnimatedLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary animatedlabel
proc `name`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `next_control_handle`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NEXT_CONTROL_HANDLE"))

proc `normalizergroup=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary animatedlabel
proc `normalizergroup`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary animatedlabel
proc `ntheme`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `padding=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding=`*(ih: AnimatedLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: AnimatedLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PADDING"))

# TODO unknown: animatedlabel PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: animatedlabel PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: AnimatedLabel_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: AnimatedLabel_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: AnimatedLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: AnimatedLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: AnimatedLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `running`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RUNNING"))

proc `screenposition`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `separator=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SEPARATOR"), cstring(value))

proc `separator`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SEPARATOR"), cstring(value))

# TODO ??? String Binary animatedlabel
proc `separator`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SEPARATOR"))

proc `size=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: AnimatedLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: AnimatedLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `start=`*(ih: AnimatedLabel_t, ) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("START"), cstring(""))

proc `start`*(ih: AnimatedLabel_t, ) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("START"), cstring(""))

# TODO unknown: animatedlabel STOP Unknown Binary
# TODO unknown: animatedlabel STOPWHENHIDDEN Unknown Binary
proc `stopwhenhidden`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("STOPWHENHIDDEN"))

proc `theme=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary animatedlabel
proc `theme`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary animatedlabel
proc `tip`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: AnimatedLabel_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: AnimatedLabel_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: AnimatedLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: AnimatedLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: AnimatedLabel_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: AnimatedLabel_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary animatedlabel
proc `tipicon`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary animatedlabel
proc `tipmarkup`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: AnimatedLabel_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: AnimatedLabel_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: AnimatedLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `title=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary animatedlabel
proc `title`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

proc `usersize=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: AnimatedLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: AnimatedLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: AnimatedLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `wordwrap=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WORDWRAP"), cstring(value))

proc `wordwrap`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WORDWRAP"), cstring(value))

proc `wordwrap=`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WORDWRAP"), cstring((if yes: "YES" else: "NO")))

proc `wordwrap`*(ih: AnimatedLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WORDWRAP"), cstring((if yes: "YES" else: "NO")))

proc `wordwrap`*(ih: AnimatedLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WORDWRAP")) == "YES"

proc `x`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

# TODO unknown: animatedlabel XFONTID Unknown Binary
proc `xfontid`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `y`*(ih: AnimatedLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `zorder=`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: AnimatedLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `button_cb=`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: AnimatedLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `dragbegin_cb=`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: AnimatedLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: AnimatedLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: AnimatedLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: AnimatedLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: AnimatedLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: AnimatedLabel_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: AnimatedLabel_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: AnimatedLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: AnimatedLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: AnimatedLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `leavewindow_cb=`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: AnimatedLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: AnimatedLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: AnimatedLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `unmap_cb=`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: AnimatedLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: AnimatedLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc BackgroundBox*(child: IUPhandle_t): BackgroundBox_t {.cdecl.} =
    # Creates a simple native container with no decorations. Useful
    # for controlling children visibility for IupZbox or IupExpander.
    # It inherits from IupCanvas.
    return BackgroundBox_t(niupc.BackgroundBox(cast[PIhandle](child)))

proc `active=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `backcolor=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    # BACKCOLOR (non inheritable): if defined used to fill the
    # background color when BACKIMAGE is defined. If not defined
    # BGCOLOR is used. (since 3.26)
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(value))

proc `backcolor`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(value))

proc `backcolor=`*(ih: BackgroundBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `backcolor`*(ih: BackgroundBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `backcolor`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"))

proc `backimage=`*(ih: BackgroundBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # BACKIMAGE (non inheritable): image name to be used as
    # background. Use IupSetHandle or IupSetAttributeHandle to
    # associate an image to a name. See also IupImage. When defined
    # the ACTION callback of the IupCanvas will be defined. (since
    # 3.26)
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGE"), cast[PIhandle](handle))

proc `backimage`*(ih: BackgroundBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGE"), cast[PIhandle](handle))

proc `backimage`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGE"))

proc `backimagezoom=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    # BACKIMAGEZOOM (non inheritable): if set the back image will be
    # zoomed to occupy the full background. Aspect ratio is NOT
    # preserved. Can be Yes or No. Default: No. (since 3.26)
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring(value))

proc `backimagezoom`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring(value))

proc `backimagezoom=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring((if yes: "YES" else: "NO")))

proc `backimagezoom`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring((if yes: "YES" else: "NO")))

proc `backimagezoom`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM")) == "YES"

proc `backingstore=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE")) == "YES"

proc `bgcolor=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    # BGCOLOR: by default will use the background color of the native
    # parent, but can be set to a custom value (since 3.11).
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: BackgroundBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: BackgroundBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    # BORDER (creation only): the default value is "NO".
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `canfocus=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    # CANFOCUS> (non inheritable): the default is changed to NO. But
    # it can receive the focus (since 3.19).
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `canvasbox=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    # CANVASBOX (non inheritable): enable the behavior of a canvas box
    # instead of a regular container. This will affect the EXPAND
    # attribute, the Natural size computation, and children layout
    # distribution. Can be Yes or No. Default: No. (since 3.19)
    SetAttribute(cast[PIhandle](ih), cstring("CANVASBOX"), cstring(value))

proc `canvasbox`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANVASBOX"), cstring(value))

proc `canvasbox=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANVASBOX"), cstring((if yes: "YES" else: "NO")))

proc `canvasbox`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANVASBOX"), cstring((if yes: "YES" else: "NO")))

proc `canvasbox`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANVASBOX")) == "YES"

proc `charsize`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `childoffset=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    # CHILDOFFSET (non inheritable): Allow to specify a position
    # offset for the child. Available for native containers only. It
    # will not affect the natural size, and allows to position
    # controls outside the client area. Format "dxxdy", where dx and
    # dy are integer values corresponding to the horizontal and
    # vertical offsets, respectively, in pixels. Default: 0x0. (since
    # 3.14)
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset=`*(ih: BackgroundBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: BackgroundBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"))

proc `clientoffset`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `cursor=`*(ih: BackgroundBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: BackgroundBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `decoration=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    # DECORATION (non inheritable): Enable a decoration area around
    # the child. Can be Yes or No. Default No. (since 3.20)
    SetAttribute(cast[PIhandle](ih), cstring("DECORATION"), cstring(value))

proc `decoration`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DECORATION"), cstring(value))

proc `decoration=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DECORATION"), cstring((if yes: "YES" else: "NO")))

proc `decoration`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DECORATION"), cstring((if yes: "YES" else: "NO")))

proc `decoration`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DECORATION")) == "YES"

proc `decoroffset=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    # DECOROFFSET (non inheritable): decoration offset from left
    # border and top border in the format "XxY" (in C "%dx%d). Used
    # only when DECORATION=Yes. (since 3.20)
    SetAttribute(cast[PIhandle](ih), cstring("DECOROFFSET"), cstring(value))

proc `decoroffset`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DECOROFFSET"), cstring(value))

proc `decoroffset=`*(ih: BackgroundBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DECOROFFSET"), cstring(&"{width}x{height}"))

proc `decoroffset`*(ih: BackgroundBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DECOROFFSET"), cstring(&"{width}x{height}"))

proc `decoroffset`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DECOROFFSET"))

proc `decorsize=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    # DECORSIZE (non inheritable): total size of the decoration in the
    # format "WidthxHeight" (in C "%dx%d). Used only when
    # DECORATION=Yes. (since 3.20)
    SetAttribute(cast[PIhandle](ih), cstring("DECORSIZE"), cstring(value))

proc `decorsize`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DECORSIZE"), cstring(value))

proc `decorsize=`*(ih: BackgroundBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DECORSIZE"), cstring(&"{width}x{height}"))

proc `decorsize`*(ih: BackgroundBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DECORSIZE"), cstring(&"{width}x{height}"))

proc `decorsize`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DECORSIZE"))

proc `dragdrop=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary backgroundbox
proc `dragtypes`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

# TODO unknown: backgroundbox DRAWABLE Unknown Binary
proc `drawable`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWABLE"))

proc `drawbgcolor=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor=`*(ih: BackgroundBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: BackgroundBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"))

proc `drawcolor=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor=`*(ih: BackgroundBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: BackgroundBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"))

proc `drawdriver`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWDRIVER"))

proc `drawfont=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

proc `drawfont`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

# TODO ??? String Binary backgroundbox
proc `drawfont`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"))

proc `drawlinewidth=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth=`*(ih: BackgroundBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: BackgroundBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"))

proc `drawmakeinactive=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE")) == "YES"

proc `drawsize`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSIZE"))

proc `drawstyle=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"))

proc `drawtextalignment=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"))

proc `drawtextclip=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP")) == "YES"

proc `drawtextellipsis=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS")) == "YES"

proc `drawtextlayoutcenter=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER")) == "YES"

proc `drawtextorientation=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation=`*(ih: BackgroundBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: BackgroundBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"))

proc `drawtextwrap=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP")) == "YES"

proc `dropfilestarget=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary backgroundbox
proc `droptypes`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `dx=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx=`*(ih: BackgroundBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: BackgroundBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DX"))

proc `dy=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy=`*(ih: BackgroundBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: BackgroundBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DY"))

proc `expand=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable): behaves as a container. See CANVASBOX
    # attribute.
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: BackgroundBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: BackgroundBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary backgroundbox
proc `font`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary backgroundbox
proc `fontface`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: BackgroundBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: BackgroundBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary backgroundbox
proc `fontstyle`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary backgroundbox
proc `handlename`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `linex=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex=`*(ih: BackgroundBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: BackgroundBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEX"))

proc `liney=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney=`*(ih: BackgroundBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: BackgroundBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEY"))

proc `maxsize=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: BackgroundBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: BackgroundBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: BackgroundBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: BackgroundBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary backgroundbox
proc `name`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary backgroundbox
proc `normalizergroup`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary backgroundbox
proc `ntheme`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: backgroundbox PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: backgroundbox PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: BackgroundBox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: BackgroundBox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `posx=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx=`*(ih: BackgroundBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: BackgroundBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSX"))

proc `posy=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy=`*(ih: BackgroundBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: BackgroundBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSY"))

proc `propagatefocus=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: BackgroundBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: BackgroundBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `sb_resize`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_RESIZE"))

proc `screenposition`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `scrollbar=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR")) == "YES"

proc `size=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: BackgroundBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: BackgroundBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary backgroundbox
proc `theme`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary backgroundbox
proc `tip`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: BackgroundBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: BackgroundBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: BackgroundBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: BackgroundBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: BackgroundBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: BackgroundBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary backgroundbox
proc `tipicon`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary backgroundbox
proc `tipmarkup`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: BackgroundBox_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: BackgroundBox_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `touch=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOUCH")) == "YES"

proc `usersize=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: BackgroundBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: BackgroundBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wheeldropfocus=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS")) == "YES"

proc `wid`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

proc `xautohide=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE")) == "YES"

proc `xdisplay`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XDISPLAY"))

# TODO unknown: backgroundbox XFONTID Unknown Binary
proc `xfontid`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `xhidden`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XHIDDEN")) == "YES"

proc `xmax=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax=`*(ih: BackgroundBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: BackgroundBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMAX"))

proc `xmin=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin=`*(ih: BackgroundBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: BackgroundBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMIN"))

# TODO unknown: backgroundbox XWINDOW Unknown Binary
proc `xwindow`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `yautohide=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide=`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: BackgroundBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE")) == "YES"

proc `yhidden`*(ih: BackgroundBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YHIDDEN")) == "YES"

proc `ymax=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax=`*(ih: BackgroundBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: BackgroundBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMAX"))

proc `ymin=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin=`*(ih: BackgroundBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: BackgroundBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: BackgroundBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMIN"))

proc `zorder=`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: BackgroundBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `destroy_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: BackgroundBox_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: BackgroundBox_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `focus_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `keypress_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    # KEYPRESS_CB KEYPRESS_CB Action generated when a key is pressed
    # or released. If the key is pressed and held several calls will
    # occur. It is called after the callback K_ANY is processed.
    # Callback int function(Ihandle *ih, int c, int press); [in C]
    # ih:keypress_cb(c, press: number) -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. c:
    # identifier of typed key. Please refer to the Keyboard Codes
    # table for a list of possible values. press: 1 is the user
    # pressed the key or 0 otherwise. Returns: If IUP_IGNORE is
    # returned the key is ignored by the system. IUP_CLOSE will be
    # processed. Affects IupCanvas
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB")))

proc `killfocus_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `postmessage_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `scroll_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    # SCROLL_CB SCROLL_CB Called when some manipulation is made to the
    # scrollbar. The canvas is automatically redrawn only if this
    # callback is NOT defined. (GTK 2.8) Also the POSX and POSY values
    # will not be correctly updated for older GTK versions. In Ubuntu,
    # when liboverlay-scrollbar is enabled (the new tiny auto-hide
    # scrollbar) only the IUP_SBPOSV and IUP_SBPOSH codes are used.
    # Callback int function(Ihandle *ih, int op, float posx, float
    # posy); [in C] ih:scroll_cb(op, posx, posy: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. op: indicates the operation performed on the
    # scrollbar. If the manipulation was made on the vertical
    # scrollbar, it can have the following values: IUP_SBUP - line up
    # IUP_SBDN - line down IUP_SBPGUP - page up IUP_SBPGDN - page down
    # IUP_SBPOSV - vertical positioning IUP_SBDRAGV - vertical drag If
    # it was on the horizontal scrollbar, the following values are
    # valid: IUP_SBLEFT - column left IUP_SBRIGHT - column right
    # IUP_SBPGLEFT - page left IUP_SBPGRIGHT - page right IUP_SBPOSH -
    # horizontal positioning IUP_SBDRAGH - horizontal drag posx, posy:
    # the same as the ACTION canvas callback (corresponding to the
    # values of attributes POSX and POSY). Notes IUP_SBDRAGH and
    # IUP_SBDRAGV are not supported in GTK. During drag IUP_SBPOSH and
    # IUP_SBPOSV are used. In Windows, after a drag when mouse is
    # released IUP_SBPOSH or IUP_SBPOSV are called. Affects IupCanvas,
    # IupGLCanvas, SCROLLBAR
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SCROLL_CB")))

proc `unmap_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `wheel_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # WHEEL_CB WHEEL_CB Action generated when the mouse wheel is
    # rotated. If this callback is not defined the wheel will
    # automatically scroll the canvas in the vertical direction by
    # some lines, the SCROLL_CB callback if defined will be called
    # with the IUP_SBDRAGV operation. Callback int function(Ihandle
    # *ih, float delta, int x, int y, char *status); [in C]
    # ih:wheel_cb(delta, x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. delta: the amount the wheel was rotated in notches.
    # x, y: position in the canvas where the event has occurred, in
    # pixels. status: status of mouse buttons and certain keyboard
    # keys at the moment the event was generated. The same macros used
    # for BUTTON_CB can be used for this status. Notes In Motif and
    # GTK delta is always 1 or -1. In Windows is some situations delta
    # can reach the value of two. In the future with more precise
    # wheels this increment can be changed. Affects IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WHEEL_CB")))

proc `wom_cb=`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # WOM_CB WOM_CB Action generated when an audio device receives an
    # event. [Windows Only] Callback int function(Ihandle *ih, int
    # state); [in C] ih:wom_cb(state: number) -> (ret: number) [in
    # Lua] ih: identifies the element that activated the event. state:
    # can be opening=1, done=0, or closing=-1. Notes This callback is
    # used to syncronize video playback with audio. It is sent when
    # the audio device: Message Description opening is opened by using
    # the waveOutOpen function. done is finished with a data block
    # sent by using the waveOutWrite function. closing is closed by
    # using the waveOutClose function. You must use the HWND attribute
    # when calling waveOutOpen in the dwCallback parameter and set
    # fdwOpen to CALLBACK_WINDOW. Affects IupDialog, IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: BackgroundBox_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: BackgroundBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WOM_CB")))

proc Button*(title: string; action: string): Button_t {.cdecl.} =
    # Creates an interface element that is a button. When selected,
    # this element activates a function in the application. Its visual
    # presentation can contain a text and/or an image.
    return Button_t(niupc.Button(cstring(title), cstring(action)))

proc Button*(title:string): Button_t {.cdecl.} =
    # Creates an interface element that is a button. When selected,
    # this element activates a function in the application. Its visual
    # presentation can contain a text and/or an image.
    return Button_t(niupc.Button(title, nil))

proc `active=`*(ih: Button_t, value: string) {.cdecl.} =
    # ACTIVE, FONT, EXPAND, SCREENPOSITION, POSITION, MINSIZE,
    # MAXSIZE, WID, TIP, SIZE, RASTERSIZE, ZORDER, VISIBLE, THEME:
    # also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Button_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Button_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Button_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `alignment=`*(ih: Button_t, value: string) {.cdecl.} =
    # ALIGNMENT (non inheritable): horizontal and vertical alignment.
    # Possible values: "ALEFT", "ACENTER" and "ARIGHT", combined to
    # "ATOP", "ACENTER" and "ABOTTOM". Default: "ACENTER:ACENTER".
    # Partial values are also accepted, like "ARIGHT" or ":ATOP", the
    # other value will be obtained from the default value. In Motif,
    # vertical alignment is restricted to "ACENTER". In GTK,
    # horizontal alignment for multiple lines will align only the text
    # block. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"))

proc `bgcolor=`*(ih: Button_t, value: string) {.cdecl.} =
    # BGCOLOR: Background color. If text and image are not defined,
    # the button is configured to simply show a color, in this case
    # set the button size because the natural size will be very small.
    # In Windows and in GTK 3, the BGCOLOR attribute is ignored if
    # text or image is defined. Default: the global attribute
    # DLGBGCOLOR. BGCOLOR is ignored when FLAT=YES because it will be
    # used the background from the native parent. The buttons with
    # image and text simultaneous have PADDING=5x5, the other buttons
    # have no padding. The buttons with no text and BGCOLOR defined
    # have their RASTERSIZE set. Motif Windows Classic Windows w/
    # Styles GTK
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: Button_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Button_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `canfocus=`*(ih: Button_t, value: string) {.cdecl.} =
    # CANFOCUS (creation only) (non inheritable): enables the focus
    # traversal of the control. In Windows the button will respect
    # CANFOCUS differently to some other controls. Default: YES.
    # (since 3.0). Buttons are not activated if the user clicks inside
    # the button but moves the cursor and releases outside the button
    # area. Also in Windows the highlight feedback when that happens
    # is different if the button has CANFOCUS enabled or not.
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Button_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Button_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Button_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `cpadding=`*(ih: Button_t, value: string) {.cdecl.} =
    # CPADDING: same as PADDING but using the units of the SIZE
    # attribute. It will actually set the PADDING attribute. (since
    # 3.29)
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding=`*(ih: Button_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: Button_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CPADDING"))

proc `cspacing=`*(ih: Button_t, value: string) {.cdecl.} =
    # CSPACING: same as SPACING but using the units of the vertical
    # part of the SIZE attribute. It will actually set the SPACING
    # attribute. (since 3.29)
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(value))

proc `cspacing`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(value))

proc `cspacing=`*(ih: Button_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(&"{x}"))

proc `cspacing`*(ih: Button_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(&"{x}"))

proc `cspacing`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CSPACING"))

proc `expand=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Button_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Button_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `fgcolor=`*(ih: Button_t, value: string) {.cdecl.} =
    # FGCOLOR: Text color. Default: the global attribute DLGFGCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: Button_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: Button_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

proc `flat=`*(ih: Button_t, value: string) {.cdecl.} =
    # FLAT (creation only): Hides the button borders until the mouse
    # cursor enters the button area. The border space is always there.
    # Can be YES or NO. Default: NO.
    SetAttribute(cast[PIhandle](ih), cstring("FLAT"), cstring(value))

proc `flat`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLAT"), cstring(value))

proc `flat=`*(ih: Button_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLAT"), cstring((if yes: "YES" else: "NO")))

proc `flat`*(ih: Button_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLAT"), cstring((if yes: "YES" else: "NO")))

proc `flat`*(ih: Button_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLAT")) == "YES"

proc `floating=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

# TODO unknown: button FOCUSONCLICK Unknown Binary
proc `focusonclick`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FOCUSONCLICK"))

proc `font=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary button
proc `font`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary button
proc `fontface`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Button_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Button_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary button
proc `fontstyle`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary button
proc `handlename`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `image=`*(ih: Button_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGE (non inheritable): Image name. If set before map defines
    # the behavior of the button to contain an image. The natural size
    # will be size of the image in pixels, plus the button borders.
    # Use IupSetHandle or IupSetAttributeHandle to associate an image
    # to a name. See also IupImage. If TITLE is also defined and not
    # empty both will be shown (except in Motif). (GTK 2.6). Buttons
    # always have borders, except when IMAGE and IMPRESS are both
    # defined and IMPRESSBORDER=NO. In this case in Windows TITLE can
    # also be defined.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: Button_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGE"))

proc `imageposition=`*(ih: Button_t, value: string) {.cdecl.} =
    # IMAGEPOSITION (non inheritable): Position of the image relative
    # to the text when both are displayed. Can be: LEFT, RIGHT, TOP,
    # BOTTOM. Default: LEFT. (since 3.0) (GTK 2.10)
    SetAttribute(cast[PIhandle](ih), cstring("IMAGEPOSITION"), cstring(value))

proc `imageposition`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("IMAGEPOSITION"), cstring(value))

proc `imageposition`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEPOSITION"))

proc `iminactive=`*(ih: Button_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMINACTIVE (non inheritable): Image name of the element when
    # inactive. If it is not defined then the IMAGE is used and the
    # colors will be replaced by a modified version of the background
    # color creating the disabled effect. GTK will also change the
    # inactive image to look like other inactive objects. (GTK 2.6)
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMINACTIVE"), cast[PIhandle](handle))

proc `iminactive`*(ih: Button_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMINACTIVE"), cast[PIhandle](handle))

proc `iminactive`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMINACTIVE"))

proc `impress=`*(ih: Button_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMPRESS (non inheritable): Image name of the pressed button. If
    # IMPRESS and IMAGE are defined, the button borders are not shown
    # and not computed in natural size. When the button is clicked the
    # pressed image does not offset. In Motif the button will lose its
    # focus feedback also. (GTK 2.6). Buttons always have borders,
    # except when IMAGE and IMPRESS are both defined and
    # IMPRESSBORDER=NO. In this case in Windows TITLE can also be
    # defined.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMPRESS"), cast[PIhandle](handle))

proc `impress`*(ih: Button_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMPRESS"), cast[PIhandle](handle))

proc `impress`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMPRESS"))

# TODO unknown: button IMPRESSBORDER Unknown Binary
proc `impressborder`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMPRESSBORDER"))

proc `markup=`*(ih: Button_t, value: string) {.cdecl.} =
    # MARKUP [GTK only]: allows the title string to contains pango
    # markup commands. Works only if a mnemonic is NOT defined in the
    # title. Can be "YES" or "NO". Default: "NO".
    SetAttribute(cast[PIhandle](ih), cstring("MARKUP"), cstring(value))

proc `markup`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKUP"), cstring(value))

proc `markup=`*(ih: Button_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKUP"), cstring((if yes: "YES" else: "NO")))

proc `markup`*(ih: Button_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKUP"), cstring((if yes: "YES" else: "NO")))

proc `markup`*(ih: Button_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MARKUP")) == "YES"

proc `maxsize=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Button_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Button_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Button_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Button_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary button
proc `name`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary button
proc `normalizergroup`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary button
proc `ntheme`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `padding=`*(ih: Button_t, value: string) {.cdecl.} =
    # PADDING: internal margin. Works just like the MARGIN attribute
    # of the IupHbox and IupVbox containers, but uses a different name
    # to avoid inheritance problems. Default value: "0x0". Value can
    # be DEFAULTBUTTONPADDING, so the global attribute of this name
    # will be used instead (since 3.29). (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding=`*(ih: Button_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: Button_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PADDING"))

# TODO unknown: button PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: button PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Button_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Button_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Button_t, value: string) {.cdecl.} =
    # PROPAGATEFOCUS(non inheritable): enables the focus callback
    # forwarding to the next native parent with FOCUS_CB defined.
    # Default: NO. (since 3.23)
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Button_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Button_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Button_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Button_t, value: string) {.cdecl.} =
    # The buttons with image and text simultaneous have PADDING=5x5,
    # the other buttons have no padding. The buttons with no text and
    # BGCOLOR defined have their RASTERSIZE set. Motif Windows Classic
    # Windows w/ Styles GTK
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Button_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Button_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `screenposition`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `size=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Button_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Button_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `spacing=`*(ih: Button_t, value: string) {.cdecl.} =
    # SPACING (creation only): defines the spacing between the image
    # associated and the button's text. Default: "2".
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(value))

proc `spacing`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(value))

proc `spacing=`*(ih: Button_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(&"{x}"))

proc `spacing`*(ih: Button_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(&"{x}"))

proc `spacing`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPACING"))

proc `theme=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary button
proc `theme`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary button
proc `tip`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: Button_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Button_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: Button_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Button_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: Button_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Button_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary button
proc `tipicon`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary button
proc `tipmarkup`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: Button_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Button_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: Button_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Button_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Button_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `title=`*(ih: Button_t, value: string) {.cdecl.} =
    # TITLE (non inheritable): Button's text. If IMAGE is not defined
    # before map, then the default behavior is to contain only a text.
    # The button behavior can not be changed after map. The natural
    # size will be larger enough to include all the text in the
    # selected font, even using multiple lines, plus the button
    # borders. The '\n' character is accepted for line change. The "&"
    # character can be used to define a mnemonic, the next character
    # will be used as key. Use "&&" to show the "&" character instead
    # on defining a mnemonic. The button can be activated from any
    # control in the dialog using the "Alt+key" combination. In old
    # Motif versions (2.1) using a '\n' causes an invalid memory
    # access inside Motif. (mnemonic support since 3.0). Buttons
    # always have borders, except when IMAGE and IMPRESS are both
    # defined and IMPRESSBORDER=NO. In this case in Windows TITLE can
    # also be defined.
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary button
proc `title`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

proc `usersize=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Button_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Button_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Button_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Button_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Button_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

# TODO unknown: button XFONTID Unknown Binary
proc `xfontid`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `y`*(ih: Button_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `zorder=`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: Button_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: Button_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: Button_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: Button_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: Button_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: Button_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: Button_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `destroy_cb=`*(ih: Button_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Button_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Button_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `enterwindow_cb=`*(ih: Button_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Button_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Button_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `getfocus_cb=`*(ih: Button_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Button_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Button_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: Button_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Button_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Button_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `killfocus_cb=`*(ih: Button_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Button_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Button_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: Button_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Button_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Button_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: Button_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Button_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Button_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: Button_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Button_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Button_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: Button_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Button_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Button_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: Button_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Button_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Button_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: Button_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Button_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Button_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc Calendar*(): Calendar_t {.cdecl.} =
    # Creates a month calendar interface element, where the user can
    # select a date. GTK and Windows only. NOT available in Motif.
    return Calendar_t(niupc.Calendar())

proc `active=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Calendar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Calendar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Calendar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `canfocus=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Calendar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Calendar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Calendar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `expand=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Calendar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Calendar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary calendar
proc `font`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary calendar
proc `fontface`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Calendar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Calendar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary calendar
proc `fontstyle`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary calendar
proc `handlename`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `maxsize=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Calendar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Calendar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Calendar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Calendar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary calendar
proc `name`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary calendar
proc `normalizergroup`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary calendar
proc `ntheme`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: calendar PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: calendar PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Calendar_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Calendar_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Calendar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Calendar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Calendar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Calendar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Calendar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `screenposition`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `size=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Calendar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Calendar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary calendar
proc `theme`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary calendar
proc `tip`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: Calendar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Calendar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: Calendar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Calendar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: Calendar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Calendar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary calendar
proc `tipicon`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary calendar
proc `tipmarkup`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: Calendar_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Calendar_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: Calendar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Calendar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Calendar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `today`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TODAY"))

proc `usersize=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Calendar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Calendar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: Calendar_t, value: string) {.cdecl.} =
    # VALUE: the current date always in the format "year/month/day"
    # ("%d/%d/%d" in C). Can be set to "TODAY". Default value is the
    # today date.
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

# TODO ??? String Binary calendar
proc `value`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `visible=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Calendar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Calendar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Calendar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

# TODO unknown: calendar WEEKNUMBERS Unknown Binary
proc `weeknumbers`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WEEKNUMBERS"))

proc `wid`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

# TODO unknown: calendar XFONTID Unknown Binary
proc `xfontid`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `y`*(ih: Calendar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `zorder=`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: Calendar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `destroy_cb=`*(ih: Calendar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Calendar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Calendar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `enterwindow_cb=`*(ih: Calendar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Calendar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Calendar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `getfocus_cb=`*(ih: Calendar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Calendar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Calendar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: Calendar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Calendar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Calendar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `killfocus_cb=`*(ih: Calendar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Calendar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Calendar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: Calendar_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Calendar_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Calendar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: Calendar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Calendar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Calendar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: Calendar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Calendar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Calendar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: Calendar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Calendar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Calendar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: Calendar_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Calendar_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Calendar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: Calendar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Calendar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Calendar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `valuechanged_cb=`*(ih: Calendar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # VALUECHANGED_CB: Called after the value was interactively
    # changed by the user. int function(Ihandle *ih); [in
    # C]ih:valuechanged_cb() -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: Calendar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: Calendar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB")))

proc Canvas*(action: string): Canvas_t {.cdecl.} =
    # Creates an interface element that is a canvas - a drawing area
    # for your application.
    return Canvas_t(niupc.Canvas(cstring(action)))

proc Canvas*(): Canvas_t {.cdecl.} =
    # Creates an interface element that is a canvas - a drawing area
    # for your application.
    return Canvas_t(niupc.Canvas(nil))

proc `active=`*(ih: Canvas_t, value: string) {.cdecl.} =
    # ACTIVE, FONT, SCREENPOSITION, POSITION, MINSIZE, MAXSIZE, WID,
    # TIP, SIZE, RASTERSIZE, ZORDER, VISIBLE, THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `backingstore=`*(ih: Canvas_t, value: string) {.cdecl.} =
    # BACKINGSTORE [Motif Only]: Controls the canvas backing store
    # flag. The default value is "YES".
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE")) == "YES"

proc `bgcolor=`*(ih: Canvas_t, value: string) {.cdecl.} =
    # BGCOLOR: Background color. The background is painted only if the
    # ACTION callback is not defined. If the callback is defined the
    # application must draw all the canvas contents. In GTK or Motif
    # if you set the ACTION callback after map then you should also
    # set BGCOLOR to any value just after setting the callback or the
    # first redraw will be lost. Default: "255 255 255".
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: Canvas_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Canvas_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border=`*(ih: Canvas_t, value: string) {.cdecl.} =
    # BORDER (creation only): Shows a border around the canvas.
    # Default: "YES". Notice that the drawing area size is not the
    # same as RASTERSIZE. The SCROLLBAR and BORDER attributes affect
    # the size of the drawing area.
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `canfocus=`*(ih: Canvas_t, value: string) {.cdecl.} =
    # CANFOCUS (creation only) (non inheritable): enables the focus
    # traversal of the control. In Windows the canvas will respect
    # CANFOCUS differently to some other controls. Default: YES.
    # (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `cursor=`*(ih: Canvas_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # CURSOR (non inheritable): Defines a cursor for the canvas. The
    # Windows SDK recommends that cursors and icons should be
    # implemented as resources rather than created at run time.
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: Canvas_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `dragdrop=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary canvas
proc `dragtypes`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

# TODO unknown: canvas DRAWABLE Unknown Binary
proc `drawable`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWABLE"))

proc `drawbgcolor=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor=`*(ih: Canvas_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: Canvas_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"))

proc `drawcolor=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor=`*(ih: Canvas_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: Canvas_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"))

proc `drawdriver`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWDRIVER"))

proc `drawfont=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

proc `drawfont`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

# TODO ??? String Binary canvas
proc `drawfont`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"))

proc `drawlinewidth=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth=`*(ih: Canvas_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: Canvas_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"))

proc `drawmakeinactive=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE")) == "YES"

proc `drawsize`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSIZE"))

proc `drawstyle=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"))

proc `drawtextalignment=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"))

proc `drawtextclip=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP")) == "YES"

proc `drawtextellipsis=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS")) == "YES"

proc `drawtextlayoutcenter=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER")) == "YES"

proc `drawtextorientation=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation=`*(ih: Canvas_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: Canvas_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"))

proc `drawtextwrap=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP")) == "YES"

proc `dropfilestarget=`*(ih: Canvas_t, value: string) {.cdecl.} =
    # DROPFILESTARGET [Windows and GTK Only] (non inheritable): Enable
    # or disable the drop of files. Default: NO, but if DROPFILES_CB
    # is defined when the element is mapped then it will be
    # automatically enabled.
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary canvas
proc `droptypes`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `dx=`*(ih: Canvas_t, value: string) {.cdecl.} =
    # DX: Size of the thumb in the horizontal scrollbar. Also the
    # horizontal page size. Default: "0.1". DY: Size of the thumb in
    # the vertical scrollbar. Also the vertical page size. Default:
    # "0.1". POSX: Position of the thumb in the horizontal scrollbar.
    # Default: "0.0". POSY: Position of the thumb in the vertical
    # scrollbar. Default: "0.0". XMIN: Minimum value of the horizontal
    # scrollbar. Default: "0.0". XMAX: Maximum value of the horizontal
    # scrollbar. Default: "1.0". YMIN: Minimum value of the vertical
    # scrollbar. Default: "0.0". YMAX: Maximum value of the vertical
    # scrollbar. Default: "1.0". LINEX: The amount the thumb moves
    # when an horizontal step is performed. Default: 1/10th of DX.
    # (since 3.0) LINEY: The amount the thumb moves when a vertical
    # step is performed. Default: 1/10th of DY. (since 3.0) XAUTOHIDE:
    # When enabled, if DX >= XMAX-XMIN then the horizontal scrollbar
    # is hidden. Default: "YES". (since 3.0) YAUTOHIDE: When enabled,
    # if DY >= YMAX-YMIN then the vertical scrollbar is hidden.
    # Default: "YES". (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx=`*(ih: Canvas_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: Canvas_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DX"))

proc `dy=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy=`*(ih: Canvas_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: Canvas_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DY"))

proc `expand=`*(ih: Canvas_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable): The default value is "YES". The
    # natural size is the size of 1 character.
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Canvas_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Canvas_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary canvas
proc `font`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary canvas
proc `fontface`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Canvas_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Canvas_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary canvas
proc `fontstyle`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary canvas
proc `handlename`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `linex=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex=`*(ih: Canvas_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: Canvas_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEX"))

proc `liney=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney=`*(ih: Canvas_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: Canvas_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEY"))

proc `maxsize=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Canvas_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Canvas_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Canvas_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Canvas_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary canvas
proc `name`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary canvas
proc `normalizergroup`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary canvas
proc `ntheme`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: canvas PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: canvas PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Canvas_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Canvas_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `posx=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx=`*(ih: Canvas_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: Canvas_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSX"))

proc `posy=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy=`*(ih: Canvas_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: Canvas_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSY"))

proc `propagatefocus=`*(ih: Canvas_t, value: string) {.cdecl.} =
    # PROPAGATEFOCUS(non inheritable): enables the focus callback
    # forwarding to the next native parent with FOCUS_CB defined.
    # Default: NO. (since 3.23)
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Canvas_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Canvas_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `sb_resize`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_RESIZE"))

proc `screenposition`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `scrollbar=`*(ih: Canvas_t, value: string) {.cdecl.} =
    # Notice that the drawing area size is not the same as RASTERSIZE.
    # The SCROLLBAR and BORDER attributes affect the size of the
    # drawing area. SCROLLBAR (creation only): Associates a horizontal
    # and/or vertical scrollbar to the canvas. Default: "NO". The
    # secondary attributes are all non inheritable.
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR")) == "YES"

proc `size=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Canvas_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Canvas_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary canvas
proc `theme`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary canvas
proc `tip`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: Canvas_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Canvas_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: Canvas_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Canvas_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: Canvas_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Canvas_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary canvas
proc `tipicon`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary canvas
proc `tipmarkup`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: Canvas_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Canvas_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `touch=`*(ih: Canvas_t, value: string) {.cdecl.} =
    # TOUCH [Windows 7 Only]: enable the multi-touch events
    # processing. (since 3.3)
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOUCH")) == "YES"

proc `usersize=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Canvas_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Canvas_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wheeldropfocus=`*(ih: Canvas_t, value: string) {.cdecl.} =
    # WHEELDROPFOCUS (non inheritable): when the wheel is used the
    # focus control receives a SHOWDROPDOWN=No. (since 3.28)
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS")) == "YES"

proc `wid`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

proc `xautohide=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE")) == "YES"

proc `xdisplay`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XDISPLAY"))

# TODO unknown: canvas XFONTID Unknown Binary
proc `xfontid`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `xhidden`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XHIDDEN")) == "YES"

proc `xmax=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax=`*(ih: Canvas_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: Canvas_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMAX"))

proc `xmin=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin=`*(ih: Canvas_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: Canvas_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMIN"))

# TODO unknown: canvas XWINDOW Unknown Binary
proc `xwindow`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `yautohide=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide=`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: Canvas_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE")) == "YES"

proc `yhidden`*(ih: Canvas_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YHIDDEN")) == "YES"

proc `ymax=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax=`*(ih: Canvas_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: Canvas_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMAX"))

proc `ymin=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin=`*(ih: Canvas_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: Canvas_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: Canvas_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMIN"))

proc `zorder=`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: Canvas_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: Canvas_t, cb: proc (ih: PIhandle, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: Canvas_t, cb: proc (ih: PIhandle, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `destroy_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: Canvas_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: Canvas_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `focus_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    # FOCUS_CB: Called when the canvas gets or looses the focus. It is
    # called after the common callbacks GETFOCUS_CB and KILL_FOCUS_CB.
    # int function(Ihandle *ih, int focus); [in C]ih:focus_cb(focus:
    # number) -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `keypress_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    # KEYPRESS_CB KEYPRESS_CB Action generated when a key is pressed
    # or released. If the key is pressed and held several calls will
    # occur. It is called after the callback K_ANY is processed.
    # Callback int function(Ihandle *ih, int c, int press); [in C]
    # ih:keypress_cb(c, press: number) -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. c:
    # identifier of typed key. Please refer to the Keyboard Codes
    # table for a list of possible values. press: 1 is the user
    # pressed the key or 0 otherwise. Returns: If IUP_IGNORE is
    # returned the key is ignored by the system. IUP_CLOSE will be
    # processed. Affects IupCanvas
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB")))

proc `killfocus_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: Canvas_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Canvas_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `postmessage_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `scroll_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    # SCROLL_CB SCROLL_CB Called when some manipulation is made to the
    # scrollbar. The canvas is automatically redrawn only if this
    # callback is NOT defined. (GTK 2.8) Also the POSX and POSY values
    # will not be correctly updated for older GTK versions. In Ubuntu,
    # when liboverlay-scrollbar is enabled (the new tiny auto-hide
    # scrollbar) only the IUP_SBPOSV and IUP_SBPOSH codes are used.
    # Callback int function(Ihandle *ih, int op, float posx, float
    # posy); [in C] ih:scroll_cb(op, posx, posy: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. op: indicates the operation performed on the
    # scrollbar. If the manipulation was made on the vertical
    # scrollbar, it can have the following values: IUP_SBUP - line up
    # IUP_SBDN - line down IUP_SBPGUP - page up IUP_SBPGDN - page down
    # IUP_SBPOSV - vertical positioning IUP_SBDRAGV - vertical drag If
    # it was on the horizontal scrollbar, the following values are
    # valid: IUP_SBLEFT - column left IUP_SBRIGHT - column right
    # IUP_SBPGLEFT - page left IUP_SBPGRIGHT - page right IUP_SBPOSH -
    # horizontal positioning IUP_SBDRAGH - horizontal drag posx, posy:
    # the same as the ACTION canvas callback (corresponding to the
    # values of attributes POSX and POSY). Notes IUP_SBDRAGH and
    # IUP_SBDRAGV are not supported in GTK. During drag IUP_SBPOSH and
    # IUP_SBPOSV are used. In Windows, after a drag when mouse is
    # released IUP_SBPOSH or IUP_SBPOSV are called. Affects IupCanvas,
    # IupGLCanvas, SCROLLBAR
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SCROLL_CB")))

proc `unmap_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `wheel_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # WHEEL_CB WHEEL_CB Action generated when the mouse wheel is
    # rotated. If this callback is not defined the wheel will
    # automatically scroll the canvas in the vertical direction by
    # some lines, the SCROLL_CB callback if defined will be called
    # with the IUP_SBDRAGV operation. Callback int function(Ihandle
    # *ih, float delta, int x, int y, char *status); [in C]
    # ih:wheel_cb(delta, x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. delta: the amount the wheel was rotated in notches.
    # x, y: position in the canvas where the event has occurred, in
    # pixels. status: status of mouse buttons and certain keyboard
    # keys at the moment the event was generated. The same macros used
    # for BUTTON_CB can be used for this status. Notes In Motif and
    # GTK delta is always 1 or -1. In Windows is some situations delta
    # can reach the value of two. In the future with more precise
    # wheels this increment can be changed. Affects IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WHEEL_CB")))

proc `wom_cb=`*(ih: Canvas_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # WOM_CB WOM_CB Action generated when an audio device receives an
    # event. [Windows Only] Callback int function(Ihandle *ih, int
    # state); [in C] ih:wom_cb(state: number) -> (ret: number) [in
    # Lua] ih: identifies the element that activated the event. state:
    # can be opening=1, done=0, or closing=-1. Notes This callback is
    # used to syncronize video playback with audio. It is sent when
    # the audio device: Message Description opening is opened by using
    # the waveOutOpen function. done is finished with a data block
    # sent by using the waveOutWrite function. closing is closed by
    # using the waveOutClose function. You must use the HWND attribute
    # when calling waveOutOpen in the dwCallback parameter and set
    # fdwOpen to CALLBACK_WINDOW. Affects IupDialog, IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: Canvas_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: Canvas_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WOM_CB")))

macro Cbox*(args: varargs[untyped]): Cbox_t =
    # Creates a void container for position elements in absolute
    # coordinates. It is a concrete layout container. It does not have
    # a native representation. The IupCbox is equivalent of a IupVbox
    # or IupHbox where all the children have the FLOATING attribute
    # set to YES, but children must use CX and CY attributes instead
    # of the POSITION attribute.


    result = nnkCall.newTree(
        nnkDotExpr.newTree(
            newIdentNode("niup"),
            newIdentNode("Cbox_t")
          ),
       )
    let inner = nnkCall.newTree(
            newIdentNode("Cbox")
          )

    if args.len > 0:
        for i in 0 ..< args.len:
          inner.add nnkCast.newTree(newIdentNode("PIhandle"), args[i])
    inner.add newNilLit()
    result.add inner


proc `active=`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Cbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Cbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Cbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `canfocus=`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Cbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Cbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Cbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `clientoffset`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `expand=`*(ih: Cbox_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable): The default value is "YES".
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Cbox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Cbox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Cbox_t, value: string) {.cdecl.} =
    # FONT, CLIENTSIZE, CLIENTOFFSET, POSITION, MINSIZE, MAXSIZE,
    # THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary cbox
proc `font`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary cbox
proc `fontface`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Cbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Cbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary cbox
proc `fontstyle`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary cbox
proc `handlename`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `maxsize=`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Cbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Cbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Cbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Cbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary cbox
proc `name`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary cbox
proc `normalizergroup`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary cbox
proc `ntheme`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: cbox PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: cbox PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Cbox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Cbox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Cbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Cbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Cbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Cbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Cbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `size=`*(ih: Cbox_t, value: string) {.cdecl.} =
    # SIZE / RASTERSIZE (non inheritable): Must be defined for each
    # child. If not defined for the box, then it will be the bounding
    # box that includes all children in their position.
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Cbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Cbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary cbox
proc `theme`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `usersize=`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Cbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Cbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Cbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Cbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Cbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Cbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

# TODO unknown: cbox XFONTID Unknown Binary
proc `xfontid`*(ih: Cbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `destroy_cb=`*(ih: Cbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Cbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Cbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `ldestroy_cb=`*(ih: Cbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Cbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Cbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: Cbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Cbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Cbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: Cbox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Cbox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Cbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: Cbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Cbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Cbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc Clipboard*(): Clipboard_t {.cdecl.} =
    # Creates an element that allows access to the clipboard. Each
    # clipboard should be destroyed using IupDestroy, but you can use
    # only one for the entire application because it does not store
    # any data inside. Or you can simply create and destroy every time
    # you need to copy or paste.
    return Clipboard_t(niupc.Clipboard())

# TODO unknown: clipboard ADDFORMAT Unknown Binary
proc `format=`*(ih: Clipboard_t, value: string) {.cdecl.} =
    # FORMAT: set the current format to be used by the FORMATAVAILABLE
    # and FORMATDATA attributes. This is a custom format string. The
    # application copy and paste functions must know what it is
    # copying and pasting in FORMATDATA based on that string. (since
    # 3.7)
    SetAttribute(cast[PIhandle](ih), cstring("FORMAT"), cstring(value))

proc `format`*(ih: Clipboard_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FORMAT"), cstring(value))

# TODO ??? String Binary clipboard
proc `format`*(ih: Clipboard_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FORMAT"))

proc `formatavailable`*(ih: Clipboard_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FORMATAVAILABLE"))

# TODO unknown: clipboard FORMATDATA Unknown Binary
proc `formatdata`*(ih: Clipboard_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FORMATDATA"))

# TODO unknown: clipboard FORMATDATASIZE Unknown Binary
proc `formatdatasize`*(ih: Clipboard_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FORMATDATASIZE"))

# TODO unknown: clipboard FORMATDATASTRING Unknown Binary
proc `formatdatastring`*(ih: Clipboard_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FORMATDATASTRING"))

proc `image=`*(ih: Clipboard_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGE (write-only): name of an image to copy to the clipboard.
    # If set to NULL clears the clipboard data. (GTK 2.6)
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: Clipboard_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `imageavailable`*(ih: Clipboard_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEAVAILABLE"))

# TODO unknown: clipboard NATIVEIMAGE Unknown Binary
proc `nativeimage`*(ih: Clipboard_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATIVEIMAGE"))

proc `text=`*(ih: Clipboard_t, value: string) {.cdecl.} =
    # TEXT: copy or paste text to or from the clipboard. If set to
    # NULL clears the clipboard data.
    SetAttribute(cast[PIhandle](ih), cstring("TEXT"), cstring(value))

proc `text`*(ih: Clipboard_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXT"), cstring(value))

# TODO ??? String Binary clipboard
proc `text`*(ih: Clipboard_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXT"))

proc `textavailable`*(ih: Clipboard_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTAVAILABLE"))

proc Colorbar*(): Colorbar_t {.cdecl.} =
    # Creates a color palette to enable a color selection from several
    # samples. It can select one or two colors. The primary color is
    # selected with the left mouse button, and the secondary color is
    # selected with the right mouse button. You can double click a
    # cell to change its color and you can double click the preview
    # area to switch between primary and secondary colors. (Migrated
    # from the IupControls library since IUP 3.24, it does not depend
    # on the CD library anymore.) It inherits from IupCanvas.
    # Originally implemented by Andr Clinio.
    return Colorbar_t(niupc.Colorbar())

proc `active=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    # ACTIVE, BGCOLOR, FONT, SCREENPOSITION, POSITION, MINSIZE,
    # MAXSIZE, WID, TIP, EXPAND, SIZE, RASTERSIZE, ZORDER, VISIBLE,
    # THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `backingstore=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE")) == "YES"

proc `bgcolor=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: Colorbar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Colorbar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `canfocus=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

# TODO getter colorbar CELL
proc `charsize`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `count`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("COUNT"))

proc `cursor=`*(ih: Colorbar_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: Colorbar_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `dragdrop=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary colorbar
proc `dragtypes`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

# TODO unknown: colorbar DRAWABLE Unknown Binary
proc `drawable`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWABLE"))

proc `drawbgcolor=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor=`*(ih: Colorbar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: Colorbar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"))

proc `drawcolor=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor=`*(ih: Colorbar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: Colorbar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"))

proc `drawdriver`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWDRIVER"))

proc `drawfont=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

proc `drawfont`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

# TODO ??? String Binary colorbar
proc `drawfont`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"))

proc `drawlinewidth=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth=`*(ih: Colorbar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: Colorbar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"))

proc `drawmakeinactive=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE")) == "YES"

proc `drawsize`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSIZE"))

proc `drawstyle=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"))

proc `drawtextalignment=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"))

proc `drawtextclip=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP")) == "YES"

proc `drawtextellipsis=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS")) == "YES"

proc `drawtextlayoutcenter=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER")) == "YES"

proc `drawtextorientation=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation=`*(ih: Colorbar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: Colorbar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"))

proc `drawtextwrap=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP")) == "YES"

proc `dropfilestarget=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary colorbar
proc `droptypes`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `dx=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx=`*(ih: Colorbar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: Colorbar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DX"))

proc `dy=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy=`*(ih: Colorbar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: Colorbar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DY"))

proc `expand=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Colorbar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Colorbar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `flat=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    # FLAT: use a 1 pixel flat border instead of the default 3 pixels
    # sunken border. When enabled is the same as setting SHADOWED=NO.
    # Can be Yes or No. Default: No. (since 3.24)
    SetAttribute(cast[PIhandle](ih), cstring("FLAT"), cstring(value))

proc `flat`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLAT"), cstring(value))

proc `flat=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLAT"), cstring((if yes: "YES" else: "NO")))

proc `flat`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLAT"), cstring((if yes: "YES" else: "NO")))

proc `flat`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLAT")) == "YES"

proc `flatcolor=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    # FLATCOLOR: color of the border when FLAT=Yes and the preview
    # area borders. Default: "0 0 0". (since 3.24)
    SetAttribute(cast[PIhandle](ih), cstring("FLATCOLOR"), cstring(value))

proc `flatcolor`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLATCOLOR"), cstring(value))

proc `flatcolor=`*(ih: Colorbar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLATCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `flatcolor`*(ih: Colorbar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLATCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `flatcolor`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLATCOLOR"))

proc `floating=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

# TODO unknown: colorbar FOCUSSELECT Unknown Binary
proc `focusselect`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FOCUSSELECT"))

proc `font=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary colorbar
proc `font`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary colorbar
proc `fontface`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Colorbar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Colorbar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary colorbar
proc `fontstyle`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary colorbar
proc `handlename`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `linex=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex=`*(ih: Colorbar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: Colorbar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEX"))

proc `liney=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney=`*(ih: Colorbar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: Colorbar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEY"))

proc `maxsize=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Colorbar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Colorbar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Colorbar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Colorbar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary colorbar
proc `name`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary colorbar
proc `normalizergroup`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary colorbar
proc `ntheme`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: colorbar NUM_CELLS Unknown Binary
proc `num_cells`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NUM_CELLS"))

# TODO unknown: colorbar NUM_PARTS Unknown Binary
proc `num_parts`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NUM_PARTS"))

proc `orientation=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    # ORIENTATION: Controls the orientation. It can be "VERTICAL" or
    # "HORIZONTAL". Default: "VERTICAL".
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"))

# TODO unknown: colorbar PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: colorbar PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Colorbar_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Colorbar_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `posx=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx=`*(ih: Colorbar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: Colorbar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSX"))

proc `posy=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy=`*(ih: Colorbar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: Colorbar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSY"))

# TODO unknown: colorbar PREVIEW_SIZE Unknown Binary
proc `preview_size`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PREVIEW_SIZE"))

# TODO unknown: colorbar PRIMARY_CELL Unknown Binary
proc `primary_cell`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PRIMARY_CELL"))

proc `propagatefocus=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Colorbar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Colorbar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `sb_resize`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_RESIZE"))

proc `screenposition`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `scrollbar=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR")) == "YES"

# TODO unknown: colorbar SECONDARY_CELL Unknown Binary
proc `secondary_cell`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SECONDARY_CELL"))

# TODO unknown: colorbar SHADOWED Unknown Binary
proc `shadowed`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHADOWED"))

proc `show_preview=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    # SHOW_PREVIEW: Controls the display of the preview area. Default:
    # "YES".
    SetAttribute(cast[PIhandle](ih), cstring("SHOW_PREVIEW"), cstring(value))

proc `show_preview`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOW_PREVIEW"), cstring(value))

proc `show_preview=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOW_PREVIEW"), cstring((if yes: "YES" else: "NO")))

proc `show_preview`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOW_PREVIEW"), cstring((if yes: "YES" else: "NO")))

proc `show_preview`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOW_PREVIEW")) == "YES"

# TODO unknown: colorbar SHOW_SECONDARY Unknown Binary
proc `show_secondary`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOW_SECONDARY"))

proc `size=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    # SIZE: there is no initial size. You must define SIZE or
    # RASTERSIZE.
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Colorbar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Colorbar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

# TODO unknown: colorbar SQUARED Unknown Binary
proc `squared`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SQUARED"))

proc `theme=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary colorbar
proc `theme`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary colorbar
proc `tip`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: Colorbar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Colorbar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: Colorbar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Colorbar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: Colorbar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Colorbar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary colorbar
proc `tipicon`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary colorbar
proc `tipmarkup`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: Colorbar_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Colorbar_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `touch=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOUCH")) == "YES"

# TODO unknown: colorbar TRANSPARENCY Unknown Binary
proc `transparency`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRANSPARENCY"))

proc `usersize=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Colorbar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Colorbar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wheeldropfocus=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS")) == "YES"

proc `wid`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

proc `xautohide=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE")) == "YES"

proc `xdisplay`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XDISPLAY"))

# TODO unknown: colorbar XFONTID Unknown Binary
proc `xfontid`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `xhidden`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XHIDDEN")) == "YES"

proc `xmax=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax=`*(ih: Colorbar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: Colorbar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMAX"))

proc `xmin=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin=`*(ih: Colorbar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: Colorbar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMIN"))

# TODO unknown: colorbar XWINDOW Unknown Binary
proc `xwindow`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `yautohide=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide=`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: Colorbar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE")) == "YES"

proc `yhidden`*(ih: Colorbar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YHIDDEN")) == "YES"

proc `ymax=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax=`*(ih: Colorbar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: Colorbar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMAX"))

proc `ymin=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin=`*(ih: Colorbar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: Colorbar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: Colorbar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMIN"))

proc `zorder=`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: Colorbar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: Colorbar_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: Colorbar_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `cell_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # CELL_CB: called when the user double clicks a color cell to
    # change its value. char* function(Ihandle* ih, int cell); [in C]
    # ih:cell_cb(cell: number) -> (ret: string) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("CELL_CB"), cast[Icallback](cb))

proc `cell_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("CELL_CB"), cast[Icallback](cb))

proc `cell_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("CELL_CB")))

proc `destroy_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: Colorbar_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: Colorbar_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `extended_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # EXTENDED_CB: called when the user right click a cell with the
    # Shift key pressed. It is independent of the SHOW_SECONDARY
    # attribute. int function(Ihandle* ih, int cell); [in C]
    # ih:extended_cb(cell: number) -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("EXTENDED_CB"), cast[Icallback](cb))

proc `extended_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("EXTENDED_CB"), cast[Icallback](cb))

proc `extended_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("EXTENDED_CB")))

proc `focus_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `keypress_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    # KEYPRESS_CB KEYPRESS_CB Action generated when a key is pressed
    # or released. If the key is pressed and held several calls will
    # occur. It is called after the callback K_ANY is processed.
    # Callback int function(Ihandle *ih, int c, int press); [in C]
    # ih:keypress_cb(c, press: number) -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. c:
    # identifier of typed key. Please refer to the Keyboard Codes
    # table for a list of possible values. press: 1 is the user
    # pressed the key or 0 otherwise. Returns: If IUP_IGNORE is
    # returned the key is ignored by the system. IUP_CLOSE will be
    # processed. Affects IupCanvas
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB")))

proc `killfocus_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: Colorbar_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Colorbar_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `postmessage_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `scroll_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    # SCROLL_CB SCROLL_CB Called when some manipulation is made to the
    # scrollbar. The canvas is automatically redrawn only if this
    # callback is NOT defined. (GTK 2.8) Also the POSX and POSY values
    # will not be correctly updated for older GTK versions. In Ubuntu,
    # when liboverlay-scrollbar is enabled (the new tiny auto-hide
    # scrollbar) only the IUP_SBPOSV and IUP_SBPOSH codes are used.
    # Callback int function(Ihandle *ih, int op, float posx, float
    # posy); [in C] ih:scroll_cb(op, posx, posy: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. op: indicates the operation performed on the
    # scrollbar. If the manipulation was made on the vertical
    # scrollbar, it can have the following values: IUP_SBUP - line up
    # IUP_SBDN - line down IUP_SBPGUP - page up IUP_SBPGDN - page down
    # IUP_SBPOSV - vertical positioning IUP_SBDRAGV - vertical drag If
    # it was on the horizontal scrollbar, the following values are
    # valid: IUP_SBLEFT - column left IUP_SBRIGHT - column right
    # IUP_SBPGLEFT - page left IUP_SBPGRIGHT - page right IUP_SBPOSH -
    # horizontal positioning IUP_SBDRAGH - horizontal drag posx, posy:
    # the same as the ACTION canvas callback (corresponding to the
    # values of attributes POSX and POSY). Notes IUP_SBDRAGH and
    # IUP_SBDRAGV are not supported in GTK. During drag IUP_SBPOSH and
    # IUP_SBPOSV are used. In Windows, after a drag when mouse is
    # released IUP_SBPOSH or IUP_SBPOSV are called. Affects IupCanvas,
    # IupGLCanvas, SCROLLBAR
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SCROLL_CB")))

proc `select_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    # SELECT_CB: called when a color is selected. The primary color is
    # selected with the left mouse button, and if existent the
    # secondary is selected with the right mouse button. int
    # function(Ihandle* ih, int cell, int type); [in C]
    # ih:select_cb(cell, type: number) -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("SELECT_CB"), cast[Icallback](cb))

proc `select_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SELECT_CB"), cast[Icallback](cb))

proc `select_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SELECT_CB")))

proc `switch_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    # SWITCH_CB: called when the user double clicks the preview area
    # outside the preview cells to switch the primary and secondary
    # selections. It is only called if SHOW_SECONDARY=YES. int
    # function(Ihandle* ih, int prim_cell, int sec_cell); [in C]
    # ih:switch_cb(prim_cell, sec_cell: number) -> (ret: number) [in
    # Lua]
    SetCallback(cast[PIhandle](ih), cstring("SWITCH_CB"), cast[Icallback](cb))

proc `switch_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SWITCH_CB"), cast[Icallback](cb))

proc `switch_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SWITCH_CB")))

proc `unmap_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `wheel_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # WHEEL_CB WHEEL_CB Action generated when the mouse wheel is
    # rotated. If this callback is not defined the wheel will
    # automatically scroll the canvas in the vertical direction by
    # some lines, the SCROLL_CB callback if defined will be called
    # with the IUP_SBDRAGV operation. Callback int function(Ihandle
    # *ih, float delta, int x, int y, char *status); [in C]
    # ih:wheel_cb(delta, x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. delta: the amount the wheel was rotated in notches.
    # x, y: position in the canvas where the event has occurred, in
    # pixels. status: status of mouse buttons and certain keyboard
    # keys at the moment the event was generated. The same macros used
    # for BUTTON_CB can be used for this status. Notes In Motif and
    # GTK delta is always 1 or -1. In Windows is some situations delta
    # can reach the value of two. In the future with more precise
    # wheels this increment can be changed. Affects IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WHEEL_CB")))

proc `wom_cb=`*(ih: Colorbar_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # WOM_CB WOM_CB Action generated when an audio device receives an
    # event. [Windows Only] Callback int function(Ihandle *ih, int
    # state); [in C] ih:wom_cb(state: number) -> (ret: number) [in
    # Lua] ih: identifies the element that activated the event. state:
    # can be opening=1, done=0, or closing=-1. Notes This callback is
    # used to syncronize video playback with audio. It is sent when
    # the audio device: Message Description opening is opened by using
    # the waveOutOpen function. done is finished with a data block
    # sent by using the waveOutWrite function. closing is closed by
    # using the waveOutClose function. You must use the HWND attribute
    # when calling waveOutOpen in the dwCallback parameter and set
    # fdwOpen to CALLBACK_WINDOW. Affects IupDialog, IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: Colorbar_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: Colorbar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WOM_CB")))

proc ColorBrowser*(): ColorBrowser_t {.cdecl.} =
    # Creates an element for selecting a color. The selection is done
    # using a cylindrical projection of the RGB cube. The
    # transformation defines a coordinate color system called HSI,
    # that is still the RGB color space but using cylindrical
    # coordinates. H is for Hue, and it is the angle around the RGB
    # cube diagonal starting at red (RGB=255 0 0). S is for
    # Saturation, and it is the normal distance from the color to the
    # diagonal, normalized by its maximum value at the specified Hue.
    # This also defines a point at the diagonal used to define I. I is
    # for Intensity, and it is the distance from the point defined at
    # the diagonal to black (RGB=0 0 0). I can also be seen as the
    # projection of the color vector onto the diagonal. But I is not
    # linear, see Notes below. (Migrated from the IupControls library
    # since IUP 3.24, it does not depend on the CD library anymore.)
    # For a dialog that simply returns the selected color, you can use
    # function IupGetColor or IupColorDlg.
    return ColorBrowser_t(niupc.ColorBrowser())

proc `active=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    # ACTIVE, BGCOLOR, FONT, X, Y, POSITION, MINSIZE, MAXSIZE, WID,
    # TIP, SIZE, ZORDER, VISIBLE, THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `backingstore=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore=`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE")) == "YES"

proc `bgcolor=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: ColorBrowser_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: ColorBrowser_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `canfocus=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `cursor=`*(ih: ColorBrowser_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: ColorBrowser_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `dragdrop=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary colorbrowser
proc `dragtypes`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

# TODO unknown: colorbrowser DRAWABLE Unknown Binary
proc `drawable`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWABLE"))

proc `drawbgcolor=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor=`*(ih: ColorBrowser_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: ColorBrowser_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"))

proc `drawcolor=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor=`*(ih: ColorBrowser_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: ColorBrowser_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"))

proc `drawdriver`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWDRIVER"))

proc `drawfont=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

proc `drawfont`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

# TODO ??? String Binary colorbrowser
proc `drawfont`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"))

proc `drawlinewidth=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth=`*(ih: ColorBrowser_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: ColorBrowser_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"))

proc `drawmakeinactive=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive=`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE")) == "YES"

proc `drawsize`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSIZE"))

proc `drawstyle=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"))

proc `drawtextalignment=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"))

proc `drawtextclip=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip=`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP")) == "YES"

proc `drawtextellipsis=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis=`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS")) == "YES"

proc `drawtextlayoutcenter=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter=`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER")) == "YES"

proc `drawtextorientation=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation=`*(ih: ColorBrowser_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: ColorBrowser_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"))

proc `drawtextwrap=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap=`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP")) == "YES"

proc `dropfilestarget=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary colorbrowser
proc `droptypes`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `dx=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx=`*(ih: ColorBrowser_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: ColorBrowser_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DX"))

proc `dy=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy=`*(ih: ColorBrowser_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: ColorBrowser_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DY"))

proc `expand=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    # EXPAND: The default is "NO".
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: ColorBrowser_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: ColorBrowser_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary colorbrowser
proc `font`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary colorbrowser
proc `fontface`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: ColorBrowser_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: ColorBrowser_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary colorbrowser
proc `fontstyle`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary colorbrowser
proc `handlename`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

# TODO unknown: colorbrowser HSI Unknown Binary
proc `hsi`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HSI"))

proc `linex=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex=`*(ih: ColorBrowser_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: ColorBrowser_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEX"))

proc `liney=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney=`*(ih: ColorBrowser_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: ColorBrowser_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEY"))

proc `maxsize=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: ColorBrowser_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: ColorBrowser_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: ColorBrowser_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: ColorBrowser_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary colorbrowser
proc `name`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary colorbrowser
proc `normalizergroup`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary colorbrowser
proc `ntheme`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: colorbrowser PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: colorbrowser PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: ColorBrowser_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: ColorBrowser_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `posx=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx=`*(ih: ColorBrowser_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: ColorBrowser_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSX"))

proc `posy=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy=`*(ih: ColorBrowser_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: ColorBrowser_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSY"))

proc `propagatefocus=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    # RASTERSIZE (non inheritable): the initial size is "181x181". Set
    # to NULL to allow the automatic layout use smaller values.
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: ColorBrowser_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: ColorBrowser_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

# TODO unknown: colorbrowser RGB Unknown Binary
proc `rgb`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RGB"))

proc `sb_resize`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_RESIZE"))

proc `screenposition`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `scrollbar=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar=`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR")) == "YES"

proc `size=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: ColorBrowser_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: ColorBrowser_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary colorbrowser
proc `theme`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary colorbrowser
proc `tip`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: ColorBrowser_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: ColorBrowser_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: ColorBrowser_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: ColorBrowser_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: ColorBrowser_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: ColorBrowser_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary colorbrowser
proc `tipicon`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary colorbrowser
proc `tipmarkup`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: ColorBrowser_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: ColorBrowser_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `touch=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch=`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOUCH")) == "YES"

proc `usersize=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: ColorBrowser_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: ColorBrowser_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wheeldropfocus=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus=`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS")) == "YES"

proc `wid`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

proc `xautohide=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide=`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE")) == "YES"

proc `xdisplay`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XDISPLAY"))

# TODO unknown: colorbrowser XFONTID Unknown Binary
proc `xfontid`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `xhidden`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XHIDDEN")) == "YES"

proc `xmax=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax=`*(ih: ColorBrowser_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: ColorBrowser_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMAX"))

proc `xmin=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin=`*(ih: ColorBrowser_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: ColorBrowser_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMIN"))

# TODO unknown: colorbrowser XWINDOW Unknown Binary
proc `xwindow`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `yautohide=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide=`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: ColorBrowser_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE")) == "YES"

proc `yhidden`*(ih: ColorBrowser_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YHIDDEN")) == "YES"

proc `ymax=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax=`*(ih: ColorBrowser_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: ColorBrowser_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMAX"))

proc `ymin=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin=`*(ih: ColorBrowser_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: ColorBrowser_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: ColorBrowser_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMIN"))

proc `zorder=`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: ColorBrowser_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `change_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, arg2: uint8, arg3: uint8, arg4: uint8): cint {.cdecl.}) {.cdecl.} =
    # CHANGE_CB: Called when the user releases the left mouse button
    # over the control, defining the selected color. int
    # change(Ihandle *ih, unsigned char r, unsigned char g, unsigned
    # char b); [in C] ih:change_cb(r: number, g: number, b: number) ->
    # (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("CHANGE_CB"), cast[Icallback](cb))

proc `change_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, arg2: uint8, arg3: uint8, arg4: uint8): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("CHANGE_CB"), cast[Icallback](cb))

proc `change_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("CHANGE_CB")))

proc `destroy_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `drag_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, arg2: uint8, arg3: uint8, arg4: uint8): cint {.cdecl.}) {.cdecl.} =
    # DRAG_CB: Called several times while the color is being changed
    # by dragging the mouse over the control. int drag(Ihandle *ih,
    # unsigned char r, unsigned char g, unsigned char b); [in C]
    # ih:drag_cb(r: number, g: number, b: number) -> (ret: number) [in
    # Lua]
    SetCallback(cast[PIhandle](ih), cstring("DRAG_CB"), cast[Icallback](cb))

proc `drag_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, arg2: uint8, arg3: uint8, arg4: uint8): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAG_CB"), cast[Icallback](cb))

proc `drag_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAG_CB")))

proc `dropdata_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: ColorBrowser_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: ColorBrowser_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `focus_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `keypress_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    # KEYPRESS_CB KEYPRESS_CB Action generated when a key is pressed
    # or released. If the key is pressed and held several calls will
    # occur. It is called after the callback K_ANY is processed.
    # Callback int function(Ihandle *ih, int c, int press); [in C]
    # ih:keypress_cb(c, press: number) -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. c:
    # identifier of typed key. Please refer to the Keyboard Codes
    # table for a list of possible values. press: 1 is the user
    # pressed the key or 0 otherwise. Returns: If IUP_IGNORE is
    # returned the key is ignored by the system. IUP_CLOSE will be
    # processed. Affects IupCanvas
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB")))

proc `killfocus_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `postmessage_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `scroll_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    # SCROLL_CB SCROLL_CB Called when some manipulation is made to the
    # scrollbar. The canvas is automatically redrawn only if this
    # callback is NOT defined. (GTK 2.8) Also the POSX and POSY values
    # will not be correctly updated for older GTK versions. In Ubuntu,
    # when liboverlay-scrollbar is enabled (the new tiny auto-hide
    # scrollbar) only the IUP_SBPOSV and IUP_SBPOSH codes are used.
    # Callback int function(Ihandle *ih, int op, float posx, float
    # posy); [in C] ih:scroll_cb(op, posx, posy: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. op: indicates the operation performed on the
    # scrollbar. If the manipulation was made on the vertical
    # scrollbar, it can have the following values: IUP_SBUP - line up
    # IUP_SBDN - line down IUP_SBPGUP - page up IUP_SBPGDN - page down
    # IUP_SBPOSV - vertical positioning IUP_SBDRAGV - vertical drag If
    # it was on the horizontal scrollbar, the following values are
    # valid: IUP_SBLEFT - column left IUP_SBRIGHT - column right
    # IUP_SBPGLEFT - page left IUP_SBPGRIGHT - page right IUP_SBPOSH -
    # horizontal positioning IUP_SBDRAGH - horizontal drag posx, posy:
    # the same as the ACTION canvas callback (corresponding to the
    # values of attributes POSX and POSY). Notes IUP_SBDRAGH and
    # IUP_SBDRAGV are not supported in GTK. During drag IUP_SBPOSH and
    # IUP_SBPOSV are used. In Windows, after a drag when mouse is
    # released IUP_SBPOSH or IUP_SBPOSV are called. Affects IupCanvas,
    # IupGLCanvas, SCROLLBAR
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SCROLL_CB")))

proc `unmap_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `valuechanged_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # VALUECHANGED_CB: Called after the value was interactively
    # changed by the user. It is called whenever a CHANGE_CB or a
    # DRAG_CB would also be called, it is just called after them.
    # (since 3.0) int function(Ihandle *ih); [in
    # C]ih:valuechanged_cb() -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB")))

proc `wheel_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # WHEEL_CB WHEEL_CB Action generated when the mouse wheel is
    # rotated. If this callback is not defined the wheel will
    # automatically scroll the canvas in the vertical direction by
    # some lines, the SCROLL_CB callback if defined will be called
    # with the IUP_SBDRAGV operation. Callback int function(Ihandle
    # *ih, float delta, int x, int y, char *status); [in C]
    # ih:wheel_cb(delta, x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. delta: the amount the wheel was rotated in notches.
    # x, y: position in the canvas where the event has occurred, in
    # pixels. status: status of mouse buttons and certain keyboard
    # keys at the moment the event was generated. The same macros used
    # for BUTTON_CB can be used for this status. Notes In Motif and
    # GTK delta is always 1 or -1. In Windows is some situations delta
    # can reach the value of two. In the future with more precise
    # wheels this increment can be changed. Affects IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WHEEL_CB")))

proc `wom_cb=`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # WOM_CB WOM_CB Action generated when an audio device receives an
    # event. [Windows Only] Callback int function(Ihandle *ih, int
    # state); [in C] ih:wom_cb(state: number) -> (ret: number) [in
    # Lua] ih: identifies the element that activated the event. state:
    # can be opening=1, done=0, or closing=-1. Notes This callback is
    # used to syncronize video playback with audio. It is sent when
    # the audio device: Message Description opening is opened by using
    # the waveOutOpen function. done is finished with a data block
    # sent by using the waveOutWrite function. closing is closed by
    # using the waveOutClose function. You must use the HWND attribute
    # when calling waveOutOpen in the dwCallback parameter and set
    # fdwOpen to CALLBACK_WINDOW. Affects IupDialog, IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: ColorBrowser_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: ColorBrowser_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WOM_CB")))

proc ColorDlg*(): ColorDlg_t {.cdecl.} =
    # Creates the Color Dialog element. It is a predefined dialog for
    # selecting a color. (since IUP version 3.24 the native versions
    # were removed and only the IupColorBrowser based dialog remains.)
    return ColorDlg_t(niupc.ColorDlg())

proc `active=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `activewindow`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVEWINDOW")) == "YES"

# TODO unknown: colordlg ALPHA Unknown Binary
proc `alpha`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ALPHA"))

proc `background=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(value))

proc `background`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(value))

proc `background=`*(ih: ColorDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(&"{red} {green} {blue} {alpha}"))

proc `background`*(ih: ColorDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(&"{red} {green} {blue} {alpha}"))

proc `background`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"))

proc `bgcolor=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: ColorDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: ColorDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `bordersize`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERSIZE"))

proc `bringfront=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring(value))

proc `bringfront`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring(value))

proc `bringfront=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring((if yes: "YES" else: "NO")))

proc `bringfront`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring((if yes: "YES" else: "NO")))

proc `bringfront`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT")) == "YES"

proc `canfocus=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `childoffset=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset=`*(ih: ColorDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: ColorDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"))

proc `clientoffset`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(value))

proc `clientsize`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(value))

proc `clientsize=`*(ih: ColorDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(&"{width}x{height}"))

proc `clientsize`*(ih: ColorDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(&"{width}x{height}"))

proc `clientsize`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

# TODO unknown: colordlg COLORTABLE Unknown Binary
proc `colortable`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("COLORTABLE"))

proc `composited=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring(value))

proc `composited`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring(value))

proc `composited=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring((if yes: "YES" else: "NO")))

proc `composited`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring((if yes: "YES" else: "NO")))

proc `composited`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("COMPOSITED")) == "YES"

proc `control=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring(value))

proc `control`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring(value))

proc `control=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring((if yes: "YES" else: "NO")))

proc `control`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring((if yes: "YES" else: "NO")))

proc `control`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CONTROL")) == "YES"

proc `cursor=`*(ih: ColorDlg_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: ColorDlg_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `customframe=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring(value))

proc `customframe`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring(value))

proc `customframe=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring((if yes: "YES" else: "NO")))

proc `customframe`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring((if yes: "YES" else: "NO")))

proc `customframe`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME")) == "YES"

proc `customframesimulate=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring(value))

proc `customframesimulate`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring(value))

proc `customframesimulate=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring((if yes: "YES" else: "NO")))

proc `customframesimulate`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring((if yes: "YES" else: "NO")))

proc `customframesimulate`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE")) == "YES"

proc `defaultenter=`*(ih: ColorDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTENTER"), cast[PIhandle](handle))

proc `defaultenter`*(ih: ColorDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTENTER"), cast[PIhandle](handle))

proc `defaultenter`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DEFAULTENTER"))

proc `defaultesc=`*(ih: ColorDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTESC"), cast[PIhandle](handle))

proc `defaultesc`*(ih: ColorDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTESC"), cast[PIhandle](handle))

proc `defaultesc`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DEFAULTESC"))

proc `dialogframe=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring(value))

proc `dialogframe`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring(value))

proc `dialogframe=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring((if yes: "YES" else: "NO")))

proc `dialogframe`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring((if yes: "YES" else: "NO")))

proc `dialogframe`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME")) == "YES"

proc `dialoghint=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring(value))

proc `dialoghint`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring(value))

proc `dialoghint=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring((if yes: "YES" else: "NO")))

proc `dialoghint`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring((if yes: "YES" else: "NO")))

proc `dialoghint`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT")) == "YES"

proc `dragdrop=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary colordlg
proc `dragtypes`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

proc `dropfilestarget=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary colordlg
proc `droptypes`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `expand=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: ColorDlg_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: ColorDlg_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary colordlg
proc `font`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary colordlg
proc `fontface`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: ColorDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: ColorDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary colordlg
proc `fontstyle`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `fullscreen=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring(value))

proc `fullscreen`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring(value))

proc `fullscreen=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring((if yes: "YES" else: "NO")))

proc `fullscreen`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring((if yes: "YES" else: "NO")))

proc `handlename=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary colordlg
proc `handlename`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `helpbutton=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring(value))

proc `helpbutton`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring(value))

proc `helpbutton=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring((if yes: "YES" else: "NO")))

proc `helpbutton`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring((if yes: "YES" else: "NO")))

proc `helpbutton`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON")) == "YES"

proc `hidetaskbar=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring(value))

proc `hidetaskbar`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring(value))

proc `hidetaskbar=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring((if yes: "YES" else: "NO")))

proc `hidetaskbar`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring((if yes: "YES" else: "NO")))

proc `hidetaskbar`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR")) == "YES"

proc `hidetitlebar=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETITLEBAR"), cstring(value))

proc `hidetitlebar`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETITLEBAR"), cstring(value))

# TODO ??? String Binary colordlg
proc `hidetitlebar`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIDETITLEBAR"))

proc `icon=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ICON"), cstring(value))

proc `icon`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ICON"), cstring(value))

# TODO ??? String Binary colordlg
proc `icon`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ICON"))

proc `maxbox=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring(value))

proc `maxbox`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring(value))

proc `maxbox=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring((if yes: "YES" else: "NO")))

proc `maxbox`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring((if yes: "YES" else: "NO")))

proc `maxbox`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXBOX")) == "YES"

proc `maximized`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXIMIZED")) == "YES"

proc `maxsize=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: ColorDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: ColorDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `mdichild=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring(value))

proc `mdichild`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring(value))

proc `mdichild=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring((if yes: "YES" else: "NO")))

proc `mdichild`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring((if yes: "YES" else: "NO")))

proc `mdichild`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDICHILD")) == "YES"

proc `mdiclient=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring(value))

proc `mdiclient`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring(value))

proc `mdiclient=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring((if yes: "YES" else: "NO")))

proc `mdiclient`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring((if yes: "YES" else: "NO")))

proc `mdiclient`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDICLIENT")) == "YES"

proc `mdiframe=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring(value))

proc `mdiframe`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring(value))

proc `mdiframe=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring((if yes: "YES" else: "NO")))

proc `mdiframe`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring((if yes: "YES" else: "NO")))

proc `mdiframe`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDIFRAME")) == "YES"

proc `mdimenu=`*(ih: ColorDlg_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MDIMENU"), cast[PIhandle](handle))

proc `mdimenu`*(ih: ColorDlg_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MDIMENU"), cast[PIhandle](handle))

proc `mdimenu`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDIMENU"))

proc `menu=`*(ih: ColorDlg_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MENU"), cast[PIhandle](handle))

proc `menu`*(ih: ColorDlg_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MENU"), cast[PIhandle](handle))

proc `menu`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MENU"))

proc `menubox=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring(value))

proc `menubox`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring(value))

proc `menubox=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring((if yes: "YES" else: "NO")))

proc `menubox`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring((if yes: "YES" else: "NO")))

proc `menubox`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MENUBOX")) == "YES"

proc `minbox=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring(value))

proc `minbox`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring(value))

proc `minbox=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring((if yes: "YES" else: "NO")))

proc `minbox`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring((if yes: "YES" else: "NO")))

proc `minbox`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINBOX")) == "YES"

proc `minsize=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: ColorDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: ColorDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `modal`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MODAL")) == "YES"

proc `nactive=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring(value))

proc `nactive`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring(value))

proc `nactive=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `nactive`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `nactive`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NACTIVE")) == "YES"

proc `name=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary colordlg
proc `name`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `nativeparent=`*(ih: ColorDlg_t, handle: User_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("NATIVEPARENT"), cast[PIhandle](handle))

proc `nativeparent`*(ih: ColorDlg_t, handle: User_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("NATIVEPARENT"), cast[PIhandle](handle))

proc `nativeparent`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATIVEPARENT"))

proc `naturalsize`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `noflush=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring(value))

proc `noflush`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring(value))

proc `noflush=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring((if yes: "YES" else: "NO")))

proc `noflush`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring((if yes: "YES" else: "NO")))

proc `noflush`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NOFLUSH")) == "YES"

proc `normalizergroup=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary colordlg
proc `normalizergroup`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary colordlg
proc `ntheme`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `opacity=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(value))

proc `opacity`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(value))

proc `opacity=`*(ih: ColorDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(&"{x}"))

proc `opacity`*(ih: ColorDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(&"{x}"))

proc `opacity`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("OPACITY"))

proc `opacityimage=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITYIMAGE"), cstring(value))

proc `opacityimage`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITYIMAGE"), cstring(value))

# TODO ??? String Binary colordlg
proc `opacityimage`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("OPACITYIMAGE"))

# TODO unknown: colordlg PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: colordlg PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `parentdialog=`*(ih: ColorDlg_t, handle: IUPhandle_t) {.cdecl.} =
    # PARENTDIALOG (creation only): Name of a dialog to be used as
    # parent. This dialog will be always in front of the parent
    # dialog.
    SetAttributeHandle(cast[PIhandle](ih), cstring("PARENTDIALOG"), cast[PIhandle](handle))

proc `parentdialog`*(ih: ColorDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("PARENTDIALOG"), cast[PIhandle](handle))

proc `parentdialog`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PARENTDIALOG"))

proc `placement=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PLACEMENT"), cstring(value))

proc `placement`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PLACEMENT"), cstring(value))

proc `placement`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PLACEMENT"))

proc `position=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: ColorDlg_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: ColorDlg_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: ColorDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: ColorDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `resize=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(value))

proc `resize`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(value))

proc `resize=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring((if yes: "YES" else: "NO")))

proc `resize`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring((if yes: "YES" else: "NO")))

proc `resize`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RESIZE")) == "YES"

proc `saveunder=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring(value))

proc `saveunder`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring(value))

proc `saveunder=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring((if yes: "YES" else: "NO")))

proc `saveunder`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring((if yes: "YES" else: "NO")))

proc `saveunder`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER")) == "YES"

proc `screenposition`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `shapeimage=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHAPEIMAGE"), cstring(value))

proc `shapeimage`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHAPEIMAGE"), cstring(value))

# TODO ??? String Binary colordlg
proc `shapeimage`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHAPEIMAGE"))

# TODO unknown: colordlg SHOWALPHA Unknown Binary
proc `showalpha`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWALPHA"))

# TODO unknown: colordlg SHOWCOLORTABLE Unknown Binary
proc `showcolortable`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWCOLORTABLE"))

# TODO unknown: colordlg SHOWHELP Unknown Binary
proc `showhelp`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWHELP"))

# TODO unknown: colordlg SHOWHEX Unknown Binary
proc `showhex`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWHEX"))

proc `shownofocus=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring(value))

proc `shownofocus`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring(value))

proc `shownofocus=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `shownofocus`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `shownofocus`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS")) == "YES"

proc `shrink=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring(value))

proc `shrink`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring(value))

proc `shrink=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring((if yes: "YES" else: "NO")))

proc `shrink`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring((if yes: "YES" else: "NO")))

proc `shrink`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHRINK")) == "YES"

proc `simulatemodal=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring(value))

proc `simulatemodal`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring(value))

proc `simulatemodal=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring((if yes: "YES" else: "NO")))

proc `simulatemodal`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring((if yes: "YES" else: "NO")))

proc `size=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: ColorDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: ColorDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size=`*(ih: ColorDlg_t, width: string, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: ColorDlg_t, width: string, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size=`*(ih: ColorDlg_t, width: int, height:string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: ColorDlg_t, width: int, height:string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `startfocus=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STARTFOCUS"), cstring(value))

proc `startfocus`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STARTFOCUS"), cstring(value))

# TODO ??? String Binary colordlg
proc `startfocus`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("STARTFOCUS"))

proc `status`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("STATUS"))

proc `theme=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary colordlg
proc `theme`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary colordlg
proc `tip`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: ColorDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: ColorDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: ColorDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: ColorDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: ColorDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: ColorDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary colordlg
proc `tipicon`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary colordlg
proc `tipmarkup`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: ColorDlg_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: ColorDlg_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `title=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    # TITLE: Dialog title.
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary colordlg
proc `title`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

proc `toolbox=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring(value))

proc `toolbox`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring(value))

proc `toolbox=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring((if yes: "YES" else: "NO")))

proc `toolbox`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring((if yes: "YES" else: "NO")))

proc `toolbox`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOOLBOX")) == "YES"

proc `topmost=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring(value))

proc `topmost`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring(value))

proc `topmost=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring((if yes: "YES" else: "NO")))

proc `topmost`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring((if yes: "YES" else: "NO")))

proc `tray=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring(value))

proc `tray`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring(value))

proc `tray=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring((if yes: "YES" else: "NO")))

proc `tray`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring((if yes: "YES" else: "NO")))

proc `tray`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAY")) == "YES"

proc `trayimage=`*(ih: ColorDlg_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("TRAYIMAGE"), cast[PIhandle](handle))

proc `trayimage`*(ih: ColorDlg_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("TRAYIMAGE"), cast[PIhandle](handle))

proc `trayimage`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAYIMAGE"))

proc `traytip=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIP"), cstring(value))

proc `traytip`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIP"), cstring(value))

# TODO ??? String Binary colordlg
proc `traytip`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAYTIP"))

proc `traytipmarkup=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIPMARKUP"), cstring(value))

proc `traytipmarkup`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIPMARKUP"), cstring(value))

# TODO ??? String Binary colordlg
proc `traytipmarkup`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAYTIPMARKUP"))

proc `usersize=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: ColorDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: ColorDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    # VALUE: The color value in RGB coordinates and optionally alpha.
    # It is used as the initial value and contains the selected value
    # if the user pressed the Ok button. Format: "R G B" or "R G B A".
    # Each component range from 0 to 255.
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

# TODO ??? String Binary colordlg
proc `value`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

# TODO unknown: colordlg VALUEHEX Unknown Binary
proc `valuehex`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUEHEX"))

# TODO unknown: colordlg VALUEHSI Unknown Binary
proc `valuehsi`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUEHSI"))

proc `visible=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: ColorDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: ColorDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

# TODO unknown: colordlg XFONTID Unknown Binary
proc `xfontid`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

# TODO unknown: colordlg XWINDOW Unknown Binary
proc `xwindow`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: ColorDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `zorder=`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: ColorDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `close_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # CLOSE_CB CLOSE_CB Called just before a dialog is closed when the
    # user clicks the close button of the title bar or an equivalent
    # action. Callback int function(Ihandle *ih); [in C] ih:close_cb()
    # -> (ret: number) [in Lua] ih: identifies the element that
    # activated the event. Returns: if IUP_IGNORE, it prevents the
    # dialog from being closed. If you destroy the dialog in this
    # callback, you must return IUP_IGNORE. IUP_CLOSE will be
    # processed. Affects IupDialog
    SetCallback(cast[PIhandle](ih), cstring("CLOSE_CB"), cast[Icallback](cb))

proc `close_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("CLOSE_CB"), cast[Icallback](cb))

proc `close_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("CLOSE_CB")))

proc `colorupdate_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # COLORUPDATE_CB: Action generated when the color is updated in
    # the dialog. It is also called when the color is updated
    # programmatically. (since 3.11) int function(Ihandle* ih); [in C]
    # elem:colorupdate_cb() -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("COLORUPDATE_CB"), cast[Icallback](cb))

proc `colorupdate_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("COLORUPDATE_CB"), cast[Icallback](cb))

proc `colorupdate_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("COLORUPDATE_CB")))

proc `destroy_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: ColorDlg_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: ColorDlg_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `focus_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `killfocus_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `show_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, state: cint): cint {.cdecl.}) {.cdecl.} =
    # SHOW_CB SHOW_CB Called right after the dialog is showed, hidden,
    # maximized, minimized or restored from minimized/maximized. This
    # callback is called when those actions were performed by the user
    # or programmatically by the application. Callback int
    # function(Ihandle *ih, int state); [in C] ih:show_cb(state:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. state: indicates which of the
    # following situations generated the event: IUP_HIDE (since 3.0)
    # IUP_SHOW IUP_RESTORE (was minimized or maximized) IUP_MINIMIZE
    # IUP_MAXIMIZE (since 3.0) (not received in Motif when activated
    # from the maximize button) Returns: IUP_CLOSE will be processed.
    # Affects IupDialog
    SetCallback(cast[PIhandle](ih), cstring("SHOW_CB"), cast[Icallback](cb))

proc `show_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, state: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SHOW_CB"), cast[Icallback](cb))

proc `show_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SHOW_CB")))

proc `trayclick_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, but, pressed, dclick: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("TRAYCLICK_CB"), cast[Icallback](cb))

proc `trayclick_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle, but, pressed, dclick: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("TRAYCLICK_CB"), cast[Icallback](cb))

proc `trayclick_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("TRAYCLICK_CB")))

proc `unmap_cb=`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: ColorDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: ColorDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc DatePick*(): DatePick_t {.cdecl.} =
    # Creates a date editing interface element, which can displays a
    # calendar for selecting a date. In Windows is a native element.
    # In GTK and Motif is a custom element. In Motif is not capable of
    # displaying the calendar.
    return DatePick_t(niupc.DatePick())

proc `active=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: DatePick_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: DatePick_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: DatePick_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `backcolor=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(value))

proc `backcolor`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(value))

proc `backcolor=`*(ih: DatePick_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `backcolor`*(ih: DatePick_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `backcolor`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"))

proc `bgcolor=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: DatePick_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: DatePick_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

# TODO unknown: datepick CALENDARWEEKNUMBERS Unknown Binary
proc `calendarweeknumbers`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CALENDARWEEKNUMBERS"))

proc `canfocus=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: DatePick_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: DatePick_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: DatePick_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `childoffset=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset=`*(ih: DatePick_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: DatePick_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"))

proc `clientoffset`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `expand=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: DatePick_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: DatePick_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `fgcolor=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: DatePick_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: DatePick_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

proc `floating=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary datepick
proc `font`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary datepick
proc `fontface`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: DatePick_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: DatePick_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary datepick
proc `fontstyle`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary datepick
proc `handlename`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `maxsize=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: DatePick_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: DatePick_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: DatePick_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: DatePick_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary datepick
proc `name`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary datepick
proc `normalizergroup`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary datepick
proc `ntheme`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: datepick ORDER Unknown Binary
proc `order`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ORDER"))

# TODO unknown: datepick PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: datepick PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: DatePick_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: DatePick_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: DatePick_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: DatePick_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: DatePick_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: DatePick_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: DatePick_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `screenposition`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `separator=`*(ih: DatePick_t, value: string) {.cdecl.} =
    # SEPARATOR: Separator between day, month and year. Must be set
    # before ORDER in Windows. Default: "/".
    SetAttribute(cast[PIhandle](ih), cstring("SEPARATOR"), cstring(value))

proc `separator`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SEPARATOR"), cstring(value))

# TODO ??? String Binary datepick
proc `separator`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SEPARATOR"))

proc `showdropdown=`*(ih: DatePick_t, value: string) {.cdecl.} =
    # SHOWDROPDOWN (write-only): opens or closes the dropdown
    # calendar. Can be "YES" or "NO". Ignored if set before map. In
    # Windows, it works only for NO. (since 3.28)
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDROPDOWN"), cstring(value))

proc `showdropdown`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDROPDOWN"), cstring(value))

proc `showdropdown=`*(ih: DatePick_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDROPDOWN"), cstring((if yes: "YES" else: "NO")))

proc `showdropdown`*(ih: DatePick_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDROPDOWN"), cstring((if yes: "YES" else: "NO")))

proc `size=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: DatePick_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: DatePick_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `sunken=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SUNKEN"), cstring(value))

proc `sunken`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SUNKEN"), cstring(value))

# TODO ??? String Binary datepick
proc `sunken`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SUNKEN"))

proc `theme=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary datepick
proc `theme`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary datepick
proc `tip`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: DatePick_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: DatePick_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: DatePick_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: DatePick_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: DatePick_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: DatePick_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary datepick
proc `tipicon`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary datepick
proc `tipmarkup`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: DatePick_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: DatePick_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: DatePick_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: DatePick_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: DatePick_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `title=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary datepick
proc `title`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

proc `today`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TODAY"))

proc `usersize=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: DatePick_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: DatePick_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: DatePick_t, value: string) {.cdecl.} =
    # VALUE: the current date always in the format "year/month/day"
    # ("%d/%d/%d" in C). Can be set to "TODAY". Default value is the
    # today date.
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

# TODO ??? String Binary datepick
proc `value`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `visible=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: DatePick_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: DatePick_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: DatePick_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

# TODO unknown: datepick XFONTID Unknown Binary
proc `xfontid`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `y`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

# TODO unknown: datepick ZEROPRECED Unknown Binary
proc `zeropreced`*(ih: DatePick_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ZEROPRECED"))

proc `zorder=`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: DatePick_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `focus_cb=`*(ih: DatePick_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: DatePick_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: DatePick_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `map_cb=`*(ih: DatePick_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: DatePick_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: DatePick_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `unmap_cb=`*(ih: DatePick_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: DatePick_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: DatePick_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `valuechanged_cb=`*(ih: DatePick_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # VALUECHANGED_CB: Called after the value was interactively
    # changed by the user. int function(Ihandle *ih); [in
    # C]ih:valuechanged_cb() -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: DatePick_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: DatePick_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB")))

proc DetachBox*(child: IUPhandle_t): DetachBox_t {.cdecl.} =
    # Creates a detachable void container. Dragging and dropping this
    # element, it creates a new dialog composed by its child or
    # elements arranged in it (for example, a child like IupVbox or
    # IupHbox). During the drag, the ESC key can be pressed to cancel
    # the action. It does not have a native representation, but it
    # contains also a IupCanvas to implement the bar handler.
    return DetachBox_t(niupc.DetachBox(cast[PIhandle](child)))

proc `active=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: DetachBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: DetachBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: DetachBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `barsize=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    # BARSIZE (non inheritable): controls the size of the bar handler.
    # To completely hide the bar set BARSIZE to 0 (since 3.16).
    # Default: 10.
    SetAttribute(cast[PIhandle](ih), cstring("BARSIZE"), cstring(value))

proc `barsize`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BARSIZE"), cstring(value))

proc `barsize=`*(ih: DetachBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BARSIZE"), cstring(&"{x}"))

proc `barsize`*(ih: DetachBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BARSIZE"), cstring(&"{x}"))

proc `barsize`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BARSIZE"))

proc `canfocus=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: DetachBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: DetachBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: DetachBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `clientoffset`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `color=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    # COLOR: Changes the color of the bar grip affordance. The value
    # should be given in "R G B" color style. Default: "160 160 160".
    # When SHOWGRIP = NO, this attribute sets the background color of
    # the bar handler.
    SetAttribute(cast[PIhandle](ih), cstring("COLOR"), cstring(value))

proc `color`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COLOR"), cstring(value))

proc `color=`*(ih: DetachBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `color`*(ih: DetachBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `color`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("COLOR"))

# TODO unknown: detachbox DETACH Unknown Binary
proc `expand=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable): The default value is "YES".
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: DetachBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: DetachBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    # FONT, SIZE, RASTERSIZE, CLIENTSIZE, CLIENTOFFSET, POSITION,
    # MINSIZE, MAXSIZE, THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary detachbox
proc `font`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary detachbox
proc `fontface`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: DetachBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: DetachBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary detachbox
proc `fontstyle`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary detachbox
proc `handlename`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `maxsize=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: DetachBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: DetachBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: DetachBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: DetachBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary detachbox
proc `name`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary detachbox
proc `normalizergroup`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary detachbox
proc `ntheme`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `oldbrother_handle`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("OLDBROTHER_HANDLE"))

proc `oldparent_handle`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("OLDPARENT_HANDLE"))

proc `orientation=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    # ORIENTATION (creation only) (non inheritable): Indicates the
    # orientation of the bar handler. The direction of the resize is
    # perpendicular to the orientation. Possible values are "VERTICAL"
    # or "HORIZONTAL". Default: "VERTICAL".
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"))

# TODO unknown: detachbox PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: detachbox PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: DetachBox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: DetachBox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: DetachBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: DetachBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: DetachBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: DetachBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: DetachBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

# TODO unknown: detachbox RESTORE Unknown Binary
# TODO unknown: detachbox RESTOREWHENCLOSED Unknown Binary
proc `restorewhenclosed`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RESTOREWHENCLOSED"))

proc `showgrip=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    # SHOWGRIP (non inheritable): Shows the bar grip affordance.
    # Default: YES. When set to NO, the BARSIZE is set to 5 (if
    # greater than 5). To completely hide the bar set BARSIZE to 0
    # (since 3.16).
    SetAttribute(cast[PIhandle](ih), cstring("SHOWGRIP"), cstring(value))

proc `showgrip`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWGRIP"), cstring(value))

proc `showgrip=`*(ih: DetachBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWGRIP"), cstring((if yes: "YES" else: "NO")))

proc `showgrip`*(ih: DetachBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWGRIP"), cstring((if yes: "YES" else: "NO")))

proc `showgrip`*(ih: DetachBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWGRIP")) == "YES"

proc `size=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: DetachBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: DetachBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary detachbox
proc `theme`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `usersize=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: DetachBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: DetachBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: DetachBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: DetachBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: DetachBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: DetachBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

# TODO unknown: detachbox XFONTID Unknown Binary
proc `xfontid`*(ih: DetachBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `destroy_cb=`*(ih: DetachBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: DetachBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: DetachBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `detached_cb=`*(ih: DetachBox_t, cb: proc (ih: PIhandle, arg2: PIhandle, arg3: cint, arg4: cint): cint {.cdecl.}) {.cdecl.} =
    # DETACHED_CB: Callback called when the box is detached. int
    # function(Ihandle *ih, Ihandle *new_parent, int x, int y); [in C]
    # ih:detached_cb(new_parent: ihandle, x, y: number) -> (ret:
    # number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("DETACHED_CB"), cast[Icallback](cb))

proc `detached_cb`*(ih: DetachBox_t, cb: proc (ih: PIhandle, arg2: PIhandle, arg3: cint, arg4: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DETACHED_CB"), cast[Icallback](cb))

proc `detached_cb`*(ih: DetachBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DETACHED_CB")))

proc `ldestroy_cb=`*(ih: DetachBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: DetachBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: DetachBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: DetachBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: DetachBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: DetachBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: DetachBox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: DetachBox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: DetachBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `restored_cb=`*(ih: DetachBox_t, cb: proc (ih: PIhandle, arg2: PIhandle, arg3: cint, arg4: cint): cint {.cdecl.}) {.cdecl.} =
    # RESTORED_CB: Callback called when the box is restored if
    # RESTOREWHENCLOSED=Yes. (since 3.21) int function(Ihandle *ih,
    # Ihandle *old_parent, int x, int y); [in C]
    # ih:restored_cb(old_parent: ihandle, x, y: number) -> (ret:
    # number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("RESTORED_CB"), cast[Icallback](cb))

proc `restored_cb`*(ih: DetachBox_t, cb: proc (ih: PIhandle, arg2: PIhandle, arg3: cint, arg4: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESTORED_CB"), cast[Icallback](cb))

proc `restored_cb`*(ih: DetachBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESTORED_CB")))

proc `unmap_cb=`*(ih: DetachBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: DetachBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: DetachBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc Dial*(`type`: string): Dial_t {.cdecl.} =
    # Creates a dial for regulating a given angular variable. It
    # inherits from IupCanvas. (Migrated from the IupControls library
    # since IUP 3.24, it does not depend on the CD library anymore.)
    return Dial_t(niupc.Dial(cstring(`type`)))

proc `active=`*(ih: Dial_t, value: string) {.cdecl.} =
    # ACTIVE, BGCOLOR, FONT, SCREENPOSITION, POSITION, MINSIZE,
    # MAXSIZE, WID, TIP, RASTERSIZE, ZORDER, VISIBLE, THEME: also
    # accepted.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `backingstore=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE")) == "YES"

proc `bgcolor=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: Dial_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Dial_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `canfocus=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `cursor=`*(ih: Dial_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: Dial_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

# TODO unknown: dial DENSITY Unknown Binary
proc `density`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DENSITY"))

proc `dragdrop=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary dial
proc `dragtypes`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

# TODO unknown: dial DRAWABLE Unknown Binary
proc `drawable`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWABLE"))

proc `drawbgcolor=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor=`*(ih: Dial_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: Dial_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"))

proc `drawcolor=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor=`*(ih: Dial_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: Dial_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"))

proc `drawdriver`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWDRIVER"))

proc `drawfont=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

proc `drawfont`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

# TODO ??? String Binary dial
proc `drawfont`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"))

proc `drawlinewidth=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth=`*(ih: Dial_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: Dial_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"))

proc `drawmakeinactive=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE")) == "YES"

proc `drawsize`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSIZE"))

proc `drawstyle=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"))

proc `drawtextalignment=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"))

proc `drawtextclip=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP")) == "YES"

proc `drawtextellipsis=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS")) == "YES"

proc `drawtextlayoutcenter=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER")) == "YES"

proc `drawtextorientation=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation=`*(ih: Dial_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: Dial_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"))

proc `drawtextwrap=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP")) == "YES"

proc `dropfilestarget=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary dial
proc `droptypes`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `dx=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx=`*(ih: Dial_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: Dial_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DX"))

proc `dy=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy=`*(ih: Dial_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: Dial_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DY"))

proc `expand=`*(ih: Dial_t, value: string) {.cdecl.} =
    # EXPAND: the default is "NO".
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Dial_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Dial_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `fgcolor=`*(ih: Dial_t, value: string) {.cdecl.} =
    # FGCOLOR: foreground color. The default value is "64 64 64".
    # (appears in circular dial since 3.24)
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: Dial_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: Dial_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

proc `flat=`*(ih: Dial_t, value: string) {.cdecl.} =
    # FLAT: use a 1 pixel flat border instead of the default 3 pixels
    # sunken border. Can be Yes or No. Default: No. (since 3.24)
    SetAttribute(cast[PIhandle](ih), cstring("FLAT"), cstring(value))

proc `flat`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLAT"), cstring(value))

proc `flat=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLAT"), cstring((if yes: "YES" else: "NO")))

proc `flat`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLAT"), cstring((if yes: "YES" else: "NO")))

proc `flat`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLAT")) == "YES"

proc `flatcolor=`*(ih: Dial_t, value: string) {.cdecl.} =
    # FLATCOLOR: color of the border when FLAT=Yes. Default: "160 160
    # 160". (since 3.24)
    SetAttribute(cast[PIhandle](ih), cstring("FLATCOLOR"), cstring(value))

proc `flatcolor`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLATCOLOR"), cstring(value))

proc `flatcolor=`*(ih: Dial_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLATCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `flatcolor`*(ih: Dial_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLATCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `flatcolor`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLATCOLOR"))

proc `floating=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary dial
proc `font`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary dial
proc `fontface`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Dial_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Dial_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary dial
proc `fontstyle`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary dial
proc `handlename`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `linex=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex=`*(ih: Dial_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: Dial_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEX"))

proc `liney=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney=`*(ih: Dial_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: Dial_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEY"))

proc `maxsize=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Dial_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Dial_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Dial_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Dial_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary dial
proc `name`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary dial
proc `normalizergroup`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary dial
proc `ntheme`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `orientation=`*(ih: Dial_t, value: string) {.cdecl.} =
    # ORIENTATION (creation only) (non inheritable): dial layout
    # configuration "VERTICAL", "HORIZONTAL" or "CIRCULAR". Default:
    # "HORIZONTAL". Vertical increments when moved up, and decrements
    # when moved down. Horizontal increments when moved right, and
    # decrements when moved left. Circular increments when moved
    # counter clock wise, and decrements when moved clock wise.
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"))

# TODO unknown: dial PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: dial PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Dial_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Dial_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `posx=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx=`*(ih: Dial_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: Dial_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSX"))

proc `posy=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy=`*(ih: Dial_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: Dial_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSY"))

proc `propagatefocus=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Dial_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Dial_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `sb_resize`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_RESIZE"))

proc `screenposition`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `scrollbar=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR")) == "YES"

proc `size=`*(ih: Dial_t, value: string) {.cdecl.} =
    # SIZE (non inheritable): the initial size is "16x80", "80x16" or
    # "40x35" according to the dial orientation. Set to NULL to allow
    # the automatic layout use smaller values.
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Dial_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Dial_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary dial
proc `theme`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary dial
proc `tip`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: Dial_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Dial_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: Dial_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Dial_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: Dial_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Dial_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary dial
proc `tipicon`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary dial
proc `tipmarkup`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: Dial_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Dial_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `touch=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOUCH")) == "YES"

proc `type=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TYPE"), cstring(value))

proc `type`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TYPE"), cstring(value))

proc `type=`*(ih: Dial_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TYPE"), cstring(&"{x}"))

proc `type`*(ih: Dial_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TYPE"), cstring(&"{x}"))

proc `type`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TYPE"))

# TODO unknown: dial UNIT Unknown Binary
proc `unit`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("UNIT"))

proc `usersize=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Dial_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Dial_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: Dial_t, value: string) {.cdecl.} =
    # VALUE (non inheritable): The dial angular value in radians
    # always. The value is reset to zero when the interaction is
    # started, except for ORIENTATION=CIRCULAR. When orientation is
    # vertical or horizontal, the dial measures relative angles. When
    # orientation is circular the dial measure absolute angles, where
    # the origin is at 3 O'clock.
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

# TODO ??? String Binary dial
proc `value`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `visible=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wheeldropfocus=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS")) == "YES"

proc `wid`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

proc `xautohide=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE")) == "YES"

proc `xdisplay`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XDISPLAY"))

# TODO unknown: dial XFONTID Unknown Binary
proc `xfontid`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `xhidden`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XHIDDEN")) == "YES"

proc `xmax=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax=`*(ih: Dial_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: Dial_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMAX"))

proc `xmin=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin=`*(ih: Dial_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: Dial_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMIN"))

# TODO unknown: dial XWINDOW Unknown Binary
proc `xwindow`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `yautohide=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide=`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: Dial_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE")) == "YES"

proc `yhidden`*(ih: Dial_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YHIDDEN")) == "YES"

proc `ymax=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax=`*(ih: Dial_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: Dial_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMAX"))

proc `ymin=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin=`*(ih: Dial_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: Dial_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: Dial_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMIN"))

proc `zorder=`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: Dial_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: Dial_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: Dial_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: Dial_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `button_press_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle, arg2: cdouble): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_PRESS_CB: Called when the user presses the left mouse
    # button over the dial. The angle here is always zero, except for
    # the circular dial. int function(Ihandle *ih, double angle)
    # ih:button_press_cb(angle: number) -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_PRESS_CB"), cast[Icallback](cb))

proc `button_press_cb`*(ih: Dial_t, cb: proc (ih: PIhandle, arg2: cdouble): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_PRESS_CB"), cast[Icallback](cb))

proc `button_press_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_PRESS_CB")))

proc `button_release_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle, arg2: cdouble): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_RELEASE_CB: Called when the user releases the left mouse
    # button after pressing it over the dial. int function(Ihandle
    # *ih, double angle) ih:button_release_cb(angle: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. angle: the dial value converted according to UNIT.
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_RELEASE_CB"), cast[Icallback](cb))

proc `button_release_cb`*(ih: Dial_t, cb: proc (ih: PIhandle, arg2: cdouble): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_RELEASE_CB"), cast[Icallback](cb))

proc `button_release_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_RELEASE_CB")))

proc `destroy_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Dial_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: Dial_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: Dial_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: Dial_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: Dial_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: Dial_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: Dial_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: Dial_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: Dial_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Dial_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `focus_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: Dial_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Dial_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Dial_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `keypress_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    # KEYPRESS_CB KEYPRESS_CB Action generated when a key is pressed
    # or released. If the key is pressed and held several calls will
    # occur. It is called after the callback K_ANY is processed.
    # Callback int function(Ihandle *ih, int c, int press); [in C]
    # ih:keypress_cb(c, press: number) -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. c:
    # identifier of typed key. Please refer to the Keyboard Codes
    # table for a list of possible values. press: 1 is the user
    # pressed the key or 0 otherwise. Returns: If IUP_IGNORE is
    # returned the key is ignored by the system. IUP_CLOSE will be
    # processed. Affects IupCanvas
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: Dial_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB")))

proc `killfocus_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Dial_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: Dial_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Dial_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Dial_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Dial_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Dial_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: Dial_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `mousemove_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle, arg2: cdouble): cint {.cdecl.}) {.cdecl.} =
    # MOUSEMOVE_CB: Called each time the user moves the dial with the
    # mouse button pressed. The angle the dial rotated since it was
    # initialized is passed as a parameter. int function(Ihandle *ih,
    # double angle); [in C] ih:mousemove_cb(angle: number) -> (ret:
    # number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("MOUSEMOVE_CB"), cast[Icallback](cb))

proc `mousemove_cb`*(ih: Dial_t, cb: proc (ih: PIhandle, arg2: cdouble): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOUSEMOVE_CB"), cast[Icallback](cb))

proc `mousemove_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOUSEMOVE_CB")))

proc `postmessage_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Dial_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: Dial_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `scroll_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    # SCROLL_CB SCROLL_CB Called when some manipulation is made to the
    # scrollbar. The canvas is automatically redrawn only if this
    # callback is NOT defined. (GTK 2.8) Also the POSX and POSY values
    # will not be correctly updated for older GTK versions. In Ubuntu,
    # when liboverlay-scrollbar is enabled (the new tiny auto-hide
    # scrollbar) only the IUP_SBPOSV and IUP_SBPOSH codes are used.
    # Callback int function(Ihandle *ih, int op, float posx, float
    # posy); [in C] ih:scroll_cb(op, posx, posy: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. op: indicates the operation performed on the
    # scrollbar. If the manipulation was made on the vertical
    # scrollbar, it can have the following values: IUP_SBUP - line up
    # IUP_SBDN - line down IUP_SBPGUP - page up IUP_SBPGDN - page down
    # IUP_SBPOSV - vertical positioning IUP_SBDRAGV - vertical drag If
    # it was on the horizontal scrollbar, the following values are
    # valid: IUP_SBLEFT - column left IUP_SBRIGHT - column right
    # IUP_SBPGLEFT - page left IUP_SBPGRIGHT - page right IUP_SBPOSH -
    # horizontal positioning IUP_SBDRAGH - horizontal drag posx, posy:
    # the same as the ACTION canvas callback (corresponding to the
    # values of attributes POSX and POSY). Notes IUP_SBDRAGH and
    # IUP_SBDRAGV are not supported in GTK. During drag IUP_SBPOSH and
    # IUP_SBPOSV are used. In Windows, after a drag when mouse is
    # released IUP_SBPOSH or IUP_SBPOSV are called. Affects IupCanvas,
    # IupGLCanvas, SCROLLBAR
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: Dial_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SCROLL_CB")))

proc `unmap_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Dial_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `valuechanged_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # VALUECHANGED_CB: Called after the value was interactively
    # changed by the user. It is called whenever a BUTTON_PRESS_CB, a
    # BUTTON_RELEASE_CB or a MOUSEMOVE_CB would also be called, but if
    # defined those callbacks will not be called. (since 3.0) int
    # function(Ihandle *ih); [in C]ih:valuechanged_cb() -> (ret:
    # number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: Dial_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB")))

proc `wheel_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # WHEEL_CB WHEEL_CB Action generated when the mouse wheel is
    # rotated. If this callback is not defined the wheel will
    # automatically scroll the canvas in the vertical direction by
    # some lines, the SCROLL_CB callback if defined will be called
    # with the IUP_SBDRAGV operation. Callback int function(Ihandle
    # *ih, float delta, int x, int y, char *status); [in C]
    # ih:wheel_cb(delta, x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. delta: the amount the wheel was rotated in notches.
    # x, y: position in the canvas where the event has occurred, in
    # pixels. status: status of mouse buttons and certain keyboard
    # keys at the moment the event was generated. The same macros used
    # for BUTTON_CB can be used for this status. Notes In Motif and
    # GTK delta is always 1 or -1. In Windows is some situations delta
    # can reach the value of two. In the future with more precise
    # wheels this increment can be changed. Affects IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: Dial_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WHEEL_CB")))

proc `wom_cb=`*(ih: Dial_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # WOM_CB WOM_CB Action generated when an audio device receives an
    # event. [Windows Only] Callback int function(Ihandle *ih, int
    # state); [in C] ih:wom_cb(state: number) -> (ret: number) [in
    # Lua] ih: identifies the element that activated the event. state:
    # can be opening=1, done=0, or closing=-1. Notes This callback is
    # used to syncronize video playback with audio. It is sent when
    # the audio device: Message Description opening is opened by using
    # the waveOutOpen function. done is finished with a data block
    # sent by using the waveOutWrite function. closing is closed by
    # using the waveOutClose function. You must use the HWND attribute
    # when calling waveOutOpen in the dwCallback parameter and set
    # fdwOpen to CALLBACK_WINDOW. Affects IupDialog, IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: Dial_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: Dial_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WOM_CB")))

proc Dialog*(child: IUPhandle_t): Dialog_t {.cdecl.} =
    # Creates a dialog element. It manages user interaction with the
    # interface elements. For any interface element to be shown, it
    # must be encapsulated in a dialog.
    return Dialog_t(niupc.Dialog(cast[PIhandle](child)))

proc `active=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # ACTIVE, BGCOLOR, FONT, EXPAND, SCREENPOSITION, WID, TIP,
    # CLIENTOFFSET, CLIENTSIZE, RASTERSIZE, ZORDER: also accepted.
    # Note that ACTIVE, BGCOLOR and FONT will also affect all the
    # controls inside the dialog.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `activewindow`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVEWINDOW")) == "YES"

proc `background=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # BACKGROUND (non inheritable): Dialog background color or image.
    # Can be a non inheritable alternative to BGCOLOR or can be the
    # name of an image to be tiled on the background. See also the
    # screenshots of the sample.c results with normal background,
    # changing the dialog BACKGROUND, the dialog BGCOLOR and the
    # children BGCOLOR. Not working in GTK 3. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(value))

proc `background`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(value))

proc `background=`*(ih: Dialog_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(&"{red} {green} {blue} {alpha}"))

proc `background`*(ih: Dialog_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(&"{red} {green} {blue} {alpha}"))

proc `background`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"))

proc `bgcolor=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: Dialog_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Dialog_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # BORDER (non inheritable) (creation only): Shows a resize border
    # around the dialog. Default: "YES". BORDER=NO is useful only when
    # RESIZE=NO, MAXBOX=NO, MINBOX=NO, MENUBOX=NO and TITLE=NULL, if
    # any of these are defined there will be always some border.
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `bordersize`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERSIZE"))

proc `bringfront=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # BRINGFRONT [Windows Only] (write-only): makes the dialog the
    # foreground window. Use "YES" to activate it. Useful for
    # multithreaded applications.
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring(value))

proc `bringfront`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring(value))

proc `bringfront=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring((if yes: "YES" else: "NO")))

proc `bringfront`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring((if yes: "YES" else: "NO")))

proc `bringfront`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT")) == "YES"

proc `canfocus=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `childoffset=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # CHILDOFFSET: Allow to specify a position offset for the child.
    # Available for native containers only. It will not affect the
    # natural size, and allows to position controls outside the client
    # area. Format "dxxdy", where dx and dy are integer values
    # corresponding to the horizontal and vertical offsets,
    # respectively, in pixels. Default: 0x0. (since 3.14)
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset=`*(ih: Dialog_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: Dialog_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"))

proc `clientoffset`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(value))

proc `clientsize`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(value))

proc `clientsize=`*(ih: Dialog_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(&"{width}x{height}"))

proc `clientsize`*(ih: Dialog_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(&"{width}x{height}"))

proc `clientsize`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `composited=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # COMPOSITED [Windows Only] (creation only): controls if the
    # window will have an automatic double buffer for all children.
    # Default is "NO". In Windows Vista it is NOT working as expected.
    # It is NOT compatible with IupCanvas and all derived IUP controls
    # such as IupFlat*, IupGL*, IupPlot and IupMatrix, because
    # IupCanvas uses CS_OWNDC in the window class.
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring(value))

proc `composited`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring(value))

proc `composited=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring((if yes: "YES" else: "NO")))

proc `composited`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring((if yes: "YES" else: "NO")))

proc `composited`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("COMPOSITED")) == "YES"

proc `control=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # CONTROL [Windows Only] (creation only): Embeds the dialog inside
    # another window.
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring(value))

proc `control`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring(value))

proc `control=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring((if yes: "YES" else: "NO")))

proc `control`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring((if yes: "YES" else: "NO")))

proc `control`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CONTROL")) == "YES"

proc `cursor=`*(ih: Dialog_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # CURSOR (non inheritable): Defines a cursor for the dialog.
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: Dialog_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `customframe=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # CUSTOMFRAME [Windows and GTK Only] (non inheritable): allows the
    # application to customize the dialog frame elements (the title
    # and its buttons) by using IUP controls for its elements like
    # caption, minimize button, maximize button, and close buttons.
    # The custom frame support uses the native system support for
    # custom frames. The application is responsible for leaving space
    # for the borders. One drawback is that menu bars will not work.
    # For the dialog to be able to be moved an IupLabel or an
    # IupCanvas must be at the top of the dialog and must have the
    # NAME attribute set to CUSTOMFRAMECAPTION (since 3.22). Native
    # custom frames are supported only in Windows and in GTK version
    # 3.10, so for older GTK versions we have to simulate the support
    # using CUSTOMFRAMESIMULATE. (since 3.18) (renamed in 3.22) (GTK
    # support since 3.22) See the Custom Frame notes bellow.
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring(value))

proc `customframe`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring(value))

proc `customframe=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring((if yes: "YES" else: "NO")))

proc `customframe`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring((if yes: "YES" else: "NO")))

proc `customframe`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME")) == "YES"

proc `customframesimulate=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # CUSTOMFRAMESIMULATE: allows the application to customize the
    # dialog frame elements (the title and its buttons) by using IUP
    # controls for its elements like caption, minimize button,
    # maximize button, and close buttons. The custom frame support is
    # entirely simulated by IUP, no native support for custom frame is
    # used (this seems to have less drawbacks on the application
    # behavior). The application is responsible for leaving space for
    # the borders. One drawback is that menu bars will not work. For
    # the dialog to be able to be moved an IupLabel, or a IupFlatLabel
    # or an IupCanvas must be at the top of the dialog and must have
    # the NAME attribute set to CUSTOMFRAMECAPTION. See the Custom
    # Frame notes bellow. (since 3.28)
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring(value))

proc `customframesimulate`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring(value))

proc `customframesimulate=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring((if yes: "YES" else: "NO")))

proc `customframesimulate`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring((if yes: "YES" else: "NO")))

proc `customframesimulate`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE")) == "YES"

proc `defaultenter=`*(ih: Dialog_t, handle: IUPhandle_t) {.cdecl.} =
    # DEFAULTENTER: Name of the button activated when the user press
    # Enter when focus is in another control of the dialog. Use
    # IupSetHandle or IupSetAttributeHandle to associate a button to a
    # name.
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTENTER"), cast[PIhandle](handle))

proc `defaultenter`*(ih: Dialog_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTENTER"), cast[PIhandle](handle))

proc `defaultenter`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DEFAULTENTER"))

proc `defaultesc=`*(ih: Dialog_t, handle: IUPhandle_t) {.cdecl.} =
    # DEFAULTESC: Name of the button activated when the user press Esc
    # when focus is in another control of the dialog. Use IupSetHandle
    # or IupSetAttributeHandle to associate a button to a name.
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTESC"), cast[PIhandle](handle))

proc `defaultesc`*(ih: Dialog_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTESC"), cast[PIhandle](handle))

proc `defaultesc`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DEFAULTESC"))

proc `dialogframe=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # DIALOGFRAME: Set the common decorations for modal dialogs. This
    # means RESIZE=NO, MINBOX=NO and MAXBOX=NO. In Windows, if the
    # PARENTDIALOG is defined then the MENUBOX is also removed, but
    # the Close button remains.
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring(value))

proc `dialogframe`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring(value))

proc `dialogframe=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring((if yes: "YES" else: "NO")))

proc `dialogframe`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring((if yes: "YES" else: "NO")))

proc `dialogframe`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME")) == "YES"

proc `dialoghint=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # DIALOGHINT [GTK Only] (creation-only): if enabled sets the
    # window type hint to a dialog hint.
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring(value))

proc `dialoghint`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring(value))

proc `dialoghint=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring((if yes: "YES" else: "NO")))

proc `dialoghint`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring((if yes: "YES" else: "NO")))

proc `dialoghint`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT")) == "YES"

proc `dragdrop=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary dialog
proc `dragtypes`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

proc `dropfilestarget=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # DROPFILESTARGET [Windows and GTK Only] (non inheritable): Enable
    # or disable the drop of files. Default: NO, but if DROPFILES_CB
    # is defined when the element is mapped then it will be
    # automatically enabled.
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary dialog
proc `droptypes`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `expand=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable): The default value is "YES".
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Dialog_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Dialog_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary dialog
proc `font`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary dialog
proc `fontface`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Dialog_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Dialog_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary dialog
proc `fontstyle`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `fullscreen=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # FULLSCREEN: Makes the dialog occupy the whole screen over any
    # system bars in the main monitor. All dialog details, such as
    # title bar, borders, maximize button, etc, are removed. Possible
    # values: YES, NO. In Motif you may have to click in the dialog to
    # set its focus. In Motif if set to YES when the dialog is hidden,
    # then it can not be changed after it is visible.
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring(value))

proc `fullscreen`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring(value))

proc `fullscreen=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring((if yes: "YES" else: "NO")))

proc `fullscreen`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring((if yes: "YES" else: "NO")))

proc `handlename=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary dialog
proc `handlename`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `helpbutton=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # HELPBUTTON [Windows Only] (creation only): Inserts a help button
    # in the same place of the maximize button. It can only be used
    # for dialogs without the minimize and maximize buttons, and with
    # the menu box. For the next interaction of the user with a
    # control in the dialog, the callback HELP_CB will be called
    # instead of the control defined ACTION callback. Possible values:
    # YES, NO. Default: NO.
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring(value))

proc `helpbutton`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring(value))

proc `helpbutton=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring((if yes: "YES" else: "NO")))

proc `helpbutton`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring((if yes: "YES" else: "NO")))

proc `helpbutton`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON")) == "YES"

proc `hidetaskbar=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # HIDETASKBAR [Windows and GTK Only] (write-only): Action
    # attribute that when set to "YES", hides the dialog, but does not
    # decrement the visible dialog count, does not call SHOW_CB and
    # does not mark the dialog as hidden inside IUP. It is usually
    # used to hide the dialog and keep the tray icon working without
    # closing the main loop. It has the same effect as setting
    # LOCKLOOP=Yes and normally hiding the dialog. IMPORTANT: when you
    # hide using HIDETASKBAR, you must show using HIDETASKBAR also.
    # Possible values: YES, NO.
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring(value))

proc `hidetaskbar`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring(value))

proc `hidetaskbar=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring((if yes: "YES" else: "NO")))

proc `hidetaskbar`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring((if yes: "YES" else: "NO")))

proc `hidetaskbar`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR")) == "YES"

proc `hidetitlebar=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # HIDETITLEBAR [GTK Only] (non inheritable): hides the title bar
    # with al its elements. (since 3.20) (GTK 3.10)
    SetAttribute(cast[PIhandle](ih), cstring("HIDETITLEBAR"), cstring(value))

proc `hidetitlebar`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETITLEBAR"), cstring(value))

# TODO ??? String Binary dialog
proc `hidetitlebar`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIDETITLEBAR"))

proc `icon=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # ICON: Dialogs icon. The Windows SDK recommends that cursors and
    # icons should be implemented as resources rather than created at
    # run time.
    SetAttribute(cast[PIhandle](ih), cstring("ICON"), cstring(value))

proc `icon`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ICON"), cstring(value))

# TODO ??? String Binary dialog
proc `icon`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ICON"))

proc `maxbox=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # MAXBOX (creation only): Requires a maximize button from the
    # window manager. If RESIZE=NO then MAXBOX will be set to NO.
    # Default: YES. In Motif the decorations are controlled by the
    # Window Manager and may not be possible to be changed from IUP.
    # In Windows MAXBOX is hidden only if MINBOX is hidden as well, or
    # else it will be just disabled.
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring(value))

proc `maxbox`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring(value))

proc `maxbox=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring((if yes: "YES" else: "NO")))

proc `maxbox`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring((if yes: "YES" else: "NO")))

proc `maxbox`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXBOX")) == "YES"

proc `maximized`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXIMIZED")) == "YES"

proc `maxsize=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # MAXSIZE: Maximum size for the dialog in raster units (pixels).
    # The windowing system will not be able to change the size beyond
    # this limit. Default: 65535x65535. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Dialog_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Dialog_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `mdichild=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # MDICHILD (creation only) [Windows Only]: Configure this dialog
    # to be a MDI child. Can be YES or NO. The PARENTDIALOG attribute
    # must also be defined. Each MDI child is automatically named if
    # it does not have one. Default: NO.
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring(value))

proc `mdichild`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring(value))

proc `mdichild=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring((if yes: "YES" else: "NO")))

proc `mdichild`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring((if yes: "YES" else: "NO")))

proc `mdichild`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDICHILD")) == "YES"

proc `mdiclient=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # MDICLIENT (creation only) [Windows Only] (non inheritable):
    # Configure the canvas as a MDI client. Can be YES or NO. No
    # callbacks will be called. This canvas will be used internally
    # only by the MDI Frame and its MDI Children. The MDI frame must
    # have one and only one MDI client. Default: NO.
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring(value))

proc `mdiclient`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring(value))

proc `mdiclient=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring((if yes: "YES" else: "NO")))

proc `mdiclient`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring((if yes: "YES" else: "NO")))

proc `mdiclient`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDICLIENT")) == "YES"

proc `mdiframe=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # MDIFRAME (creation only) [Windows Only] (non inheritable):
    # Configure this dialog as a MDI frame. Can be YES or NO. Default:
    # NO.
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring(value))

proc `mdiframe`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring(value))

proc `mdiframe=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring((if yes: "YES" else: "NO")))

proc `mdiframe`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring((if yes: "YES" else: "NO")))

proc `mdiframe`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDIFRAME")) == "YES"

proc `mdimenu=`*(ih: Dialog_t, handle: Menu_t) {.cdecl.} =
    # MDIMENU (creation only) [Windows Only]: Name of a IupMenu to be
    # used as the Window list of a MDI frame. The system will
    # automatically add the list of MDI child windows there.
    SetAttributeHandle(cast[PIhandle](ih), cstring("MDIMENU"), cast[PIhandle](handle))

proc `mdimenu`*(ih: Dialog_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MDIMENU"), cast[PIhandle](handle))

proc `mdimenu`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDIMENU"))

proc `menu=`*(ih: Dialog_t, handle: Menu_t) {.cdecl.} =
    # MENU: Name of a menu. Associates a menu to the dialog as a menu
    # bar. The previous menu, if any, is unmapped. Use IupSetHandle or
    # IupSetAttributeHandle to associate a menu to a name. See also
    # IupMenu.
    SetAttributeHandle(cast[PIhandle](ih), cstring("MENU"), cast[PIhandle](handle))

proc `menu`*(ih: Dialog_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MENU"), cast[PIhandle](handle))

proc `menu`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MENU"))

proc `menubox=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # MENUBOX (creation only): Requires a system menu box from the
    # window manager. If hidden will also remove the Close button.
    # Default: YES. In Motif the decorations are controlled by the
    # Window Manager and may not be possible to be changed from IUP.
    # In Windows if hidden will hide also MAXBOX and MINBOX.
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring(value))

proc `menubox`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring(value))

proc `menubox=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring((if yes: "YES" else: "NO")))

proc `menubox`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring((if yes: "YES" else: "NO")))

proc `menubox`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MENUBOX")) == "YES"

proc `minbox=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # MINBOX (creation only): Requires a minimize button from the
    # window manager. Default: YES. In Motif the decorations are
    # controlled by the Window Manager and may not be possible to be
    # changed from IUP. In Windows MINBOX is hidden only if MAXBOX is
    # hidden as well, or else it will be just disabled.
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring(value))

proc `minbox`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring(value))

proc `minbox=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring((if yes: "YES" else: "NO")))

proc `minbox`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring((if yes: "YES" else: "NO")))

proc `minbox`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINBOX")) == "YES"

proc `minsize=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # MINSIZE: Minimum size for the dialog in raster units (pixels).
    # The windowing system will not be able to change the size beyond
    # this limit. Default: 1x1. Some systems define a very minimum
    # size greater than this, for instance in Windows the horizontal
    # minimum size includes the window decoration buttons. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Dialog_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Dialog_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `modal`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MODAL")) == "YES"

proc `nactive=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # NACTIVE (non inheritable): same as ACTIVE but does not affects
    # the controls inside the dialog. (since 3.13)
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring(value))

proc `nactive`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring(value))

proc `nactive=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `nactive`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `nactive`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NACTIVE")) == "YES"

proc `name=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary dialog
proc `name`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `nativeparent=`*(ih: Dialog_t, handle: User_t) {.cdecl.} =
    # NATIVEPARENT (creation only): Native handle of a dialog to be
    # used as parent. Used only if PARENTDIALOG is not defined.
    SetAttributeHandle(cast[PIhandle](ih), cstring("NATIVEPARENT"), cast[PIhandle](handle))

proc `nativeparent`*(ih: Dialog_t, handle: User_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("NATIVEPARENT"), cast[PIhandle](handle))

proc `nativeparent`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATIVEPARENT"))

proc `naturalsize`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `noflush=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring(value))

proc `noflush`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring(value))

proc `noflush=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring((if yes: "YES" else: "NO")))

proc `noflush`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring((if yes: "YES" else: "NO")))

proc `noflush`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NOFLUSH")) == "YES"

proc `normalizergroup=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary dialog
proc `normalizergroup`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary dialog
proc `ntheme`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `opacity=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # OPACITY [Windows and GTK Only]: sets the dialog transparency
    # alpha value. Valid values range from 0 (completely transparent)
    # to 255 (opaque). In Windows must be set before map so the native
    # window would be properly initialized when mapped (since 3.16).
    # (GTK 2.12)
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(value))

proc `opacity`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(value))

proc `opacity=`*(ih: Dialog_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(&"{x}"))

proc `opacity`*(ih: Dialog_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(&"{x}"))

proc `opacity`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("OPACITY"))

proc `opacityimage=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # OPACITYIMAGE [Windows Only]: sets an RGBA image as the dialog
    # background so it is possible to create a non rectangle window
    # with transparency, but it can not have children. Used usually
    # for splash screens. It must be set before map so the native
    # window would be properly initialized when mapped. Works also for
    # GTK but as the SHAPEIMAGE attribute. (since 3.16)
    SetAttribute(cast[PIhandle](ih), cstring("OPACITYIMAGE"), cstring(value))

proc `opacityimage`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITYIMAGE"), cstring(value))

# TODO ??? String Binary dialog
proc `opacityimage`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("OPACITYIMAGE"))

# TODO unknown: dialog PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: dialog PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `parentdialog=`*(ih: Dialog_t, handle: IUPhandle_t) {.cdecl.} =
    # PARENTDIALOG (creation only): Name of a dialog to be used as
    # parent.
    SetAttributeHandle(cast[PIhandle](ih), cstring("PARENTDIALOG"), cast[PIhandle](handle))

proc `parentdialog`*(ih: Dialog_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("PARENTDIALOG"), cast[PIhandle](handle))

proc `parentdialog`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PARENTDIALOG"))

proc `placement=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # PLACEMENT: Changes how the dialog will be shown. Values: "FULL",
    # "MAXIMIZED", "MINIMIZED" and "NORMAL". Default: NORMAL. After
    # IupShow/IupPopup the attribute is set back to "NORMAL". FULL is
    # similar to FULLSCREEN but only the dialog client area covers the
    # screen area, menu and decorations will be there but out of the
    # screen. In UNIX there is a chance that the placement won't work
    # correctly, that depends on the Window Manager. In Windows, the
    # SHOWNOACTIVATE attribute can be set to Yes to prevent the window
    # from being activated (since 3.15). In Windows, the
    # SHOWMINIMIZENEXT attribute can be set to Yes to activate the
    # next top-level window in the Z order when minimizing (since
    # 3.15).
    SetAttribute(cast[PIhandle](ih), cstring("PLACEMENT"), cstring(value))

proc `placement`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PLACEMENT"), cstring(value))

proc `placement`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PLACEMENT"))

proc `position=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Dialog_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Dialog_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # Values set at SIZE or RASTERSIZE attributes of a dialog are
    # always accepted, regardless of the minimum size required by its
    # children. For a dialog to have the minimum necessary size to fit
    # all elements contained in it, simply define SIZE or RASTERSIZE
    # to NULL. Also if you set SIZE or RASTERSIZE to be used as the
    # initial size of the dialog, its contents will be limited to this
    # size as the minimum size, if you do not want that, then after
    # showing the dialog reset this size to NULL so the dialog can be
    # resized to smaller values. But notice that its contents will
    # still be limited by the Natural size, to also remove that
    # limitation set SHRINK=YES. To only change the User size in
    # pixels, without resetting the Current size, set the USERSIZE
    # attribute (since 3.12). Values set at SIZE or RASTERSIZE
    # attributes of a dialog are always accepted, regardless of the
    # minimum size required by its children. For a dialog to have the
    # minimum necessary size to fit all elements contained in it,
    # simply define SIZE or RASTERSIZE to NULL. Also if you set SIZE
    # or RASTERSIZE to be used as the initial size of the dialog, its
    # contents will be limited to this size as the minimum size, if
    # you do not want that, then after showing the dialog reset this
    # size to NULL so the dialog can be resized to smaller values. But
    # notice that its contents will still be limited by the Natural
    # size, to also remove that limitation set SHRINK=YES. To only
    # change the User size in pixels, without resetting the Current
    # size, set the USERSIZE attribute (since 3.12). Values set at
    # SIZE or RASTERSIZE attributes of a dialog are always accepted,
    # regardless of the minimum size required by its children. For a
    # dialog to have the minimum necessary size to fit all elements
    # contained in it, simply define SIZE or RASTERSIZE to NULL. Also
    # if you set SIZE or RASTERSIZE to be used as the initial size of
    # the dialog, its contents will be limited to this size as the
    # minimum size, if you do not want that, then after showing the
    # dialog reset this size to NULL so the dialog can be resized to
    # smaller values. But notice that its contents will still be
    # limited by the Natural size, to also remove that limitation set
    # SHRINK=YES. To only change the User size in pixels, without
    # resetting the Current size, set the USERSIZE attribute (since
    # 3.12).
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Dialog_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Dialog_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `resize=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # RESIZE (creation only): Allows interactively changing the
    # dialogs size. Default: YES. If RESIZE=NO then MAXBOX will be set
    # to NO. In Motif the decorations are controlled by the Window
    # Manager and may not be possible to be changed from IUP.
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(value))

proc `resize`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(value))

proc `resize=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring((if yes: "YES" else: "NO")))

proc `resize`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring((if yes: "YES" else: "NO")))

proc `resize`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RESIZE")) == "YES"

proc `saveunder=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # SAVEUNDER [Windows and Motif Only] (creation only): When this
    # attribute is true (YES), the dialog stores the original image of
    # the desktop region it occupies (if the system has enough memory
    # to store the image). In this case, when the dialog is closed or
    # moved, a redrawing event is not generated for the windows that
    # were shadowed by it. Its default value is YES if the dialog has
    # a parent dialog (since 3.24). To save memory disable it for your
    # main dialog. Not available in GTK.
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring(value))

proc `saveunder`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring(value))

proc `saveunder=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring((if yes: "YES" else: "NO")))

proc `saveunder`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring((if yes: "YES" else: "NO")))

proc `saveunder`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER")) == "YES"

proc `screenposition`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `shapeimage=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # SHAPEIMAGE [Windows and GTK Only]: sets a RGBA image as the
    # dialog shape so it is possible to create a non rectangle window
    # with children. (GTK 2.12) Only the fully transparent pixels will
    # be transparent. The pixels colors will be ignored, only the
    # alpha channel is used. (since 3.26)
    SetAttribute(cast[PIhandle](ih), cstring("SHAPEIMAGE"), cstring(value))

proc `shapeimage`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHAPEIMAGE"), cstring(value))

# TODO ??? String Binary dialog
proc `shapeimage`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHAPEIMAGE"))

proc `shownofocus=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # SHOWNOFOCUS: do not set focus after show. (since 3.30)
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring(value))

proc `shownofocus`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring(value))

proc `shownofocus=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `shownofocus`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `shownofocus`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS")) == "YES"

proc `shrink=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # SHRINK: Allows changing the elements distribution when the
    # dialog is smaller than the minimum size. Default: NO.
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring(value))

proc `shrink`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring(value))

proc `shrink=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring((if yes: "YES" else: "NO")))

proc `shrink`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring((if yes: "YES" else: "NO")))

proc `shrink`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHRINK")) == "YES"

proc `simulatemodal=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # SIMULATEMODAL (write-only): disable all other visible dialogs,
    # just like when the dialog is made modal. (since 3.21)
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring(value))

proc `simulatemodal`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring(value))

proc `simulatemodal=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring((if yes: "YES" else: "NO")))

proc `simulatemodal`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring((if yes: "YES" else: "NO")))

proc `size=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # SIZE (non inheritable): Dialogs size. Additionally the following
    # values can also be defined for width and/or height: "FULL":
    # Defines the dialogs width (or height) equal to the screen's
    # width (or height) "HALF": Defines the dialogs width (or height)
    # equal to half the screen's width (or height) "THIRD": Defines
    # the dialogs width (or height) equal to 1/3 the screen's width
    # (or height) "QUARTER": Defines the dialogs width (or height)
    # equal to 1/4 of the screen's width (or height) "EIGHTH": Defines
    # the dialogs width (or height) equal to 1/8 of the screen's width
    # (or height). Values set at SIZE or RASTERSIZE attributes of a
    # dialog are always accepted, regardless of the minimum size
    # required by its children. For a dialog to have the minimum
    # necessary size to fit all elements contained in it, simply
    # define SIZE or RASTERSIZE to NULL. Also if you set SIZE or
    # RASTERSIZE to be used as the initial size of the dialog, its
    # contents will be limited to this size as the minimum size, if
    # you do not want that, then after showing the dialog reset this
    # size to NULL so the dialog can be resized to smaller values. But
    # notice that its contents will still be limited by the Natural
    # size, to also remove that limitation set SHRINK=YES. To only
    # change the User size in pixels, without resetting the Current
    # size, set the USERSIZE attribute (since 3.12). Values set at
    # SIZE or RASTERSIZE attributes of a dialog are always accepted,
    # regardless of the minimum size required by its children. For a
    # dialog to have the minimum necessary size to fit all elements
    # contained in it, simply define SIZE or RASTERSIZE to NULL. Also
    # if you set SIZE or RASTERSIZE to be used as the initial size of
    # the dialog, its contents will be limited to this size as the
    # minimum size, if you do not want that, then after showing the
    # dialog reset this size to NULL so the dialog can be resized to
    # smaller values. But notice that its contents will still be
    # limited by the Natural size, to also remove that limitation set
    # SHRINK=YES. To only change the User size in pixels, without
    # resetting the Current size, set the USERSIZE attribute (since
    # 3.12). Values set at SIZE or RASTERSIZE attributes of a dialog
    # are always accepted, regardless of the minimum size required by
    # its children. For a dialog to have the minimum necessary size to
    # fit all elements contained in it, simply define SIZE or
    # RASTERSIZE to NULL. Also if you set SIZE or RASTERSIZE to be
    # used as the initial size of the dialog, its contents will be
    # limited to this size as the minimum size, if you do not want
    # that, then after showing the dialog reset this size to NULL so
    # the dialog can be resized to smaller values. But notice that its
    # contents will still be limited by the Natural size, to also
    # remove that limitation set SHRINK=YES. To only change the User
    # size in pixels, without resetting the Current size, set the
    # USERSIZE attribute (since 3.12).
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Dialog_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Dialog_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size=`*(ih: Dialog_t, width: string, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Dialog_t, width: string, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size=`*(ih: Dialog_t, width: int, height:string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Dialog_t, width: int, height:string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `startfocus=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # STARTFOCUS: Name of the element that must receive the focus
    # right after the dialog is shown using IupShow or IupPopup. If
    # not defined then the first control than can receive the focus is
    # selected (same effect of calling IupNextField for the dialog).
    # Updated after SHOW_CB is called and only if the focus was not
    # changed during the callback.
    SetAttribute(cast[PIhandle](ih), cstring("STARTFOCUS"), cstring(value))

proc `startfocus`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STARTFOCUS"), cstring(value))

# TODO ??? String Binary dialog
proc `startfocus`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("STARTFOCUS"))

proc `theme=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary dialog
proc `theme`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary dialog
proc `tip`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: Dialog_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Dialog_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: Dialog_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Dialog_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: Dialog_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Dialog_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary dialog
proc `tipicon`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary dialog
proc `tipmarkup`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: Dialog_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Dialog_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `title=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # TITLE (non inheritable): Dialogs title. Default: NULL. If you
    # want to remove the title bar you must also set MENUBOX=NO,
    # MAXBOX=NO and MINBOX=NO, before map. But in Motif and GTK it
    # will hide it only if RESIZE=NO also.
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary dialog
proc `title`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

proc `toolbox=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # TOOLBOX [Windows Only] (creation only): makes the dialog look
    # like a toolbox with a smaller title bar. It is only valid if the
    # PARENTDIALOG or NATIVEPARENT attribute is also defined. Default:
    # NO.
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring(value))

proc `toolbox`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring(value))

proc `toolbox=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring((if yes: "YES" else: "NO")))

proc `toolbox`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring((if yes: "YES" else: "NO")))

proc `toolbox`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOOLBOX")) == "YES"

proc `topmost=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # TOPMOST [Windows and GTK Only]: puts the dialog always in front
    # of all other dialogs in all applications. Default: NO.
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring(value))

proc `topmost`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring(value))

proc `topmost=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring((if yes: "YES" else: "NO")))

proc `topmost`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring((if yes: "YES" else: "NO")))

proc `tray=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # TRAY [Windows and GTK Only]: When set to "YES", displays an icon
    # on the system tray. (GTK 2.10 and GTK < 3.14)
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring(value))

proc `tray`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring(value))

proc `tray=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring((if yes: "YES" else: "NO")))

proc `tray`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring((if yes: "YES" else: "NO")))

proc `tray`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAY")) == "YES"

proc `trayimage=`*(ih: Dialog_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # TRAYIMAGE [Windows and GTK Only]: Name of a IUP image to be used
    # as the tray icon. The Windows SDK recommends that cursors and
    # icons should be implemented as resources rather than created at
    # run time. (GTK 2.10 and GTK < 3.14)
    SetAttributeHandle(cast[PIhandle](ih), cstring("TRAYIMAGE"), cast[PIhandle](handle))

proc `trayimage`*(ih: Dialog_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("TRAYIMAGE"), cast[PIhandle](handle))

proc `trayimage`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAYIMAGE"))

proc `traytip=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # TRAYTIP [Windows and GTK Only]: Tray icon's tooltip text. (GTK
    # 2.10 and GTK < 3.14)
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIP"), cstring(value))

proc `traytip`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIP"), cstring(value))

# TODO ??? String Binary dialog
proc `traytip`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAYTIP"))

proc `traytipmarkup=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # TRAYTIPMARKUP [GTK Only]: allows the tip string to contains
    # Pango markup commands. Can be "YES" or "NO". Default: "NO". Must
    # be set before setting the TRAYTIP attribute. (GTK 2.16) (since
    # 3.6)
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIPMARKUP"), cstring(value))

proc `traytipmarkup`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIPMARKUP"), cstring(value))

# TODO ??? String Binary dialog
proc `traytipmarkup`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAYTIPMARKUP"))

proc `usersize=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Dialog_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Dialog_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: Dialog_t, value: string) {.cdecl.} =
    # VISIBLE: Simply call IupShow or IupHide for the dialog.
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Dialog_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Dialog_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

# TODO unknown: dialog XFONTID Unknown Binary
proc `xfontid`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

# TODO unknown: dialog XWINDOW Unknown Binary
proc `xwindow`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: Dialog_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `zorder=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `gap=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("GAP"), cstring(cstring(value)))

proc `gap`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("GAP"), cstring(cstring(value)))

proc `gap=`*(ih: Dialog_t, value: int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("GAP"), cstring(cstring(&"value")))

proc `gap`*(ih: Dialog_t, value: int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("GAP"), cstring(cstring(&"value")))

proc `margin=`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(cstring(value)))

proc `margin`*(ih: Dialog_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(cstring(value)))

proc `margin=`*(ih: Dialog_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(&"{horiz}x{vert}"))

proc `margin`*(ih: Dialog_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(&"{horiz}x{vert}"))

proc `shapeimage=`*(ih: Dialog_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SHAPEIMAGE"), cast[PIhandle](handle))

proc `shapeimage`*(ih: Dialog_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SHAPEIMAGE"), cast[PIhandle](handle))

proc `close_cb=`*(ih: Dialog_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # CLOSE_CB CLOSE_CB Called just before a dialog is closed when the
    # user clicks the close button of the title bar or an equivalent
    # action. Callback int function(Ihandle *ih); [in C] ih:close_cb()
    # -> (ret: number) [in Lua] ih: identifies the element that
    # activated the event. Returns: if IUP_IGNORE, it prevents the
    # dialog from being closed. If you destroy the dialog in this
    # callback, you must return IUP_IGNORE. IUP_CLOSE will be
    # processed. Affects IupDialog
    SetCallback(cast[PIhandle](ih), cstring("CLOSE_CB"), cast[Icallback](cb))

proc `close_cb`*(ih: Dialog_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("CLOSE_CB"), cast[Icallback](cb))

proc `close_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("CLOSE_CB")))

proc `destroy_cb=`*(ih: Dialog_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Dialog_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: Dialog_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: Dialog_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: Dialog_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: Dialog_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: Dialog_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: Dialog_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: Dialog_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: Dialog_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: Dialog_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: Dialog_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: Dialog_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: Dialog_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: Dialog_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: Dialog_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: Dialog_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Dialog_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `focus_cb=`*(ih: Dialog_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    # FOCUS_CB: Called when the dialog or any of its children gets the
    # focus, or when another dialog or any control in another dialog
    # gets the focus. It is called after the common callbacks
    # GETFOCUS_CB and KILL_FOCUS_CB. (since 3.21) int function(Ihandle
    # *ih, int focus); [in C]ih:focus_cb(focus: number) -> (ret:
    # number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: Dialog_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: Dialog_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Dialog_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: Dialog_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Dialog_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `killfocus_cb=`*(ih: Dialog_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Dialog_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: Dialog_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Dialog_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: Dialog_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Dialog_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: Dialog_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Dialog_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: Dialog_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Dialog_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: Dialog_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Dialog_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: Dialog_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: Dialog_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `show_cb=`*(ih: Dialog_t, cb: proc (ih: PIhandle, state: cint): cint {.cdecl.}) {.cdecl.} =
    # SHOW_CB SHOW_CB Called right after the dialog is showed, hidden,
    # maximized, minimized or restored from minimized/maximized. This
    # callback is called when those actions were performed by the user
    # or programmatically by the application. Callback int
    # function(Ihandle *ih, int state); [in C] ih:show_cb(state:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. state: indicates which of the
    # following situations generated the event: IUP_HIDE (since 3.0)
    # IUP_SHOW IUP_RESTORE (was minimized or maximized) IUP_MINIMIZE
    # IUP_MAXIMIZE (since 3.0) (not received in Motif when activated
    # from the maximize button) Returns: IUP_CLOSE will be processed.
    # Affects IupDialog
    SetCallback(cast[PIhandle](ih), cstring("SHOW_CB"), cast[Icallback](cb))

proc `show_cb`*(ih: Dialog_t, cb: proc (ih: PIhandle, state: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SHOW_CB"), cast[Icallback](cb))

proc `show_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SHOW_CB")))

proc `trayclick_cb=`*(ih: Dialog_t, cb: proc (ih: PIhandle, but, pressed, dclick: cint): cint {.cdecl.}) {.cdecl.} =
    # TRAYCLICK_CB [Windows and GTK Only]: Called right after the
    # mouse button is pressed or released over the tray icon. (GTK
    # 2.10) int function(Ihandle *ih, int but, int pressed, int
    # dclick); [in C]elem:trayclick_cb(but, pressed, dclick: number)
    # -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("TRAYCLICK_CB"), cast[Icallback](cb))

proc `trayclick_cb`*(ih: Dialog_t, cb: proc (ih: PIhandle, but, pressed, dclick: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("TRAYCLICK_CB"), cast[Icallback](cb))

proc `trayclick_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("TRAYCLICK_CB")))

proc `unmap_cb=`*(ih: Dialog_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Dialog_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Dialog_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc DropButton*(dropchild: IUPhandle_t): DropButton_t {.cdecl.} =
    # Creates an interface element that is a button with a drop down
    # arrow. It can function as a button and as a dropdown. Its visual
    # presentation can contain a text and/or an image. When dropped
    # displays a child inside a dialog with no decorations, so it can
    # simulate the initial function of a dropdown list, but it can
    # display any layout of IUP elements inside the dropped dialog.
    # When the user click outside the dialog, it is automatically
    # closed. It inherits from IupCanvas.
    return DropButton_t(niupc.DropButton(cast[PIhandle](dropchild)))

proc `active=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # ACTIVE, FONT, EXPAND, SCREENPOSITION, POSITION, MINSIZE,
    # MAXSIZE, WID, TIP, SIZE, RASTERSIZE, ZORDER, VISIBLE, THEME:
    # also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `alignment=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # ALIGNMENT (non inheritable): horizontal and vertical alignment
    # of the set image+text. Possible values: "ALEFT", "ACENTER" and
    # "ARIGHT", combined to "ATOP", "ACENTER" and "ABOTTOM". Default:
    # "ALEFT:ACENTER". Partial values are also accepted, like "ARIGHT"
    # or ":ATOP", the other value will be obtained from the default
    # value. Alignment does not includes the padding area.
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"))

# TODO unknown: dropbutton ARROWACTIVE Unknown Binary
proc `arrowactive`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ARROWACTIVE"))

# TODO unknown: dropbutton ARROWALIGN Unknown Binary
proc `arrowalign`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ARROWALIGN"))

# TODO unknown: dropbutton ARROWCOLOR Unknown Binary
proc `arrowcolor`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ARROWCOLOR"))

proc `arrowimage=`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # ARROWIMAGE (non inheritable): Arrow image name. Use IupSetHandle
    # or IupSetAttributeHandle to associate an image to a name. See
    # also IupImage.
    SetAttributeHandle(cast[PIhandle](ih), cstring("ARROWIMAGE"), cast[PIhandle](handle))

proc `arrowimage`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("ARROWIMAGE"), cast[PIhandle](handle))

proc `arrowimage`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGE"))

proc `arrowimagehighlight=`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # ARROWIMAGEHIGHLIGHT (non inheritable): Arrow image name of the
    # element in highlight state. If it is not defined then the
    # ARROWIMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("ARROWIMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `arrowimagehighlight`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("ARROWIMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `arrowimagehighlight`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGEHIGHLIGHT"))

proc `arrowimageinactive=`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # ARROWIMAGEINACTIVE (non inheritable): Arrow image name of the
    # element when inactive. If it is not defined then the ARROWIMAGE
    # is used and its colors will be replaced by a modified version
    # creating the disabled effect.
    SetAttributeHandle(cast[PIhandle](ih), cstring("ARROWIMAGEINACTIVE"), cast[PIhandle](handle))

proc `arrowimageinactive`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("ARROWIMAGEINACTIVE"), cast[PIhandle](handle))

proc `arrowimageinactive`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGEINACTIVE"))

proc `arrowimagepress=`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # ARROWIMAGEPRESS (non inheritable): Arrow image name of the
    # element in pressed state. If it is not defined then the
    # ARROWIMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("ARROWIMAGEPRESS"), cast[PIhandle](handle))

proc `arrowimagepress`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("ARROWIMAGEPRESS"), cast[PIhandle](handle))

proc `arrowimagepress`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGEPRESS"))

proc `arrowimages=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # ARROWIMAGES (non inheritable): replace the drawn arrows by the
    # following images. Make sure their sizes are equal or smaller
    # than ARROWSIZE. Default: No.
    SetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGES"), cstring(value))

proc `arrowimages`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGES"), cstring(value))

proc `arrowimages=`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGES"), cstring(&"{x}"))

proc `arrowimages`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGES"), cstring(&"{x}"))

proc `arrowimages`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGES"))

# TODO unknown: dropbutton ARROWPADDING Unknown Binary
proc `arrowpadding`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ARROWPADDING"))

# TODO unknown: dropbutton ARROWSIZE Unknown Binary
proc `arrowsize`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ARROWSIZE"))

proc `backimage=`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # BACKIMAGE (non inheritable): image name to be used as
    # background. Use IupSetHandle or IupSetAttributeHandle to
    # associate an image to a name. See also IupImage.
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGE"), cast[PIhandle](handle))

proc `backimage`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGE"), cast[PIhandle](handle))

proc `backimage`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGE"))

proc `backimagehighlight=`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # BACKIMAGEHIGHLIGHT (non inheritable): background image name of
    # the element in highlight state. If it is not defined then the
    # BACKIMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `backimagehighlight`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `backimagehighlight`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEHIGHLIGHT"))

proc `backimageinactive=`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # BACKIMAGEINACTIVE (non inheritable): background image name of
    # the element when inactive. If it is not defined then the
    # BACKIMAGE is used and its colors will be replaced by a modified
    # version creating the disabled effect.
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGEINACTIVE"), cast[PIhandle](handle))

proc `backimageinactive`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGEINACTIVE"), cast[PIhandle](handle))

proc `backimageinactive`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEINACTIVE"))

proc `backimagepress=`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # BACKIMAGEPRESS (non inheritable): background image name of the
    # element in pressed state. If it is not defined then the
    # BACKIMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGEPRESS"), cast[PIhandle](handle))

proc `backimagepress`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGEPRESS"), cast[PIhandle](handle))

proc `backimagepress`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEPRESS"))

proc `backimagezoom=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # BACKIMAGEZOOM (non inheritable): if set the back image will be
    # zoomed to occupy the full background. Aspect ratio is NOT
    # preserved. Can be Yes or No. Default: No. (since 3.25)
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring(value))

proc `backimagezoom`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring(value))

proc `backimagezoom=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring((if yes: "YES" else: "NO")))

proc `backimagezoom`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring((if yes: "YES" else: "NO")))

proc `backimagezoom`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM")) == "YES"

proc `backingstore=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE")) == "YES"

proc `bgcolor=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # BGCOLOR: Background color. If text and image are not defined,
    # the button is configured to simply show a color, in this case
    # set the button size because the natural size will be very small.
    # If not defined it will use the background color of the native
    # parent.
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # BORDER (creation only): the default value is "NO". This is the
    # IupCanvas border.
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `bordercolor=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # BORDERCOLOR: color used for borders. Default: "50 150 255". This
    # is for the IupDropButton drawn border.
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(value))

proc `bordercolor`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(value))

proc `bordercolor=`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bordercolor`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bordercolor`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"))

proc `borderhlcolor=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # BORDERHLCOLOR: color used for borders when highlighted. Default
    # use BORDERCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("BORDERHLCOLOR"), cstring(value))

proc `borderhlcolor`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERHLCOLOR"), cstring(value))

proc `borderhlcolor=`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERHLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `borderhlcolor`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERHLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `borderhlcolor`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERHLCOLOR"))

proc `borderpscolor=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # BORDERPSCOLOR: color used for borders when pressed or selected.
    # Default use BORDERCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("BORDERPSCOLOR"), cstring(value))

proc `borderpscolor`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERPSCOLOR"), cstring(value))

proc `borderpscolor=`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERPSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `borderpscolor`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERPSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `borderpscolor`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERPSCOLOR"))

proc `borderwidth=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # BORDERWIDTH: line width used for borders. Default: "1". Any
    # borders can be hidden by simply setting this value to 0. This is
    # for the IupDropButton drawn border.
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(value))

proc `borderwidth`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(value))

proc `borderwidth=`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(&"{x}"))

proc `borderwidth`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(&"{x}"))

proc `borderwidth`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"))

proc `canfocus=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # CANFOCUS (creation only) (non inheritable): enables the focus
    # traversal of the control. In Windows the button will respect
    # CANFOCUS in opposite to the other controls. Default: YES.
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `cpadding=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # CPADDING: same as PADDING but using the units of the SIZE
    # attribute. It will actually set the PADDING attribute. (since
    # 3.29)
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding=`*(ih: DropButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: DropButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CPADDING"))

proc `cspacing=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # CSPACING: same as SPACING but using the units of the vertical
    # part of the SIZE attribute. It will actually set the SPACING
    # attribute. (since 3.29)
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(value))

proc `cspacing`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(value))

proc `cspacing=`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(&"{x}"))

proc `cspacing`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(&"{x}"))

proc `cspacing`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CSPACING"))

proc `cursor=`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `dragdrop=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary dropbutton
proc `dragtypes`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

# TODO unknown: dropbutton DRAWABLE Unknown Binary
proc `drawable`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWABLE"))

proc `drawbgcolor=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor=`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"))

proc `drawcolor=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor=`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"))

proc `drawdriver`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWDRIVER"))

proc `drawfont=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

proc `drawfont`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

# TODO ??? String Binary dropbutton
proc `drawfont`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"))

proc `drawlinewidth=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth=`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"))

proc `drawmakeinactive=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE")) == "YES"

proc `drawsize`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSIZE"))

proc `drawstyle=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"))

proc `drawtextalignment=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"))

proc `drawtextclip=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP")) == "YES"

proc `drawtextellipsis=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS")) == "YES"

proc `drawtextlayoutcenter=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER")) == "YES"

proc `drawtextorientation=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation=`*(ih: DropButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: DropButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"))

proc `drawtextwrap=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP")) == "YES"

# TODO unknown: dropbutton DROPCHILD Unknown Binary
proc `dropchild`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPCHILD"))

proc `dropchild_handle=`*(ih: DropButton_t, handle: User_t) {.cdecl.} =
    # DROPCHILD_HANDLE: same as DROPCHILD but directly using the
    # Ihandle* of the element.
    SetAttributeHandle(cast[PIhandle](ih), cstring("DROPCHILD_HANDLE"), cast[PIhandle](handle))

proc `dropchild_handle`*(ih: DropButton_t, handle: User_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DROPCHILD_HANDLE"), cast[PIhandle](handle))

proc `dropchild_handle`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPCHILD_HANDLE"))

proc `dropfilestarget=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

# TODO unknown: dropbutton DROPONARROW Unknown Binary
proc `droponarrow`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPONARROW"))

# TODO unknown: dropbutton DROPPOSITION Unknown Binary
proc `dropposition`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPPOSITION"))

proc `droptarget=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary dropbutton
proc `droptypes`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `dx=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx=`*(ih: DropButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: DropButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DX"))

proc `dy=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy=`*(ih: DropButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: DropButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DY"))

proc `expand=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable): The default value is "NO".
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: DropButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: DropButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `fgcolor=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # FGCOLOR: Text color. Default: the global attribute DLGFGCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

proc `first_control_handle`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FIRST_CONTROL_HANDLE"))

proc `fittobackimage=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # FITTOBACKIMAGE (non inheritable): enable the natural size to be
    # computed from the BACKIMAGE. If BACKIMAGE is not defined will be
    # ignored. Can be Yes or No. Default: No.
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring(value))

proc `fittobackimage`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring(value))

proc `fittobackimage=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring((if yes: "YES" else: "NO")))

proc `fittobackimage`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring((if yes: "YES" else: "NO")))

proc `fittobackimage`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE")) == "YES"

proc `floating=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `focusfeedback=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # FOCUSFEEDBACK (non inheritable): draw the focus feedback. Can be
    # Yes or No. Default: Yes. (since 3.26)
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring(value))

proc `focusfeedback`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring(value))

proc `focusfeedback=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring((if yes: "YES" else: "NO")))

proc `focusfeedback`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring((if yes: "YES" else: "NO")))

proc `focusfeedback`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK")) == "YES"

proc `font=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary dropbutton
proc `font`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary dropbutton
proc `fontface`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary dropbutton
proc `fontstyle`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `frontimage=`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # FRONTIMAGE (non inheritable): image name to be used as
    # foreground. The foreground image is drawn in the same position
    # as the background, but it is drawn at last. Use IupSetHandle or
    # IupSetAttributeHandle to associate an image to a name. See also
    # IupImage.
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGE"), cast[PIhandle](handle))

proc `frontimage`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGE"), cast[PIhandle](handle))

proc `frontimage`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRONTIMAGE"))

proc `frontimagehighlight=`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # FRONTIMAGEHIGHLIGHT (non inheritable): foreground image name of
    # the element in highlight state. If it is not defined then the
    # FRONTIMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `frontimagehighlight`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `frontimagehighlight`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRONTIMAGEHIGHLIGHT"))

proc `frontimageinactive=`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # FRONTIMAGEINACTIVE (non inheritable): foreground image name of
    # the element when inactive. If it is not defined then the
    # FRONTIMAGE is used and its colors will be replaced by a modified
    # version creating the disabled effect.
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGEINACTIVE"), cast[PIhandle](handle))

proc `frontimageinactive`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGEINACTIVE"), cast[PIhandle](handle))

proc `frontimageinactive`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRONTIMAGEINACTIVE"))

proc `frontimagepress=`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # FRONTIMAGEPRESS (non inheritable): foreground image name of the
    # element in pressed state. If it is not defined then the
    # FRONTIMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGEPRESS"), cast[PIhandle](handle))

proc `frontimagepress`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGEPRESS"), cast[PIhandle](handle))

proc `frontimagepress`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRONTIMAGEPRESS"))

proc `handlename=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary dropbutton
proc `handlename`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `hasfocus`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HASFOCUS")) == "YES"

proc `highlighted`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIGHLIGHTED")) == "YES"

proc `hlcolor=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # HLCOLOR: background color used to indicate a highlight state.
    # Pre-defined to "200 225 245". Can be set to NULL. If NULL
    # BGCOLOR will be used instead.
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(value))

proc `hlcolor`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(value))

proc `hlcolor=`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `hlcolor`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `hlcolor`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"))

proc `image=`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGE (non inheritable): Image name. Use IupSetHandle or
    # IupSetAttributeHandle to associate an image to a name. See also
    # IupImage.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGE"))

proc `imagehighlight=`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGEHIGHLIGHT (non inheritable): Image name of the element in
    # highlight state. If it is not defined then the IMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `imagehighlight`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `imagehighlight`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEHIGHLIGHT"))

proc `imageinactive=`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGEINACTIVE (non inheritable): Image name of the element when
    # inactive. If it is not defined then the IMAGE is used and its
    # colors will be replaced by a modified version creating the
    # disabled effect.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEINACTIVE"), cast[PIhandle](handle))

proc `imageinactive`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEINACTIVE"), cast[PIhandle](handle))

proc `imageinactive`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEINACTIVE"))

proc `imageposition=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # IMAGEPOSITION (non inheritable): Position of the image relative
    # to the text when both are displayed. Can be: LEFT, RIGHT, TOP,
    # BOTTOM. Default: LEFT.
    SetAttribute(cast[PIhandle](ih), cstring("IMAGEPOSITION"), cstring(value))

proc `imageposition`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("IMAGEPOSITION"), cstring(value))

proc `imageposition`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEPOSITION"))

proc `imagepress=`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGEPRESS (non inheritable): Image name of the element in
    # pressed state. If it is not defined then the IMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEPRESS"), cast[PIhandle](handle))

proc `imagepress`*(ih: DropButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEPRESS"), cast[PIhandle](handle))

proc `imagepress`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEPRESS"))

proc `linex=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex=`*(ih: DropButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: DropButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEX"))

proc `liney=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney=`*(ih: DropButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: DropButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEY"))

proc `maxsize=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: DropButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: DropButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: DropButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: DropButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary dropbutton
proc `name`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `next_control_handle`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NEXT_CONTROL_HANDLE"))

proc `normalizergroup=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary dropbutton
proc `normalizergroup`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary dropbutton
proc `ntheme`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `padding=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # PADDING: internal margin. Works just like the MARGIN attribute
    # of the IupHbox and IupVbox containers, but uses a different name
    # to avoid inheritance problems. Alignment does not includes the
    # padding area. Default value: "3x3". Value can be
    # DEFAULTBUTTONPADDING, so the global attribute of this name will
    # be used instead (since 3.29). The natural size will be a
    # combination of the size of the image and the title, if any, plus
    # PADDING and SPACING (if both image and title are present), and
    # plus the horizontal space occupied by the arrow.
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding=`*(ih: DropButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: DropButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PADDING"))

# TODO unknown: dropbutton PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: dropbutton PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: DropButton_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: DropButton_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `posx=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx=`*(ih: DropButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: DropButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSX"))

proc `posy=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy=`*(ih: DropButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: DropButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSY"))

proc `pressed`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PRESSED")) == "YES"

proc `propagatefocus=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # PROPAGATEFOCUS (non inheritable): enables the focus callback
    # forwarding to the next native parent with FOCUS_CB defined.
    # Default: NO.
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `pscolor=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # PSCOLOR: background color used to indicate a press state. Pre-
    # defined to "150 200 235". Can be set to NULL. If NULL BGCOLOR
    # will be used instead.
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(value))

proc `pscolor`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(value))

proc `pscolor=`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `pscolor`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `pscolor`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"))

proc `rastersize=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: DropButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: DropButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `sb_resize`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_RESIZE"))

proc `screenposition`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `scrollbar=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR")) == "YES"

proc `showborder=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # SHOWBORDER: by default borders are drawn only when the button is
    # highlighted, if SHOWBORDER=Yes borders are always show. When
    # SHOWBORDER=Yes and BGCOLOR is not defined, the actual BGCOLOR
    # will be a darker version of the background color of the native
    # parent.
    SetAttribute(cast[PIhandle](ih), cstring("SHOWBORDER"), cstring(value))

proc `showborder`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWBORDER"), cstring(value))

proc `showborder=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWBORDER"), cstring((if yes: "YES" else: "NO")))

proc `showborder`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWBORDER"), cstring((if yes: "YES" else: "NO")))

proc `showborder`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWBORDER")) == "YES"

proc `showdropdown=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # SHOWDROPDOWN (write-only): opens or closes the dropdown child.
    # Can be "YES" or "NO". Ignored if set before map.
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDROPDOWN"), cstring(value))

proc `showdropdown`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDROPDOWN"), cstring(value))

proc `showdropdown=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDROPDOWN"), cstring((if yes: "YES" else: "NO")))

proc `showdropdown`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDROPDOWN"), cstring((if yes: "YES" else: "NO")))

proc `size=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: DropButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: DropButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `spacing=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # SPACING (non inheritable): spacing between the image and the
    # text. Default: "2". The natural size will be a combination of
    # the size of the image and the title, if any, plus PADDING and
    # SPACING (if both image and title are present), and plus the
    # horizontal space occupied by the arrow.
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(value))

proc `spacing`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(value))

proc `spacing=`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(&"{x}"))

proc `spacing`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(&"{x}"))

proc `spacing`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPACING"))

proc `textalignment=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # TEXTALIGNMENT (non inheritable): Horizontal text alignment for
    # multiple lines. Can be: ALEFT, ARIGHT or ACENTER. Default:
    # ALEFT.
    SetAttribute(cast[PIhandle](ih), cstring("TEXTALIGNMENT"), cstring(value))

proc `textalignment`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTALIGNMENT"), cstring(value))

proc `textalignment`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTALIGNMENT"))

# TODO unknown: dropbutton TEXTCLIP Unknown Binary
proc `textclip`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTCLIP"))

proc `textellipsis=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # TEXTELLIPSIS (non inheritable): If the text is larger that its
    # box, an ellipsis ("...") will be placed near the last visible
    # part of the text and replace the invisible part. It will be
    # ignored when TEXTWRAP=Yes. (since 3.25)
    SetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS"), cstring(value))

proc `textellipsis`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS"), cstring(value))

proc `textellipsis=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `textellipsis`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `textellipsis`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS")) == "YES"

proc `texthlcolor=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # TEXTHLCOLOR: text color used to indicate a highlight state. If
    # not defined FGCOLOR will be used instead. (since 3.26)
    SetAttribute(cast[PIhandle](ih), cstring("TEXTHLCOLOR"), cstring(value))

proc `texthlcolor`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTHLCOLOR"), cstring(value))

proc `texthlcolor=`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTHLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `texthlcolor`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTHLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `texthlcolor`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTHLCOLOR"))

proc `textorientation=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # TEXTORIENTATION (non inheritable): text angle in degrees and
    # counterclockwise. The text size will adapt to include the
    # rotated space. (since 3.25)
    SetAttribute(cast[PIhandle](ih), cstring("TEXTORIENTATION"), cstring(value))

proc `textorientation`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTORIENTATION"), cstring(value))

proc `textorientation=`*(ih: DropButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTORIENTATION"), cstring(&"{x}"))

proc `textorientation`*(ih: DropButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTORIENTATION"), cstring(&"{x}"))

proc `textorientation`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTORIENTATION"))

proc `textpscolor=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # TEXTPSCOLOR: text color used to indicate a press state. If not
    # defined FGCOLOR will be used instead. (since 3.26)
    SetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"), cstring(value))

proc `textpscolor`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"), cstring(value))

proc `textpscolor=`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `textpscolor`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `textpscolor`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"))

proc `textwrap=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # TEXTWRAP (non inheritable): For single line texts if the text is
    # larger than its box the line will be automatically broken in
    # multiple lines. Notice that this is done internally by the
    # system, the element natural size will still use only a single
    # line. For the remaining lines to be visible the element should
    # use EXPAND=VERTICAL or set a SIZE/RASTERSIZE with enough height
    # for the wrapped lines. (since 3.25)
    SetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP"), cstring(value))

proc `textwrap`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP"), cstring(value))

proc `textwrap=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `textwrap`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `textwrap`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP")) == "YES"

proc `theme=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary dropbutton
proc `theme`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary dropbutton
proc `tip`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: DropButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary dropbutton
proc `tipicon`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary dropbutton
proc `tipmarkup`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: DropButton_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: DropButton_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `title=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # TITLE (non inheritable): Label's text. The '\n' character is
    # accepted for line change.
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary dropbutton
proc `title`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

proc `touch=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOUCH")) == "YES"

proc `usersize=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: DropButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: DropButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `visiblecolumns=`*(ih: DropButton_t, value: string) {.cdecl.} =
    # VISIBLECOLUMNS: Defines the number of visible columns for the
    # Natural Size, this means that will act also as minimum number of
    # visible columns. It uses a wider character size then the one
    # used for the SIZE attribute so strings will fit better without
    # the need of extra columns. Padding will be around the visible
    # columns.
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"), cstring(value))

proc `visiblecolumns`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"), cstring(value))

proc `visiblecolumns=`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"), cstring(&"{x}"))

proc `visiblecolumns`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"), cstring(&"{x}"))

proc `visiblecolumns`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"))

proc `wheeldropfocus=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS")) == "YES"

proc `wid`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

proc `xautohide=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE")) == "YES"

proc `xdisplay`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XDISPLAY"))

# TODO unknown: dropbutton XFONTID Unknown Binary
proc `xfontid`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `xhidden`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XHIDDEN")) == "YES"

proc `xmax=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax=`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMAX"))

proc `xmin=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin=`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMIN"))

# TODO unknown: dropbutton XWINDOW Unknown Binary
proc `xwindow`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `yautohide=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide=`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: DropButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE")) == "YES"

proc `yhidden`*(ih: DropButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YHIDDEN")) == "YES"

proc `ymax=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax=`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMAX"))

proc `ymin=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin=`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: DropButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: DropButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMIN"))

proc `zorder=`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: DropButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: DropButton_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: DropButton_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `destroy_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropdown_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle, state: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPDOWN_CB: Action generated right before the drop child is
    # shown or hidden. This callback is also called when SHOWDROPDOWN
    # is set. int function (Ihandle *ih, int state); [in
    # C]ih:dropdown_cb(state: boolean) -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("DROPDOWN_CB"), cast[Icallback](cb))

proc `dropdown_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle, state: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDOWN_CB"), cast[Icallback](cb))

proc `dropdown_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDOWN_CB")))

proc `dropfiles_cb=`*(ih: DropButton_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: DropButton_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `dropshow_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPSHOW_CB: Action generated right after the drop child is
    # shown or hidden. This callback is also called when SHOWDROPDOWN
    # is set. int function (Ihandle *ih, int state); [in
    # C]ih:dropdown_cb(state: boolean) -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("DROPSHOW_CB"), cast[Icallback](cb))

proc `dropshow_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPSHOW_CB"), cast[Icallback](cb))

proc `dropshow_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPSHOW_CB")))

proc `enterwindow_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `flat_action=`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # FLAT_ACTION: Action generated when the button 1 (usually left)
    # is selected. This callback is called only after the mouse is
    # released and when it is released inside the button area. Called
    # only when DROPONARROW=Yes. int function(Ihandle* ih); [in
    # C]ih:action() -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("FLAT_ACTION"), cast[Icallback](cb))

proc `flat_action`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_ACTION"), cast[Icallback](cb))

proc `flat_action`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_ACTION")))

proc `flat_button_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_BUTTON_CB"), cast[Icallback](cb))

proc `flat_button_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_BUTTON_CB"), cast[Icallback](cb))

proc `flat_button_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_BUTTON_CB")))

proc `flat_enterwindow_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_ENTERWINDOW_CB"), cast[Icallback](cb))

proc `flat_enterwindow_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_ENTERWINDOW_CB"), cast[Icallback](cb))

proc `flat_enterwindow_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_ENTERWINDOW_CB")))

proc `flat_focus_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_FOCUS_CB"), cast[Icallback](cb))

proc `flat_focus_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_FOCUS_CB"), cast[Icallback](cb))

proc `flat_focus_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_FOCUS_CB")))

proc `flat_leavewindow_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `flat_leavewindow_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `flat_leavewindow_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_LEAVEWINDOW_CB")))

proc `flat_motion_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_MOTION_CB"), cast[Icallback](cb))

proc `flat_motion_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_MOTION_CB"), cast[Icallback](cb))

proc `flat_motion_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_MOTION_CB")))

proc `focus_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    # The drop dialog is configured with no decorations and it is not
    # resizable, only the FOCUS_CB and K_ESC callbacks are set. But
    # this can be changed by the application. It is a regular
    # IupDialog. To obtain the drop button handle from the handle of
    # the dialog get the "DROPBUTTON" attribute handle from the
    # dialog, using IupGetAttributeHandle. After performing some
    # operation on the drop child, use SHOWDROPDOWN=NO on the drop
    # button, you may also update its TITLE, just like a regular
    # IupList with DROPDOWN=Yes, but this will not be performed
    # automatically by the drop button. For example, set the ACTION
    # callback on the IupList used as drop child: static int
    # list_cb(Ihandle* list, char *text, int item, int state) { if
    # (state == 1) { Ihandle* ih =
    # IupGetAttributeHandle(IupGetDialog(list), "DROPBUTTON");
    # IupSetAttribute(ih, "SHOWDROPDOWN", "No");
    # IupSetStrAttribute(ih, "TITLE", text); } return IUP_DEFAULT; }
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `keypress_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    # KEYPRESS_CB KEYPRESS_CB Action generated when a key is pressed
    # or released. If the key is pressed and held several calls will
    # occur. It is called after the callback K_ANY is processed.
    # Callback int function(Ihandle *ih, int c, int press); [in C]
    # ih:keypress_cb(c, press: number) -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. c:
    # identifier of typed key. Please refer to the Keyboard Codes
    # table for a list of possible values. press: 1 is the user
    # pressed the key or 0 otherwise. Returns: If IUP_IGNORE is
    # returned the key is ignored by the system. IUP_CLOSE will be
    # processed. Affects IupCanvas
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB")))

proc `killfocus_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: DropButton_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: DropButton_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `postmessage_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `scroll_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    # SCROLL_CB SCROLL_CB Called when some manipulation is made to the
    # scrollbar. The canvas is automatically redrawn only if this
    # callback is NOT defined. (GTK 2.8) Also the POSX and POSY values
    # will not be correctly updated for older GTK versions. In Ubuntu,
    # when liboverlay-scrollbar is enabled (the new tiny auto-hide
    # scrollbar) only the IUP_SBPOSV and IUP_SBPOSH codes are used.
    # Callback int function(Ihandle *ih, int op, float posx, float
    # posy); [in C] ih:scroll_cb(op, posx, posy: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. op: indicates the operation performed on the
    # scrollbar. If the manipulation was made on the vertical
    # scrollbar, it can have the following values: IUP_SBUP - line up
    # IUP_SBDN - line down IUP_SBPGUP - page up IUP_SBPGDN - page down
    # IUP_SBPOSV - vertical positioning IUP_SBDRAGV - vertical drag If
    # it was on the horizontal scrollbar, the following values are
    # valid: IUP_SBLEFT - column left IUP_SBRIGHT - column right
    # IUP_SBPGLEFT - page left IUP_SBPGRIGHT - page right IUP_SBPOSH -
    # horizontal positioning IUP_SBDRAGH - horizontal drag posx, posy:
    # the same as the ACTION canvas callback (corresponding to the
    # values of attributes POSX and POSY). Notes IUP_SBDRAGH and
    # IUP_SBDRAGV are not supported in GTK. During drag IUP_SBPOSH and
    # IUP_SBPOSV are used. In Windows, after a drag when mouse is
    # released IUP_SBPOSH or IUP_SBPOSV are called. Affects IupCanvas,
    # IupGLCanvas, SCROLLBAR
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SCROLL_CB")))

proc `unmap_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `wheel_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # WHEEL_CB WHEEL_CB Action generated when the mouse wheel is
    # rotated. If this callback is not defined the wheel will
    # automatically scroll the canvas in the vertical direction by
    # some lines, the SCROLL_CB callback if defined will be called
    # with the IUP_SBDRAGV operation. Callback int function(Ihandle
    # *ih, float delta, int x, int y, char *status); [in C]
    # ih:wheel_cb(delta, x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. delta: the amount the wheel was rotated in notches.
    # x, y: position in the canvas where the event has occurred, in
    # pixels. status: status of mouse buttons and certain keyboard
    # keys at the moment the event was generated. The same macros used
    # for BUTTON_CB can be used for this status. Notes In Motif and
    # GTK delta is always 1 or -1. In Windows is some situations delta
    # can reach the value of two. In the future with more precise
    # wheels this increment can be changed. Affects IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WHEEL_CB")))

proc `wom_cb=`*(ih: DropButton_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # WOM_CB WOM_CB Action generated when an audio device receives an
    # event. [Windows Only] Callback int function(Ihandle *ih, int
    # state); [in C] ih:wom_cb(state: number) -> (ret: number) [in
    # Lua] ih: identifies the element that activated the event. state:
    # can be opening=1, done=0, or closing=-1. Notes This callback is
    # used to syncronize video playback with audio. It is sent when
    # the audio device: Message Description opening is opened by using
    # the waveOutOpen function. done is finished with a data block
    # sent by using the waveOutWrite function. closing is closed by
    # using the waveOutClose function. You must use the HWND attribute
    # when calling waveOutOpen in the dwCallback parameter and set
    # fdwOpen to CALLBACK_WINDOW. Affects IupDialog, IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: DropButton_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: DropButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WOM_CB")))

proc Expander*(child: IUPhandle_t): Expander_t {.cdecl.} =
    # Creates a void container that can interactively show or hide its
    # child. It does not have a native representation, but it contains
    # also several elements to implement the bar handler.
    return Expander_t(niupc.Expander(cast[PIhandle](child)))

proc `active=`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Expander_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Expander_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Expander_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `animation=`*(ih: Expander_t, value: string) {.cdecl.} =
    # ANIMATION (non inheritable): enable animation during open/close.
    # Works only for BARPOSITION=TOP and does not works for AUTOSHOW.
    # Also the child must be a native container like IupTabs,
    # IupFrame, IupBackgroundBox, or IupScrollBox, or it will not work
    # accordantly. Values can be SLIDE (child controls slide down),
    # CURTAIN (child controls appears as if a curtain is being pulled)
    # or NO. Default: NO. ((since 3.14)
    SetAttribute(cast[PIhandle](ih), cstring("ANIMATION"), cstring(value))

proc `animation`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ANIMATION"), cstring(value))

proc `animation`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ANIMATION"))

# TODO unknown: expander AUTOSHOW Unknown Binary
proc `autoshow`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("AUTOSHOW"))

proc `backcolor=`*(ih: Expander_t, value: string) {.cdecl.} =
    # BACKCOLOR (non inheritable): background color of the bar
    # handler. If not defined it will use the background color of the
    # native parent. (since 3.9)
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(value))

proc `backcolor`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(value))

proc `backcolor=`*(ih: Expander_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `backcolor`*(ih: Expander_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `backcolor`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"))

# TODO unknown: expander BARPOSITION Unknown Binary
proc `barposition`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BARPOSITION"))

proc `barsize=`*(ih: Expander_t, value: string) {.cdecl.} =
    # BARSIZE (non inheritable): controls the size of the bar handler.
    # Default: the height or width that fits all its internal elements
    # according to BARPOSITION.
    SetAttribute(cast[PIhandle](ih), cstring("BARSIZE"), cstring(value))

proc `barsize`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BARSIZE"), cstring(value))

proc `barsize=`*(ih: Expander_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BARSIZE"), cstring(&"{x}"))

proc `barsize`*(ih: Expander_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BARSIZE"), cstring(&"{x}"))

proc `barsize`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BARSIZE"))

proc `canfocus=`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Expander_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Expander_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Expander_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `clientoffset`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `expand=`*(ih: Expander_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable): the default value is "YES".
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Expander_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Expander_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `extrabuttons=`*(ih: Expander_t, value: string) {.cdecl.} =
    # EXTRABUTTONS (non inheritable) (creation only): sets the number
    # of extra image buttons at right when BARPOSITION=TOP. The
    # maximum number of buttons is 3. See the EXTRABUTTON_CB callback.
    # Default: 0. (since 3.11)
    SetAttribute(cast[PIhandle](ih), cstring("EXTRABUTTONS"), cstring(value))

proc `extrabuttons`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXTRABUTTONS"), cstring(value))

proc `extrabuttons=`*(ih: Expander_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXTRABUTTONS"), cstring(&"{x}"))

proc `extrabuttons`*(ih: Expander_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXTRABUTTONS"), cstring(&"{x}"))

proc `extrabuttons`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXTRABUTTONS"))

proc `floating=`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Expander_t, value: string) {.cdecl.} =
    # FONT, SIZE, RASTERSIZE, CLIENTSIZE, CLIENTOFFSET, POSITION,
    # MINSIZE, MAXSIZE, THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary expander
proc `font`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary expander
proc `fontface`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Expander_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Expander_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary expander
proc `fontstyle`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `forecolor=`*(ih: Expander_t, value: string) {.cdecl.} =
    # FORECOLOR (non inheritable): title text color. Default: the
    # global attribute DLGFGCOLOR. (since 3.9)
    SetAttribute(cast[PIhandle](ih), cstring("FORECOLOR"), cstring(value))

proc `forecolor`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FORECOLOR"), cstring(value))

proc `forecolor=`*(ih: Expander_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FORECOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `forecolor`*(ih: Expander_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FORECOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `forecolor`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FORECOLOR"))

proc `frame=`*(ih: Expander_t, value: string) {.cdecl.} =
    # FRAME (non inheritable): enables the frame line around the bar
    # area. Default: No. (since 3.23)
    SetAttribute(cast[PIhandle](ih), cstring("FRAME"), cstring(value))

proc `frame`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FRAME"), cstring(value))

proc `frame=`*(ih: Expander_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FRAME"), cstring((if yes: "YES" else: "NO")))

proc `frame`*(ih: Expander_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FRAME"), cstring((if yes: "YES" else: "NO")))

proc `frame`*(ih: Expander_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRAME")) == "YES"

proc `framecolor=`*(ih: Expander_t, value: string) {.cdecl.} =
    # FRAMECOLOR (non inheritable): frame line color. Default: the
    # global attribute DLGFGCOLOR. (since 3.23)
    SetAttribute(cast[PIhandle](ih), cstring("FRAMECOLOR"), cstring(value))

proc `framecolor`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FRAMECOLOR"), cstring(value))

proc `framecolor=`*(ih: Expander_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FRAMECOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `framecolor`*(ih: Expander_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FRAMECOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `framecolor`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRAMECOLOR"))

proc `frametime=`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FRAMETIME"), cstring(value))

proc `frametime`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FRAMETIME"), cstring(value))

proc `frametime=`*(ih: Expander_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FRAMETIME"), cstring(&"{x}"))

proc `frametime`*(ih: Expander_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FRAMETIME"), cstring(&"{x}"))

proc `frametime`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRAMETIME"))

proc `framewidth=`*(ih: Expander_t, value: string) {.cdecl.} =
    # FRAMEWIDTH (non inheritable): frame line width. Default: 1.
    # (since 3.23)
    SetAttribute(cast[PIhandle](ih), cstring("FRAMEWIDTH"), cstring(value))

proc `framewidth`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FRAMEWIDTH"), cstring(value))

proc `framewidth=`*(ih: Expander_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FRAMEWIDTH"), cstring(&"{x}"))

proc `framewidth`*(ih: Expander_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FRAMEWIDTH"), cstring(&"{x}"))

proc `framewidth`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRAMEWIDTH"))

proc `handlename=`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary expander
proc `handlename`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `highcolor=`*(ih: Expander_t, value: string) {.cdecl.} =
    # HIGHCOLOR (non inheritable): title text color when highlighted.
    # Works only when TITLEEXPAND=Yes. Defaults to the FORECOLOR if
    # not defined. (since 3.14)
    SetAttribute(cast[PIhandle](ih), cstring("HIGHCOLOR"), cstring(value))

proc `highcolor`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIGHCOLOR"), cstring(value))

proc `highcolor=`*(ih: Expander_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIGHCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `highcolor`*(ih: Expander_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIGHCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `highcolor`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIGHCOLOR"))

proc `image=`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGE (non inheritable): image name to replace the arrow image
    # by a custom image when STATE=CLOSE. Works only when
    # BARPOSITION=TOP. Use IupSetHandle or IupSetAttributeHandle to
    # associate an image to a name. See also IupImage. (since 3.11)
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGE"))

proc `imageextra1=`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEEXTRA1"), cast[PIhandle](handle))

proc `imageextra1`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEEXTRA1"), cast[PIhandle](handle))

proc `imageextra1`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEEXTRA1"))

proc `imageextra2=`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEEXTRA2"), cast[PIhandle](handle))

proc `imageextra2`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEEXTRA2"), cast[PIhandle](handle))

proc `imageextra2`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEEXTRA2"))

proc `imageextra3=`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEEXTRA3"), cast[PIhandle](handle))

proc `imageextra3`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEEXTRA3"), cast[PIhandle](handle))

proc `imageextra3`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEEXTRA3"))

proc `imageextrahighlight1=`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEEXTRAHIGHLIGHT1"), cast[PIhandle](handle))

proc `imageextrahighlight1`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEEXTRAHIGHLIGHT1"), cast[PIhandle](handle))

proc `imageextrahighlight1`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEEXTRAHIGHLIGHT1"))

proc `imageextrahighlight2=`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEEXTRAHIGHLIGHT2"), cast[PIhandle](handle))

proc `imageextrahighlight2`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEEXTRAHIGHLIGHT2"), cast[PIhandle](handle))

proc `imageextrahighlight2`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEEXTRAHIGHLIGHT2"))

proc `imageextrahighlight3=`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEEXTRAHIGHLIGHT3"), cast[PIhandle](handle))

proc `imageextrahighlight3`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEEXTRAHIGHLIGHT3"), cast[PIhandle](handle))

proc `imageextrahighlight3`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEEXTRAHIGHLIGHT3"))

proc `imageextrapress1=`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEEXTRAPRESS1"), cast[PIhandle](handle))

proc `imageextrapress1`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEEXTRAPRESS1"), cast[PIhandle](handle))

proc `imageextrapress1`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEEXTRAPRESS1"))

proc `imageextrapress2=`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEEXTRAPRESS2"), cast[PIhandle](handle))

proc `imageextrapress2`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEEXTRAPRESS2"), cast[PIhandle](handle))

proc `imageextrapress2`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEEXTRAPRESS2"))

proc `imageextrapress3=`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEEXTRAPRESS3"), cast[PIhandle](handle))

proc `imageextrapress3`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEEXTRAPRESS3"), cast[PIhandle](handle))

proc `imageextrapress3`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEEXTRAPRESS3"))

proc `imagehighlight=`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `imagehighlight`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `imagehighlight`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEHIGHLIGHT"))

proc `imageopen=`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGEOPEN: image name used when STATE=OPEN. IMAGEHIGHLIGHT:
    # image name used when mouse is over the bar handler and
    # STATE=CLOSE.IMAGEOPENHIGHLIGHT: image name used when mouse is
    # over the bar handler and STATE=OPEN.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEOPEN"), cast[PIhandle](handle))

proc `imageopen`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEOPEN"), cast[PIhandle](handle))

proc `imageopen`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEOPEN"))

proc `imageopenhighlight=`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEOPENHIGHLIGHT"), cast[PIhandle](handle))

proc `imageopenhighlight`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEOPENHIGHLIGHT"), cast[PIhandle](handle))

proc `imageopenhighlight`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEOPENHIGHLIGHT"))

proc `maxsize=`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Expander_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Expander_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Expander_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Expander_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary expander
proc `name`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary expander
proc `normalizergroup`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary expander
proc `ntheme`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: expander NUMFRAMES Unknown Binary
proc `numframes`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NUMFRAMES"))

# TODO unknown: expander OPENCOLOR Unknown Binary
proc `opencolor`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("OPENCOLOR"))

# TODO unknown: expander PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: expander PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Expander_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Expander_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Expander_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Expander_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Expander_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Expander_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Expander_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `size=`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Expander_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Expander_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `state=`*(ih: Expander_t, value: string) {.cdecl.} =
    # STATE (non inheritable): Show or hide the container elements.
    # Possible values: "OPEN" (expanded) or "CLOSE" (collapsed).
    # Default: OPEN. Setting this attribute will automatically change
    # the layout of the entire dialog so the child can be recomposed.
    SetAttribute(cast[PIhandle](ih), cstring("STATE"), cstring(value))

proc `state`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STATE"), cstring(value))

proc `state`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("STATE"))

# TODO unknown: expander STATEREFRESH Unknown Binary
proc `staterefresh`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("STATEREFRESH"))

proc `theme=`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary expander
proc `theme`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `title=`*(ih: Expander_t, value: string) {.cdecl.} =
    # TITLE (non inheritable): title text, shown in the bar handler
    # near the expand/collapse button. When set it will reset
    # TITLEIMAGE. Shown only when BARPOSITION=TOP. When the TITLE is
    # defined and BARPOSITION=TOP then the expand/collapse button is
    # left aligned. In all other situations the expand/collapse button
    # is centered.
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary expander
proc `title`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

# TODO unknown: expander TITLEEXPAND Unknown Binary
proc `titleexpand`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLEEXPAND"))

proc `titleimage=`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # TITLEIMAGE (non inheritable): title image, shown in the bar
    # handler near the expand/collapse button. When set it will reset
    # TITLE (image and text title are mutually exclusive). Shown only
    # when BARPOSITION=TOP. (since 3.14)
    SetAttributeHandle(cast[PIhandle](ih), cstring("TITLEIMAGE"), cast[PIhandle](handle))

proc `titleimage`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("TITLEIMAGE"), cast[PIhandle](handle))

proc `titleimage`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLEIMAGE"))

proc `titleimagehighlight=`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("TITLEIMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `titleimagehighlight`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("TITLEIMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `titleimagehighlight`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLEIMAGEHIGHLIGHT"))

proc `titleimageopen=`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # TITLEIMAGEOPEN: image name used when STATE=OPEN.
    # TITLEIMAGEHIGHLIGHT: image name used when mouse is over the
    # title image and STATE=CLOSE.TITLEIMAGEOPENHIGHLIGHT: image name
    # used when mouse is over the title image and STATE=OPEN.
    SetAttributeHandle(cast[PIhandle](ih), cstring("TITLEIMAGEOPEN"), cast[PIhandle](handle))

proc `titleimageopen`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("TITLEIMAGEOPEN"), cast[PIhandle](handle))

proc `titleimageopen`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLEIMAGEOPEN"))

proc `titleimageopenhighlight=`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("TITLEIMAGEOPENHIGHLIGHT"), cast[PIhandle](handle))

proc `titleimageopenhighlight`*(ih: Expander_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("TITLEIMAGEOPENHIGHLIGHT"), cast[PIhandle](handle))

proc `titleimageopenhighlight`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLEIMAGEOPENHIGHLIGHT"))

proc `usersize=`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Expander_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Expander_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Expander_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Expander_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Expander_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Expander_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

# TODO unknown: expander XFONTID Unknown Binary
proc `xfontid`*(ih: Expander_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `action=`*(ih: Expander_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: Expander_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: Expander_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `destroy_cb=`*(ih: Expander_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Expander_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Expander_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `extrabutton_cb=`*(ih: Expander_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    # EXTRABUTTON_CB: Action generated when any mouse button is
    # pressed or released. (since 3.11) int function(Ihandle* ih, int
    # button, int pressed); [in C] ih:extrabutton_cb(button, pressed:
    # number) -> (ret: number) [in Lua] ih: identifies the element
    # that activated the event. button: identifies the extra button.
    # can be 1, 2 or 3. (this is not the same as BUTTON_CB)pressed:
    # indicates the state of the button: 0 - mouse button was
    # released; 1 - mouse button was pressed.
    SetCallback(cast[PIhandle](ih), cstring("EXTRABUTTON_CB"), cast[Icallback](cb))

proc `extrabutton_cb`*(ih: Expander_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("EXTRABUTTON_CB"), cast[Icallback](cb))

proc `extrabutton_cb`*(ih: Expander_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("EXTRABUTTON_CB")))

proc `ldestroy_cb=`*(ih: Expander_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Expander_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Expander_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: Expander_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Expander_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Expander_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `openclose_cb=`*(ih: Expander_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # OPENCLOSE_CB: Action generated before the expander state is
    # interactively changed. (Since 3.11) int function(Ihandle* ih,
    # int state); [in C]ih:openclose_cb(state: number) -> (ret:
    # number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("OPENCLOSE_CB"), cast[Icallback](cb))

proc `openclose_cb`*(ih: Expander_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("OPENCLOSE_CB"), cast[Icallback](cb))

proc `openclose_cb`*(ih: Expander_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("OPENCLOSE_CB")))

proc `postmessage_cb=`*(ih: Expander_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Expander_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Expander_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: Expander_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Expander_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Expander_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc FileDlg*(): FileDlg_t {.cdecl.} =
    # Creates the File Dialog element. It is a predefined dialog for
    # selecting files or a directory. The dialog can be shown with the
    # IupPopup function only.
    return FileDlg_t(niupc.FileDlg())

proc `active=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `activewindow`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVEWINDOW")) == "YES"

proc `allownew=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    # ALLOWNEW: Indicates if non-existent file names are accepted. If
    # equals "NO" and the user specifies a non-existing file, an alert
    # dialog is shown. Default: if the dialog is of type "OPEN",
    # default is "NO"; if the dialog is of type "SAVE", default is
    # "YES". Not used when DIALOGTYPE=DIR.
    SetAttribute(cast[PIhandle](ih), cstring("ALLOWNEW"), cstring(value))

proc `allownew`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALLOWNEW"), cstring(value))

proc `allownew=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALLOWNEW"), cstring((if yes: "YES" else: "NO")))

proc `allownew`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALLOWNEW"), cstring((if yes: "YES" else: "NO")))

proc `allownew`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ALLOWNEW")) == "YES"

proc `background=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(value))

proc `background`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(value))

proc `background=`*(ih: FileDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(&"{red} {green} {blue} {alpha}"))

proc `background`*(ih: FileDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(&"{red} {green} {blue} {alpha}"))

proc `background`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"))

proc `bgcolor=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: FileDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FileDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `bordersize`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERSIZE"))

proc `bringfront=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring(value))

proc `bringfront`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring(value))

proc `bringfront=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring((if yes: "YES" else: "NO")))

proc `bringfront`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring((if yes: "YES" else: "NO")))

proc `bringfront`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT")) == "YES"

proc `canfocus=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `childoffset=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset=`*(ih: FileDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: FileDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"))

proc `clientoffset`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(value))

proc `clientsize`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(value))

proc `clientsize=`*(ih: FileDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(&"{width}x{height}"))

proc `clientsize`*(ih: FileDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(&"{width}x{height}"))

proc `clientsize`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `composited=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring(value))

proc `composited`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring(value))

proc `composited=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring((if yes: "YES" else: "NO")))

proc `composited`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring((if yes: "YES" else: "NO")))

proc `composited`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("COMPOSITED")) == "YES"

proc `control=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring(value))

proc `control`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring(value))

proc `control=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring((if yes: "YES" else: "NO")))

proc `control`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring((if yes: "YES" else: "NO")))

proc `control`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CONTROL")) == "YES"

proc `cursor=`*(ih: FileDlg_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FileDlg_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `customframe=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring(value))

proc `customframe`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring(value))

proc `customframe=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring((if yes: "YES" else: "NO")))

proc `customframe`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring((if yes: "YES" else: "NO")))

proc `customframe`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME")) == "YES"

proc `customframesimulate=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring(value))

proc `customframesimulate`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring(value))

proc `customframesimulate=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring((if yes: "YES" else: "NO")))

proc `customframesimulate`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring((if yes: "YES" else: "NO")))

proc `customframesimulate`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE")) == "YES"

proc `defaultenter=`*(ih: FileDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTENTER"), cast[PIhandle](handle))

proc `defaultenter`*(ih: FileDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTENTER"), cast[PIhandle](handle))

proc `defaultenter`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DEFAULTENTER"))

proc `defaultesc=`*(ih: FileDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTESC"), cast[PIhandle](handle))

proc `defaultesc`*(ih: FileDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTESC"), cast[PIhandle](handle))

proc `defaultesc`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DEFAULTESC"))

proc `dialogframe=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring(value))

proc `dialogframe`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring(value))

proc `dialogframe=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring((if yes: "YES" else: "NO")))

proc `dialogframe`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring((if yes: "YES" else: "NO")))

proc `dialogframe`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME")) == "YES"

proc `dialoghint=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring(value))

proc `dialoghint`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring(value))

proc `dialoghint=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring((if yes: "YES" else: "NO")))

proc `dialoghint`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring((if yes: "YES" else: "NO")))

proc `dialoghint`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT")) == "YES"

proc `dialogtype=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    # DIALOGTYPE: Type of dialog (Open, Save or Directory). Can have
    # values "OPEN", "SAVE" or "DIR". Default: "OPEN". In Windows,
    # when DIALOGTYPE=DIR the dialog shown is not the same dialog for
    # OPEN and SAVE, this new dialog does not have the Help button
    # neither filters. Also this new dialog needs CoInitializeEx with
    # COINIT_APARTMENTTHREADED (done in IupOpen), if the COM library
    # was initialized with COINIT_MULTITHREADED prior to IupOpen then
    # the new dialog will have limited functionality. In Motif or GTK
    # the dialog is the same, but it only allows the user to select a
    # directory.
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGTYPE"), cstring(value))

proc `dialogtype`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGTYPE"), cstring(value))

proc `dialogtype`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DIALOGTYPE"))

proc `directory=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    # DIRECTORY: Initial directory. When consulted after the dialog is
    # closed and the user pressed the OK button, it will contain the
    # directory of the selected file. When set the last separator does
    # not need to be specified, but when get the returned value will
    # always contains the last separator. In Motif or GTK, if not
    # defined, the dialog opens in the current directory. In Windows,
    # if not defined and the application has used the dialog in the
    # past, the path most recently used is selected as the initial
    # directory. However, if an application is not run for a long
    # time, its saved selected path is discarded. Also if not defined
    # and the current directory contains any files of the specified
    # filter types, the initial directory is the current directory.
    # Otherwise, the initial directory is the "My Documents" directory
    # of the current user. Otherwise, the initial directory is the
    # Desktop folder. In Windows, the FILE and the DIRECTORY
    # attributes also accept strings containing "/" as path
    # separators, but the VALUE attribute will always return strings
    # using the "\" character.
    SetAttribute(cast[PIhandle](ih), cstring("DIRECTORY"), cstring(value))

proc `directory`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIRECTORY"), cstring(value))

# TODO ??? String Binary filedlg
proc `directory`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DIRECTORY"))

proc `dragdrop=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary filedlg
proc `dragtypes`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

proc `dropfilestarget=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary filedlg
proc `droptypes`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `expand=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: FileDlg_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FileDlg_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `extdefault=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    # EXTDEFAULT: default extension to be used if selected file does
    # not have an extension. The inspected extension will consider to
    # have the same number of characters of the default extension. It
    # must NOT include the period ".". (since 3.18)
    SetAttribute(cast[PIhandle](ih), cstring("EXTDEFAULT"), cstring(value))

proc `extdefault`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXTDEFAULT"), cstring(value))

# TODO ??? String Binary filedlg
proc `extdefault`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXTDEFAULT"))

proc `extfilter=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    # EXTFILTER [Windows and GTK Only]: Defines several file filters.
    # It has priority over FILTERINFO and FILTER. Must be a text with
    # the format "FilterInfo1|Filter1|FilterInfo2|Filter2|...". The
    # list ends with character '|'. Example: "Text
    # files|*.txt;*.doc|Image files|*.gif;*.jpg;*.bmp|". In GTK there
    # is no way how to overwrite the filters, so it is recommended to
    # always add a less restrictive filter to the filter list, for
    # example "All Files|*.*".
    SetAttribute(cast[PIhandle](ih), cstring("EXTFILTER"), cstring(value))

proc `extfilter`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXTFILTER"), cstring(value))

# TODO ??? String Binary filedlg
proc `extfilter`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXTFILTER"))

# TODO unknown: filedlg FILE Unknown Binary
proc `file`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FILE"))

proc `fileexist`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FILEEXIST"))

proc `filter=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    # FILTER: String containing a list of file filters separated by
    # ';' without spaces. Example: "*.C;*.LED;test.*". In Motif only
    # the first filter is used.
    SetAttribute(cast[PIhandle](ih), cstring("FILTER"), cstring(value))

proc `filter`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FILTER"), cstring(value))

# TODO ??? String Binary filedlg
proc `filter`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FILTER"))

# TODO unknown: filedlg FILTERINFO Unknown Binary
proc `filterinfo`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FILTERINFO"))

# TODO unknown: filedlg FILTERUSED Unknown Binary
proc `filterused`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FILTERUSED"))

proc `floating=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary filedlg
proc `font`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary filedlg
proc `fontface`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: FileDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FileDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary filedlg
proc `fontstyle`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `fullscreen=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring(value))

proc `fullscreen`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring(value))

proc `fullscreen=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring((if yes: "YES" else: "NO")))

proc `fullscreen`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring((if yes: "YES" else: "NO")))

proc `handlename=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary filedlg
proc `handlename`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `helpbutton=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring(value))

proc `helpbutton`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring(value))

proc `helpbutton=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring((if yes: "YES" else: "NO")))

proc `helpbutton`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring((if yes: "YES" else: "NO")))

proc `helpbutton`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON")) == "YES"

proc `hidetaskbar=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring(value))

proc `hidetaskbar`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring(value))

proc `hidetaskbar=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring((if yes: "YES" else: "NO")))

proc `hidetaskbar`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring((if yes: "YES" else: "NO")))

proc `hidetaskbar`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR")) == "YES"

proc `hidetitlebar=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETITLEBAR"), cstring(value))

proc `hidetitlebar`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETITLEBAR"), cstring(value))

# TODO ??? String Binary filedlg
proc `hidetitlebar`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIDETITLEBAR"))

proc `icon=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ICON"), cstring(value))

proc `icon`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ICON"), cstring(value))

# TODO ??? String Binary filedlg
proc `icon`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ICON"))

proc `maxbox=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring(value))

proc `maxbox`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring(value))

proc `maxbox=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring((if yes: "YES" else: "NO")))

proc `maxbox`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring((if yes: "YES" else: "NO")))

proc `maxbox`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXBOX")) == "YES"

proc `maximized`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXIMIZED")) == "YES"

proc `maxsize=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: FileDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FileDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `mdichild=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring(value))

proc `mdichild`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring(value))

proc `mdichild=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring((if yes: "YES" else: "NO")))

proc `mdichild`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring((if yes: "YES" else: "NO")))

proc `mdichild`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDICHILD")) == "YES"

proc `mdiclient=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring(value))

proc `mdiclient`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring(value))

proc `mdiclient=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring((if yes: "YES" else: "NO")))

proc `mdiclient`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring((if yes: "YES" else: "NO")))

proc `mdiclient`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDICLIENT")) == "YES"

proc `mdiframe=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring(value))

proc `mdiframe`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring(value))

proc `mdiframe=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring((if yes: "YES" else: "NO")))

proc `mdiframe`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring((if yes: "YES" else: "NO")))

proc `mdiframe`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDIFRAME")) == "YES"

proc `mdimenu=`*(ih: FileDlg_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MDIMENU"), cast[PIhandle](handle))

proc `mdimenu`*(ih: FileDlg_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MDIMENU"), cast[PIhandle](handle))

proc `mdimenu`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDIMENU"))

proc `menu=`*(ih: FileDlg_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MENU"), cast[PIhandle](handle))

proc `menu`*(ih: FileDlg_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MENU"), cast[PIhandle](handle))

proc `menu`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MENU"))

proc `menubox=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring(value))

proc `menubox`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring(value))

proc `menubox=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring((if yes: "YES" else: "NO")))

proc `menubox`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring((if yes: "YES" else: "NO")))

proc `menubox`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MENUBOX")) == "YES"

proc `minbox=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring(value))

proc `minbox`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring(value))

proc `minbox=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring((if yes: "YES" else: "NO")))

proc `minbox`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring((if yes: "YES" else: "NO")))

proc `minbox`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINBOX")) == "YES"

proc `minsize=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: FileDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FileDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `modal`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MODAL")) == "YES"

# TODO unknown: filedlg MULTIPLEFILES Unknown Binary
proc `multiplefiles`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MULTIPLEFILES"))

# TODO unknown: filedlg MULTIVALUEPATH Unknown Binary
proc `multivaluepath`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MULTIVALUEPATH"))

proc `nactive=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring(value))

proc `nactive`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring(value))

proc `nactive=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `nactive`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `nactive`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NACTIVE")) == "YES"

proc `name=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary filedlg
proc `name`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `nativeparent=`*(ih: FileDlg_t, handle: User_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("NATIVEPARENT"), cast[PIhandle](handle))

proc `nativeparent`*(ih: FileDlg_t, handle: User_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("NATIVEPARENT"), cast[PIhandle](handle))

proc `nativeparent`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATIVEPARENT"))

proc `naturalsize`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `nochangedir=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    # NOCHANGEDIR: Indicates if the current working directory must be
    # restored after the user navigation. Default: "YES".
    SetAttribute(cast[PIhandle](ih), cstring("NOCHANGEDIR"), cstring(value))

proc `nochangedir`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOCHANGEDIR"), cstring(value))

proc `nochangedir=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOCHANGEDIR"), cstring((if yes: "YES" else: "NO")))

proc `nochangedir`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOCHANGEDIR"), cstring((if yes: "YES" else: "NO")))

proc `nochangedir`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NOCHANGEDIR")) == "YES"

proc `noflush=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring(value))

proc `noflush`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring(value))

proc `noflush=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring((if yes: "YES" else: "NO")))

proc `noflush`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring((if yes: "YES" else: "NO")))

proc `noflush`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NOFLUSH")) == "YES"

proc `nooverwriteprompt=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    # NOOVERWRITEPROMPT: do not prompt to overwrite an existent file
    # when in "SAVE" dialog. Default is "NO", i.e. prompt before
    # overwrite. (GTK 2.8)
    SetAttribute(cast[PIhandle](ih), cstring("NOOVERWRITEPROMPT"), cstring(value))

proc `nooverwriteprompt`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOOVERWRITEPROMPT"), cstring(value))

proc `nooverwriteprompt=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOOVERWRITEPROMPT"), cstring((if yes: "YES" else: "NO")))

proc `nooverwriteprompt`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOOVERWRITEPROMPT"), cstring((if yes: "YES" else: "NO")))

proc `nooverwriteprompt`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NOOVERWRITEPROMPT")) == "YES"

proc `normalizergroup=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary filedlg
proc `normalizergroup`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary filedlg
proc `ntheme`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `opacity=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(value))

proc `opacity`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(value))

proc `opacity=`*(ih: FileDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(&"{x}"))

proc `opacity`*(ih: FileDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(&"{x}"))

proc `opacity`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("OPACITY"))

proc `opacityimage=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITYIMAGE"), cstring(value))

proc `opacityimage`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITYIMAGE"), cstring(value))

# TODO ??? String Binary filedlg
proc `opacityimage`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("OPACITYIMAGE"))

# TODO unknown: filedlg PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: filedlg PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `parentdialog=`*(ih: FileDlg_t, handle: IUPhandle_t) {.cdecl.} =
    # PARENTDIALOG: Makes the dialog be treated as a child of the
    # specified dialog.
    SetAttributeHandle(cast[PIhandle](ih), cstring("PARENTDIALOG"), cast[PIhandle](handle))

proc `parentdialog`*(ih: FileDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("PARENTDIALOG"), cast[PIhandle](handle))

proc `parentdialog`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PARENTDIALOG"))

proc `placement=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PLACEMENT"), cstring(value))

proc `placement`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PLACEMENT"), cstring(value))

proc `placement`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PLACEMENT"))

proc `position=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: FileDlg_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FileDlg_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `previewdc`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PREVIEWDC"))

proc `previewheight`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PREVIEWHEIGHT"))

proc `previewwidth`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PREVIEWWIDTH"))

proc `propagatefocus=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: FileDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FileDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `resize=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(value))

proc `resize`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(value))

proc `resize=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring((if yes: "YES" else: "NO")))

proc `resize`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring((if yes: "YES" else: "NO")))

proc `resize`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RESIZE")) == "YES"

proc `saveunder=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring(value))

proc `saveunder`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring(value))

proc `saveunder=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring((if yes: "YES" else: "NO")))

proc `saveunder`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring((if yes: "YES" else: "NO")))

proc `saveunder`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER")) == "YES"

proc `screenposition`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `shapeimage=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHAPEIMAGE"), cstring(value))

proc `shapeimage`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHAPEIMAGE"), cstring(value))

# TODO ??? String Binary filedlg
proc `shapeimage`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHAPEIMAGE"))

# TODO unknown: filedlg SHOWHIDDEN Unknown Binary
proc `showhidden`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWHIDDEN"))

proc `shownofocus=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring(value))

proc `shownofocus`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring(value))

proc `shownofocus=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `shownofocus`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `shownofocus`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS")) == "YES"

proc `showpreview=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    # SHOWPREVIEW: A preview area is shown inside the file dialog. Can
    # have values "YES" or "NO". Default: "NO". In Windows, you must
    # link with the "iup.rc" resource file so the preview area can be
    # enabled (not necessary if using "iup.dll"). Valid only if the
    # FILE_CB callback is defined, use it to retrieve the file name
    # and the necessary attributes to paint the preview area. (in
    # Motif since 3.0) Read only attributes that are valid inside the
    # FILE_CB callback when status="PAINT": PREVIEWDC: Returns the
    # Device Context (HDC in Windows and GC in UNIX) PREVIEWWIDTH and
    # PREVIEWHEIGHT: Returns the width and the height of the client
    # rectangle for the preview area. Also the attributes WID, HWND,
    # XWINDOW and XDISPLAY are valid and are relative to the preview
    # area. If the attribute PREVIEWGLCANVAS is defined then it is
    # used as the name of an existent IupGLCanvas control to be mapped
    # internally to the preview canvas. Notice that this is not a
    # fully implemented IupGLCanvas that inherits from IupCanvas. This
    # does the minimum necessary so you can use IupGLCanvas auxiliary
    # functions for the preview canvas and call OpenGL functions. No
    # IupCanvas attributes or callbacks are available. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("SHOWPREVIEW"), cstring(value))

proc `showpreview`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWPREVIEW"), cstring(value))

# TODO ??? String Binary filedlg
proc `showpreview`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWPREVIEW"))

proc `shrink=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring(value))

proc `shrink`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring(value))

proc `shrink=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring((if yes: "YES" else: "NO")))

proc `shrink`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring((if yes: "YES" else: "NO")))

proc `shrink`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHRINK")) == "YES"

proc `simulatemodal=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring(value))

proc `simulatemodal`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring(value))

proc `simulatemodal=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring((if yes: "YES" else: "NO")))

proc `simulatemodal`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring((if yes: "YES" else: "NO")))

proc `size=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: FileDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FileDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size=`*(ih: FileDlg_t, width: string, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FileDlg_t, width: string, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size=`*(ih: FileDlg_t, width: int, height:string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FileDlg_t, width: int, height:string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `startfocus=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STARTFOCUS"), cstring(value))

proc `startfocus`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STARTFOCUS"), cstring(value))

# TODO ??? String Binary filedlg
proc `startfocus`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("STARTFOCUS"))

proc `status`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("STATUS"))

proc `theme=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary filedlg
proc `theme`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary filedlg
proc `tip`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: FileDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FileDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: FileDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FileDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: FileDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FileDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary filedlg
proc `tipicon`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary filedlg
proc `tipmarkup`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: FileDlg_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FileDlg_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `title=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    # TITLE: Dialog's title.
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary filedlg
proc `title`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

proc `toolbox=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring(value))

proc `toolbox`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring(value))

proc `toolbox=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring((if yes: "YES" else: "NO")))

proc `toolbox`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring((if yes: "YES" else: "NO")))

proc `toolbox`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOOLBOX")) == "YES"

proc `topmost=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring(value))

proc `topmost`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring(value))

proc `topmost=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring((if yes: "YES" else: "NO")))

proc `topmost`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring((if yes: "YES" else: "NO")))

proc `tray=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring(value))

proc `tray`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring(value))

proc `tray=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring((if yes: "YES" else: "NO")))

proc `tray`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring((if yes: "YES" else: "NO")))

proc `tray`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAY")) == "YES"

proc `trayimage=`*(ih: FileDlg_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("TRAYIMAGE"), cast[PIhandle](handle))

proc `trayimage`*(ih: FileDlg_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("TRAYIMAGE"), cast[PIhandle](handle))

proc `trayimage`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAYIMAGE"))

proc `traytip=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIP"), cstring(value))

proc `traytip`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIP"), cstring(value))

# TODO ??? String Binary filedlg
proc `traytip`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAYTIP"))

proc `traytipmarkup=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIPMARKUP"), cstring(value))

proc `traytipmarkup`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIPMARKUP"), cstring(value))

# TODO ??? String Binary filedlg
proc `traytipmarkup`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAYTIPMARKUP"))

proc `usersize=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: FileDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FileDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `visible=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FileDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FileDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

# TODO unknown: filedlg XFONTID Unknown Binary
proc `xfontid`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

# TODO unknown: filedlg XWINDOW Unknown Binary
proc `xwindow`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: FileDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `zorder=`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: FileDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `close_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # CLOSE_CB CLOSE_CB Called just before a dialog is closed when the
    # user clicks the close button of the title bar or an equivalent
    # action. Callback int function(Ihandle *ih); [in C] ih:close_cb()
    # -> (ret: number) [in Lua] ih: identifies the element that
    # activated the event. Returns: if IUP_IGNORE, it prevents the
    # dialog from being closed. If you destroy the dialog in this
    # callback, you must return IUP_IGNORE. IUP_CLOSE will be
    # processed. Affects IupDialog
    SetCallback(cast[PIhandle](ih), cstring("CLOSE_CB"), cast[Icallback](cb))

proc `close_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("CLOSE_CB"), cast[Icallback](cb))

proc `close_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("CLOSE_CB")))

proc `destroy_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: FileDlg_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FileDlg_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `file_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cstring): cint {.cdecl.}) {.cdecl.} =
    # When saving a file, the overwrite check is done before the
    # FILE_CB callback is called with status=OK. If the application
    # wants to add an extension to the file name inside the FILE_CB
    # callback when status=OK, then it must manually check if the file
    # with the extension exits and asks the user if the file should be
    # replaced, if not then the callback can set the FILE attribute
    # and returns IUP_CONTINUE, so the file dialog will remain open
    # and the user will have an opportunity to change the file name
    # now that it contains the extension.
    SetCallback(cast[PIhandle](ih), cstring("FILE_CB"), cast[Icallback](cb))

proc `file_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FILE_CB"), cast[Icallback](cb))

proc `file_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FILE_CB")))

proc `focus_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `killfocus_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: FileDlg_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FileDlg_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `show_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle, state: cint): cint {.cdecl.}) {.cdecl.} =
    # SHOW_CB SHOW_CB Called right after the dialog is showed, hidden,
    # maximized, minimized or restored from minimized/maximized. This
    # callback is called when those actions were performed by the user
    # or programmatically by the application. Callback int
    # function(Ihandle *ih, int state); [in C] ih:show_cb(state:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. state: indicates which of the
    # following situations generated the event: IUP_HIDE (since 3.0)
    # IUP_SHOW IUP_RESTORE (was minimized or maximized) IUP_MINIMIZE
    # IUP_MAXIMIZE (since 3.0) (not received in Motif when activated
    # from the maximize button) Returns: IUP_CLOSE will be processed.
    # Affects IupDialog
    SetCallback(cast[PIhandle](ih), cstring("SHOW_CB"), cast[Icallback](cb))

proc `show_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle, state: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SHOW_CB"), cast[Icallback](cb))

proc `show_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SHOW_CB")))

proc `trayclick_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle, but, pressed, dclick: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("TRAYCLICK_CB"), cast[Icallback](cb))

proc `trayclick_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle, but, pressed, dclick: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("TRAYCLICK_CB"), cast[Icallback](cb))

proc `trayclick_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("TRAYCLICK_CB")))

proc `unmap_cb=`*(ih: FileDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FileDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FileDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc Fill*(): Fill_t {.cdecl.} =
    # Creates void element, which dynamically occupies empty spaces
    # always trying to expand itself. Its parent should be an IupHbox,
    # an IupVbox or a IupGridBox, or else this type of expansion will
    # not work. If an EXPAND is set on at least one of the other
    # children of the box, then the fill expansion is ignored. It does
    # not have a native representation.
    return Fill_t(niupc.Fill())

proc `active=`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Fill_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Fill_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Fill_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `canfocus=`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Fill_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Fill_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Fill_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `expand=`*(ih: Fill_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable)(read-only): If User size is not
    # defined, then when inside a IupHbox/IupGridBox EXPAND is
    # HORIZONTAL, when inside a IupVbox EXPAND is VERTICAL. If User
    # size is defined then EXPAND is NO.
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Fill_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Fill_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Fill_t, value: string) {.cdecl.} =
    # FONT, POSITION, MINSIZE, MAXSIZE, THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary fill
proc `font`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary fill
proc `fontface`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Fill_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Fill_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary fill
proc `fontstyle`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary fill
proc `handlename`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `maxsize=`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Fill_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Fill_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Fill_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Fill_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary fill
proc `name`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary fill
proc `normalizergroup`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary fill
proc `ntheme`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: fill PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: fill PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Fill_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Fill_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Fill_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Fill_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Fill_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Fill_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Fill_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `size=`*(ih: Fill_t, value: string) {.cdecl.} =
    # SIZE / RASTERSIZE (non inheritable): Defines the width, if
    # inside a IupHbox, or the height, if it is inside a IupVbox. The
    # standard format "wxh" can also be used, but width will be
    # ignored if inside a IupVbox and height will be ignored if inside
    # a IupHbox (since 3.3). When consulted behaves as the standard
    # SIZE/RASTERSIZE attributes.
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Fill_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Fill_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary fill
proc `theme`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `usersize=`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Fill_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Fill_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Fill_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Fill_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Fill_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Fill_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

# TODO unknown: fill XFONTID Unknown Binary
proc `xfontid`*(ih: Fill_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `destroy_cb=`*(ih: Fill_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Fill_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Fill_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `ldestroy_cb=`*(ih: Fill_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Fill_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Fill_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: Fill_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Fill_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Fill_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: Fill_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Fill_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Fill_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: Fill_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Fill_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Fill_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc FlatButton*(title: string): FlatButton_t {.cdecl.} =
    # Creates an interface element that is a button, but it does not
    # have native decorations. When selected, this element activates a
    # function in the application. Its visual presentation can contain
    # a text and/or an image. It behaves just like an IupButton, but
    # since it is not a native control it has more flexibility for
    # additional options. It can also behave like an IupToggle
    # (without the checkmark). It inherits from IupCanvas.
    return FlatButton_t(niupc.FlatButton(cstring(title)))

proc `active=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # ACTIVE, FONT, EXPAND, SCREENPOSITION, POSITION, MINSIZE,
    # MAXSIZE, WID, TIP, SIZE, RASTERSIZE, ZORDER, VISIBLE, THEME:
    # also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `alignment=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # ALIGNMENT (non inheritable): horizontal and vertical alignment
    # of the set image+text. Possible values: "ALEFT", "ACENTER" and
    # "ARIGHT", combined to "ATOP", "ACENTER" and "ABOTTOM". Default:
    # "ACENTER:ACENTER". Partial values are also accepted, like
    # "ARIGHT" or ":ATOP", the other value will be obtained from the
    # default value. Alignment does not includes the padding area.
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"))

proc `backimage=`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # BACKIMAGE (non inheritable): image name to be used as
    # background. Use IupSetHandle or IupSetAttributeHandle to
    # associate an image to a name. See also IupImage.
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGE"), cast[PIhandle](handle))

proc `backimage`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGE"), cast[PIhandle](handle))

proc `backimage`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGE"))

proc `backimagehighlight=`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # BACKIMAGEHIGHLIGHT (non inheritable): background image name of
    # the element in highlight state. If it is not defined then the
    # BACKIMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `backimagehighlight`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `backimagehighlight`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEHIGHLIGHT"))

proc `backimageinactive=`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # BACKIMAGEINACTIVE (non inheritable): background image name of
    # the element when inactive. If it is not defined then the
    # BACKIMAGE is used and its colors will be replaced by a modified
    # version creating the disabled effect.
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGEINACTIVE"), cast[PIhandle](handle))

proc `backimageinactive`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGEINACTIVE"), cast[PIhandle](handle))

proc `backimageinactive`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEINACTIVE"))

proc `backimagepress=`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # BACKIMAGEPRESS (non inheritable): background image name of the
    # element in pressed state. If it is not defined then the
    # BACKIMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGEPRESS"), cast[PIhandle](handle))

proc `backimagepress`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGEPRESS"), cast[PIhandle](handle))

proc `backimagepress`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEPRESS"))

proc `backimagezoom=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # BACKIMAGEZOOM (non inheritable): if set the back image will be
    # zoomed to occupy the full background. Aspect ratio is NOT
    # preserved. Can be Yes or No. Default: No. (since 3.25)
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring(value))

proc `backimagezoom`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring(value))

proc `backimagezoom=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring((if yes: "YES" else: "NO")))

proc `backimagezoom`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring((if yes: "YES" else: "NO")))

proc `backimagezoom`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM")) == "YES"

proc `backingstore=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE")) == "YES"

proc `bgcolor=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # BGCOLOR: Background color. If text and image are not defined,
    # the button is configured to simply show a color, in this case
    # set the button size because the natural size will be very small.
    # If not defined it will use the background color of the native
    # parent.
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # BORDER (creation only): the default value is "NO". This is the
    # IupCanvas border.
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `bordercolor=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # BORDERCOLOR: color used for borders. Default: "50 150 255". This
    # is for the IupFlatButton drawn border.
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(value))

proc `bordercolor`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(value))

proc `bordercolor=`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bordercolor`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bordercolor`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"))

proc `borderhlcolor=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # BORDERHLCOLOR: color used for borders when highlighted. Default
    # use BORDERCOLOR. (since 3.19)
    SetAttribute(cast[PIhandle](ih), cstring("BORDERHLCOLOR"), cstring(value))

proc `borderhlcolor`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERHLCOLOR"), cstring(value))

proc `borderhlcolor=`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERHLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `borderhlcolor`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERHLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `borderhlcolor`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERHLCOLOR"))

proc `borderpscolor=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # BORDERPSCOLOR: color used for borders when pressed or selected.
    # Default use BORDERCOLOR. (since 3.19)
    SetAttribute(cast[PIhandle](ih), cstring("BORDERPSCOLOR"), cstring(value))

proc `borderpscolor`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERPSCOLOR"), cstring(value))

proc `borderpscolor=`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERPSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `borderpscolor`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERPSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `borderpscolor`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERPSCOLOR"))

proc `borderwidth=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # BORDERWIDTH: line width used for borders. Default: "1". Any
    # borders can be hidden by simply setting this value to 0. This is
    # for the IupFlatButton drawn border.
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(value))

proc `borderwidth`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(value))

proc `borderwidth=`*(ih: FlatButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(&"{x}"))

proc `borderwidth`*(ih: FlatButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(&"{x}"))

proc `borderwidth`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"))

proc `canfocus=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # CANFOCUS (creation only) (non inheritable): enables the focus
    # traversal of the control. Default: YES.
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `cpadding=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # CPADDING: same as PADDING but using the units of the SIZE
    # attribute. It will actually set the PADDING attribute. (since
    # 3.29)
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding=`*(ih: FlatButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: FlatButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CPADDING"))

proc `cspacing=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # CSPACING: same as SPACING but using the units of the vertical
    # part of the SIZE attribute. It will actually set the SPACING
    # attribute. (since 3.29)
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(value))

proc `cspacing`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(value))

proc `cspacing=`*(ih: FlatButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(&"{x}"))

proc `cspacing`*(ih: FlatButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(&"{x}"))

proc `cspacing`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CSPACING"))

proc `cursor=`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `dragdrop=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary flatbutton
proc `dragtypes`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

# TODO unknown: flatbutton DRAWABLE Unknown Binary
proc `drawable`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWABLE"))

proc `drawbgcolor=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor=`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"))

proc `drawcolor=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor=`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"))

proc `drawdriver`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWDRIVER"))

proc `drawfont=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

proc `drawfont`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

# TODO ??? String Binary flatbutton
proc `drawfont`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"))

proc `drawlinewidth=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth=`*(ih: FlatButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: FlatButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"))

proc `drawmakeinactive=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE")) == "YES"

proc `drawsize`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSIZE"))

proc `drawstyle=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"))

proc `drawtextalignment=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"))

proc `drawtextclip=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP")) == "YES"

proc `drawtextellipsis=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS")) == "YES"

proc `drawtextlayoutcenter=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER")) == "YES"

proc `drawtextorientation=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation=`*(ih: FlatButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: FlatButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"))

proc `drawtextwrap=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP")) == "YES"

proc `dropfilestarget=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary flatbutton
proc `droptypes`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `dx=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx=`*(ih: FlatButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: FlatButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DX"))

proc `dy=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy=`*(ih: FlatButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: FlatButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DY"))

proc `expand=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable): The default value is "NO".
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: FlatButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FlatButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `fgcolor=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # FGCOLOR: Text color. Default: the global attribute DLGFGCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

proc `fittobackimage=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # FITTOBACKIMAGE (non inheritable): enable the natural size to be
    # computed from the BACKIMAGE. If BACKIMAGE is not defined will be
    # ignored. Can be Yes or No. Default: No.
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring(value))

proc `fittobackimage`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring(value))

proc `fittobackimage=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring((if yes: "YES" else: "NO")))

proc `fittobackimage`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring((if yes: "YES" else: "NO")))

proc `fittobackimage`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE")) == "YES"

proc `floating=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `focusfeedback=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # FOCUSFEEDBACK (non inheritable): draw the focus feedback. Can be
    # Yes or No. Default: Yes. (since 3.26)
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring(value))

proc `focusfeedback`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring(value))

proc `focusfeedback=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring((if yes: "YES" else: "NO")))

proc `focusfeedback`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring((if yes: "YES" else: "NO")))

proc `focusfeedback`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK")) == "YES"

proc `font=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary flatbutton
proc `font`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary flatbutton
proc `fontface`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: FlatButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FlatButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary flatbutton
proc `fontstyle`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `frontimage=`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # FRONTIMAGE (non inheritable): image name to be used as
    # foreground. The foreground image is drawn in the same position
    # as the background, but it is drawn at last. Use IupSetHandle or
    # IupSetAttributeHandle to associate an image to a name. See also
    # IupImage.
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGE"), cast[PIhandle](handle))

proc `frontimage`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGE"), cast[PIhandle](handle))

proc `frontimage`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRONTIMAGE"))

proc `frontimagehighlight=`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # FRONTIMAGEHIGHLIGHT (non inheritable): foreground image name of
    # the element in highlight state. If it is not defined then the
    # FRONTIMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `frontimagehighlight`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `frontimagehighlight`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRONTIMAGEHIGHLIGHT"))

proc `frontimageinactive=`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # FRONTIMAGEINACTIVE (non inheritable): foreground image name of
    # the element when inactive. If it is not defined then the
    # FRONTIMAGE is used and its colors will be replaced by a modified
    # version creating the disabled effect.
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGEINACTIVE"), cast[PIhandle](handle))

proc `frontimageinactive`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGEINACTIVE"), cast[PIhandle](handle))

proc `frontimageinactive`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRONTIMAGEINACTIVE"))

proc `frontimagepress=`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # FRONTIMAGEPRESS (non inheritable): foreground image name of the
    # element in pressed state. If it is not defined then the
    # FRONTIMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGEPRESS"), cast[PIhandle](handle))

proc `frontimagepress`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGEPRESS"), cast[PIhandle](handle))

proc `frontimagepress`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRONTIMAGEPRESS"))

proc `handlename=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary flatbutton
proc `handlename`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `hasfocus`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HASFOCUS")) == "YES"

proc `highlighted`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIGHLIGHTED")) == "YES"

proc `hlcolor=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # HLCOLOR: background color used to indicate a highlight state.
    # Pre-defined to "200 225 245". Can be set to NULL. If NULL
    # BGCOLOR will be used instead.
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(value))

proc `hlcolor`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(value))

proc `hlcolor=`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `hlcolor`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `hlcolor`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"))

proc `ignoreradio=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # IGNORERADIO (non inheritable): when set the toggle will not
    # behave as a radio when inside an IupRadio hierarchy. (since
    # 3.21)
    SetAttribute(cast[PIhandle](ih), cstring("IGNORERADIO"), cstring(value))

proc `ignoreradio`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("IGNORERADIO"), cstring(value))

proc `ignoreradio=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("IGNORERADIO"), cstring((if yes: "YES" else: "NO")))

proc `ignoreradio`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("IGNORERADIO"), cstring((if yes: "YES" else: "NO")))

proc `ignoreradio`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IGNORERADIO")) == "YES"

proc `image=`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGE (non inheritable): Image name. Use IupSetHandle or
    # IupSetAttributeHandle to associate an image to a name. See also
    # IupImage.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGE"))

proc `imagehighlight=`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGEHIGHLIGHT (non inheritable): Image name of the element in
    # highlight state. If it is not defined then the IMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `imagehighlight`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `imagehighlight`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEHIGHLIGHT"))

proc `imageinactive=`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGEINACTIVE (non inheritable): Image name of the element when
    # inactive. If it is not defined then the IMAGE is used and its
    # colors will be replaced by a modified version creating the
    # disabled effect. Finally notice that the name of the secondary
    # image attributes are different (for instance IMINACTIVE is
    # IMAGEINACTIVE, IMPRESS is IMAGEPRESS, and so on). To define a
    # button that only shows a color, do the same as in IupButton and
    # don't define TITLE nor IMAGE, but instead of BGCOLOR use FGCOLOR
    # to set the color of the button.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEINACTIVE"), cast[PIhandle](handle))

proc `imageinactive`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEINACTIVE"), cast[PIhandle](handle))

proc `imageinactive`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEINACTIVE"))

proc `imageposition=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # IMAGEPOSITION (non inheritable): Position of the image relative
    # to the text when both are displayed. Can be: LEFT, RIGHT, TOP,
    # BOTTOM. Default: LEFT.
    SetAttribute(cast[PIhandle](ih), cstring("IMAGEPOSITION"), cstring(value))

proc `imageposition`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("IMAGEPOSITION"), cstring(value))

proc `imageposition`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEPOSITION"))

proc `imagepress=`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGEPRESS (non inheritable): Image name of the element in
    # pressed state. If it is not defined then the IMAGE is used.
    # Finally notice that the name of the secondary image attributes
    # are different (for instance IMINACTIVE is IMAGEINACTIVE, IMPRESS
    # is IMAGEPRESS, and so on). To define a button that only shows a
    # color, do the same as in IupButton and don't define TITLE nor
    # IMAGE, but instead of BGCOLOR use FGCOLOR to set the color of
    # the button.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEPRESS"), cast[PIhandle](handle))

proc `imagepress`*(ih: FlatButton_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEPRESS"), cast[PIhandle](handle))

proc `imagepress`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEPRESS"))

proc `linex=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex=`*(ih: FlatButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: FlatButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEX"))

proc `liney=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney=`*(ih: FlatButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: FlatButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEY"))

proc `maxsize=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: FlatButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FlatButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: FlatButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FlatButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary flatbutton
proc `name`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary flatbutton
proc `normalizergroup`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary flatbutton
proc `ntheme`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `padding=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # PADDING: internal margin. Works just like the MARGIN attribute
    # of the IupHbox and IupVbox containers, but uses a different name
    # to avoid inheritance problems. Alignment does not includes the
    # padding area. Default value: "0x0". Value can be
    # DEFAULTBUTTONPADDING, so the global attribute of this name will
    # be used instead (since 3.29). The natural size will be a
    # combination of the size of the image and the title, if any, plus
    # PADDING and SPACING (if both image and title are present).
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding=`*(ih: FlatButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: FlatButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PADDING"))

# TODO unknown: flatbutton PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: flatbutton PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: FlatButton_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FlatButton_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `posx=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx=`*(ih: FlatButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: FlatButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSX"))

proc `posy=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy=`*(ih: FlatButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: FlatButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSY"))

proc `pressed`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PRESSED")) == "YES"

proc `propagatefocus=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # PROPAGATEFOCUS (non inheritable): enables the focus callback
    # forwarding to the next native parent with FOCUS_CB defined.
    # Default: NO. (since 3.23)
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `pscolor=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # PSCOLOR: background color used to indicate a press state. Pre-
    # defined to "150 200 235". Can be set to NULL. If NULL BGCOLOR
    # will be used instead.
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(value))

proc `pscolor`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(value))

proc `pscolor=`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `pscolor`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `pscolor`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"))

proc `radio`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RADIO")) == "YES"

proc `rastersize=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: FlatButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FlatButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `sb_resize`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_RESIZE"))

proc `screenposition`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `scrollbar=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR")) == "YES"

proc `showborder=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # SHOWBORDER: by default borders are drawn only when the button is
    # highlighted, if SHOWBORDER=Yes borders are always show. When
    # SHOWBORDER=Yes and BGCOLOR is not defined, the actual BGCOLOR
    # will be a darker version of the background color of the native
    # parent. (since 3.25)
    SetAttribute(cast[PIhandle](ih), cstring("SHOWBORDER"), cstring(value))

proc `showborder`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWBORDER"), cstring(value))

proc `showborder=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWBORDER"), cstring((if yes: "YES" else: "NO")))

proc `showborder`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWBORDER"), cstring((if yes: "YES" else: "NO")))

proc `showborder`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWBORDER")) == "YES"

proc `size=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: FlatButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FlatButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `spacing=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # SPACING (non inheritable): spacing between the image and the
    # text. Default: "2". The natural size will be a combination of
    # the size of the image and the title, if any, plus PADDING and
    # SPACING (if both image and title are present).
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(value))

proc `spacing`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(value))

proc `spacing=`*(ih: FlatButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(&"{x}"))

proc `spacing`*(ih: FlatButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(&"{x}"))

proc `spacing`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPACING"))

proc `textalignment=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # TEXTALIGNMENT (non inheritable): Horizontal text alignment for
    # multiple lines. Can be: ALEFT, ARIGHT or ACENTER. Default:
    # ALEFT. (since 3.22)
    SetAttribute(cast[PIhandle](ih), cstring("TEXTALIGNMENT"), cstring(value))

proc `textalignment`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTALIGNMENT"), cstring(value))

proc `textalignment`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTALIGNMENT"))

# TODO unknown: flatbutton TEXTCLIP Unknown Binary
proc `textclip`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTCLIP"))

proc `textellipsis=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # TEXTELLIPSIS (non inheritable): If the text is larger that its
    # box, an ellipsis ("...") will be placed near the last visible
    # part of the text and replace the invisible part. It will be
    # ignored when TEXTWRAP=Yes. (since 3.25)
    SetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS"), cstring(value))

proc `textellipsis`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS"), cstring(value))

proc `textellipsis=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `textellipsis`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `textellipsis`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS")) == "YES"

proc `texthlcolor=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # TEXTHLCOLOR: text color used to indicate a highlight state. If
    # not defined FGCOLOR will be used instead. (since 3.26)
    SetAttribute(cast[PIhandle](ih), cstring("TEXTHLCOLOR"), cstring(value))

proc `texthlcolor`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTHLCOLOR"), cstring(value))

proc `texthlcolor=`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTHLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `texthlcolor`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTHLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `texthlcolor`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTHLCOLOR"))

proc `textorientation=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # TEXTORIENTATION (non inheritable): text angle in degrees and
    # counterclockwise. The text size will adapt to include the
    # rotated space. (since 3.25)
    SetAttribute(cast[PIhandle](ih), cstring("TEXTORIENTATION"), cstring(value))

proc `textorientation`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTORIENTATION"), cstring(value))

proc `textorientation=`*(ih: FlatButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTORIENTATION"), cstring(&"{x}"))

proc `textorientation`*(ih: FlatButton_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTORIENTATION"), cstring(&"{x}"))

proc `textorientation`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTORIENTATION"))

proc `textpscolor=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # TEXTPSCOLOR: text color used to indicate a press state. If not
    # defined FGCOLOR will be used instead. (since 3.26)
    SetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"), cstring(value))

proc `textpscolor`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"), cstring(value))

proc `textpscolor=`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `textpscolor`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `textpscolor`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"))

proc `textwrap=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # TEXTWRAP (non inheritable): For single line texts if the text is
    # larger than its box the line will be automatically broken in
    # multiple lines. Notice that this is done internally by the
    # system, the element natural size will still use only a single
    # line. For the remaining lines to be visible the element should
    # use EXPAND=VERTICAL or set a SIZE/RASTERSIZE with enough height
    # for the wrapped lines. (since 3.25)
    SetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP"), cstring(value))

proc `textwrap`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP"), cstring(value))

proc `textwrap=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `textwrap`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `textwrap`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP")) == "YES"

proc `theme=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary flatbutton
proc `theme`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary flatbutton
proc `tip`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: FlatButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FlatButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FlatButton_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary flatbutton
proc `tipicon`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary flatbutton
proc `tipmarkup`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: FlatButton_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FlatButton_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `title=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # TITLE (non inheritable): Label's text. The '\n' character is
    # accepted for line change.
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary flatbutton
proc `title`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

# TODO unknown: flatbutton TOGGLE Unknown Binary
proc `toggle`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOGGLE"))

proc `touch=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOUCH")) == "YES"

proc `usersize=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: FlatButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FlatButton_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    # VALUE (non inheritable): Toggle's state. Values can be "ON",
    # "OFF" or "TOGGLE". Default: "OFF". The TOGGLE option will invert
    # the current state. Valid only when TOGGLE=Yes. Can only be set
    # to ON for a toggle inside a radio, it will automatically set to
    # OFF the previous toggle that was ON.
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

# TODO ??? String Binary flatbutton
proc `value`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `visible=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wheeldropfocus=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS")) == "YES"

proc `wid`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

proc `xautohide=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE")) == "YES"

proc `xdisplay`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XDISPLAY"))

# TODO unknown: flatbutton XFONTID Unknown Binary
proc `xfontid`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `xhidden`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XHIDDEN")) == "YES"

proc `xmax=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax=`*(ih: FlatButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: FlatButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMAX"))

proc `xmin=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin=`*(ih: FlatButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: FlatButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMIN"))

# TODO unknown: flatbutton XWINDOW Unknown Binary
proc `xwindow`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `yautohide=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide=`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: FlatButton_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE")) == "YES"

proc `yhidden`*(ih: FlatButton_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YHIDDEN")) == "YES"

proc `ymax=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax=`*(ih: FlatButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: FlatButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMAX"))

proc `ymin=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin=`*(ih: FlatButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: FlatButton_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: FlatButton_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMIN"))

proc `zorder=`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: FlatButton_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: FlatButton_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: FlatButton_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `destroy_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: FlatButton_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FlatButton_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `flat_action=`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # FLAT_ACTION: Action generated when the button 1 (usually left)
    # is selected. This callback is called only after the mouse is
    # released and when it is released inside the button area. int
    # function(Ihandle* ih); [in C]ih:action() -> (ret: number) [in
    # Lua]
    SetCallback(cast[PIhandle](ih), cstring("FLAT_ACTION"), cast[Icallback](cb))

proc `flat_action`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_ACTION"), cast[Icallback](cb))

proc `flat_action`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_ACTION")))

proc `flat_button_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_BUTTON_CB"), cast[Icallback](cb))

proc `flat_button_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_BUTTON_CB"), cast[Icallback](cb))

proc `flat_button_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_BUTTON_CB")))

proc `flat_enterwindow_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_ENTERWINDOW_CB"), cast[Icallback](cb))

proc `flat_enterwindow_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_ENTERWINDOW_CB"), cast[Icallback](cb))

proc `flat_enterwindow_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_ENTERWINDOW_CB")))

proc `flat_focus_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_FOCUS_CB"), cast[Icallback](cb))

proc `flat_focus_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_FOCUS_CB"), cast[Icallback](cb))

proc `flat_focus_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_FOCUS_CB")))

proc `flat_leavewindow_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `flat_leavewindow_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `flat_leavewindow_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_LEAVEWINDOW_CB")))

proc `flat_motion_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_MOTION_CB"), cast[Icallback](cb))

proc `flat_motion_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_MOTION_CB"), cast[Icallback](cb))

proc `flat_motion_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_MOTION_CB")))

proc `focus_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `keypress_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    # KEYPRESS_CB KEYPRESS_CB Action generated when a key is pressed
    # or released. If the key is pressed and held several calls will
    # occur. It is called after the callback K_ANY is processed.
    # Callback int function(Ihandle *ih, int c, int press); [in C]
    # ih:keypress_cb(c, press: number) -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. c:
    # identifier of typed key. Please refer to the Keyboard Codes
    # table for a list of possible values. press: 1 is the user
    # pressed the key or 0 otherwise. Returns: If IUP_IGNORE is
    # returned the key is ignored by the system. IUP_CLOSE will be
    # processed. Affects IupCanvas
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB")))

proc `killfocus_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: FlatButton_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FlatButton_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `postmessage_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `scroll_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    # SCROLL_CB SCROLL_CB Called when some manipulation is made to the
    # scrollbar. The canvas is automatically redrawn only if this
    # callback is NOT defined. (GTK 2.8) Also the POSX and POSY values
    # will not be correctly updated for older GTK versions. In Ubuntu,
    # when liboverlay-scrollbar is enabled (the new tiny auto-hide
    # scrollbar) only the IUP_SBPOSV and IUP_SBPOSH codes are used.
    # Callback int function(Ihandle *ih, int op, float posx, float
    # posy); [in C] ih:scroll_cb(op, posx, posy: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. op: indicates the operation performed on the
    # scrollbar. If the manipulation was made on the vertical
    # scrollbar, it can have the following values: IUP_SBUP - line up
    # IUP_SBDN - line down IUP_SBPGUP - page up IUP_SBPGDN - page down
    # IUP_SBPOSV - vertical positioning IUP_SBDRAGV - vertical drag If
    # it was on the horizontal scrollbar, the following values are
    # valid: IUP_SBLEFT - column left IUP_SBRIGHT - column right
    # IUP_SBPGLEFT - page left IUP_SBPGRIGHT - page right IUP_SBPOSH -
    # horizontal positioning IUP_SBDRAGH - horizontal drag posx, posy:
    # the same as the ACTION canvas callback (corresponding to the
    # values of attributes POSX and POSY). Notes IUP_SBDRAGH and
    # IUP_SBDRAGV are not supported in GTK. During drag IUP_SBPOSH and
    # IUP_SBPOSV are used. In Windows, after a drag when mouse is
    # released IUP_SBPOSH or IUP_SBPOSV are called. Affects IupCanvas,
    # IupGLCanvas, SCROLLBAR
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SCROLL_CB")))

proc `unmap_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `valuechanged_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # VALUECHANGED_CB: Called after the value was interactively
    # changed by the user. Called only when TOGGLE=Yes. Called after
    # the ACTION callback, but under the same context. int
    # function(Ihandle *ih); [in C]ih:valuechanged_cb() -> (ret:
    # number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB")))

proc `wheel_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # WHEEL_CB WHEEL_CB Action generated when the mouse wheel is
    # rotated. If this callback is not defined the wheel will
    # automatically scroll the canvas in the vertical direction by
    # some lines, the SCROLL_CB callback if defined will be called
    # with the IUP_SBDRAGV operation. Callback int function(Ihandle
    # *ih, float delta, int x, int y, char *status); [in C]
    # ih:wheel_cb(delta, x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. delta: the amount the wheel was rotated in notches.
    # x, y: position in the canvas where the event has occurred, in
    # pixels. status: status of mouse buttons and certain keyboard
    # keys at the moment the event was generated. The same macros used
    # for BUTTON_CB can be used for this status. Notes In Motif and
    # GTK delta is always 1 or -1. In Windows is some situations delta
    # can reach the value of two. In the future with more precise
    # wheels this increment can be changed. Affects IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WHEEL_CB")))

proc `wom_cb=`*(ih: FlatButton_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # WOM_CB WOM_CB Action generated when an audio device receives an
    # event. [Windows Only] Callback int function(Ihandle *ih, int
    # state); [in C] ih:wom_cb(state: number) -> (ret: number) [in
    # Lua] ih: identifies the element that activated the event. state:
    # can be opening=1, done=0, or closing=-1. Notes This callback is
    # used to syncronize video playback with audio. It is sent when
    # the audio device: Message Description opening is opened by using
    # the waveOutOpen function. done is finished with a data block
    # sent by using the waveOutWrite function. closing is closed by
    # using the waveOutClose function. You must use the HWND attribute
    # when calling waveOutOpen in the dwCallback parameter and set
    # fdwOpen to CALLBACK_WINDOW. Affects IupDialog, IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: FlatButton_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: FlatButton_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WOM_CB")))

proc FlatFrame*(child: IUPhandle_t): FlatFrame_t {.cdecl.} =
    # Creates a native container, which draws a frame with a title
    # around its child. The decorations are manually drawn. The
    # control inherits from IupBackgroundBox.
    return FlatFrame_t(niupc.FlatFrame(cast[PIhandle](child)))

proc `active=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `backcolor=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(value))

proc `backcolor`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(value))

proc `backcolor=`*(ih: FlatFrame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `backcolor`*(ih: FlatFrame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `backcolor`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"))

proc `backimage=`*(ih: FlatFrame_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGE"), cast[PIhandle](handle))

proc `backimage`*(ih: FlatFrame_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGE"), cast[PIhandle](handle))

proc `backimage`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGE"))

proc `backimagezoom=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring(value))

proc `backimagezoom`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring(value))

proc `backimagezoom=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring((if yes: "YES" else: "NO")))

proc `backimagezoom`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring((if yes: "YES" else: "NO")))

proc `backimagezoom`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM")) == "YES"

proc `backingstore=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE")) == "YES"

proc `bgcolor=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    # BGCOLOR: background color of the child area. If not defined it
    # will use the background color of the native parent.
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: FlatFrame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FlatFrame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `canfocus=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `canvasbox=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANVASBOX"), cstring(value))

proc `canvasbox`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANVASBOX"), cstring(value))

proc `canvasbox=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANVASBOX"), cstring((if yes: "YES" else: "NO")))

proc `canvasbox`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANVASBOX"), cstring((if yes: "YES" else: "NO")))

proc `canvasbox`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANVASBOX")) == "YES"

proc `charsize`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `childoffset=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset=`*(ih: FlatFrame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: FlatFrame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"))

proc `clientoffset`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `cursor=`*(ih: FlatFrame_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FlatFrame_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `decoration`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DECORATION")) == "YES"

proc `decoroffset`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DECOROFFSET"))

proc `decorsize`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DECORSIZE"))

proc `dragdrop=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary flatframe
proc `dragtypes`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

# TODO unknown: flatframe DRAWABLE Unknown Binary
proc `drawable`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWABLE"))

proc `drawbgcolor=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor=`*(ih: FlatFrame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: FlatFrame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"))

proc `drawcolor=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor=`*(ih: FlatFrame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: FlatFrame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"))

proc `drawdriver`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWDRIVER"))

proc `drawfont=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

proc `drawfont`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

# TODO ??? String Binary flatframe
proc `drawfont`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"))

proc `drawlinewidth=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth=`*(ih: FlatFrame_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: FlatFrame_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"))

proc `drawmakeinactive=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE")) == "YES"

proc `drawsize`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSIZE"))

proc `drawstyle=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"))

proc `drawtextalignment=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"))

proc `drawtextclip=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP")) == "YES"

proc `drawtextellipsis=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS")) == "YES"

proc `drawtextlayoutcenter=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER")) == "YES"

proc `drawtextorientation=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation=`*(ih: FlatFrame_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: FlatFrame_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"))

proc `drawtextwrap=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP")) == "YES"

proc `dropfilestarget=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary flatframe
proc `droptypes`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `dx=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx=`*(ih: FlatFrame_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: FlatFrame_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DX"))

proc `dy=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy=`*(ih: FlatFrame_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: FlatFrame_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DY"))

proc `expand=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: FlatFrame_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FlatFrame_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary flatframe
proc `font`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary flatframe
proc `fontface`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: FlatFrame_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FlatFrame_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary flatframe
proc `fontstyle`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `frame=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    # FRAME (non inheritable): enables the frame line. Default: Yes.
    # If value is CROSSTITLE the the frame at top crosses the title,
    # like traditional frames in native systems (since 3.25). When
    # CROSSTITLE is used TITLELINE and TITLEALIGNMENT are ignored, the
    # title line is never drawn and alignment is always left.
    SetAttribute(cast[PIhandle](ih), cstring("FRAME"), cstring(value))

proc `frame`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FRAME"), cstring(value))

proc `frame`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRAME"))

proc `framecolor=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    # FRAMECOLOR (non inheritable): frame line color. Default: "160
    # 160 160" (changed in 3.28).
    SetAttribute(cast[PIhandle](ih), cstring("FRAMECOLOR"), cstring(value))

proc `framecolor`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FRAMECOLOR"), cstring(value))

proc `framecolor=`*(ih: FlatFrame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FRAMECOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `framecolor`*(ih: FlatFrame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FRAMECOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `framecolor`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRAMECOLOR"))

# TODO unknown: flatframe FRAMESPACE Unknown Binary
proc `framespace`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRAMESPACE"))

proc `framewidth=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    # FRAMEWIDTH (non inheritable): frame line width. Default: 1.
    SetAttribute(cast[PIhandle](ih), cstring("FRAMEWIDTH"), cstring(value))

proc `framewidth`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FRAMEWIDTH"), cstring(value))

proc `framewidth=`*(ih: FlatFrame_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FRAMEWIDTH"), cstring(&"{x}"))

proc `framewidth`*(ih: FlatFrame_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FRAMEWIDTH"), cstring(&"{x}"))

proc `framewidth`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRAMEWIDTH"))

proc `handlename=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary flatframe
proc `handlename`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `linex=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex=`*(ih: FlatFrame_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: FlatFrame_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEX"))

proc `liney=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney=`*(ih: FlatFrame_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: FlatFrame_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEY"))

proc `maxsize=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: FlatFrame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FlatFrame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: FlatFrame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FlatFrame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary flatframe
proc `name`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary flatframe
proc `normalizergroup`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary flatframe
proc `ntheme`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: flatframe PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: flatframe PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: FlatFrame_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FlatFrame_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `posx=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx=`*(ih: FlatFrame_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: FlatFrame_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSX"))

proc `posy=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy=`*(ih: FlatFrame_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: FlatFrame_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSY"))

proc `propagatefocus=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: FlatFrame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FlatFrame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `sb_resize`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_RESIZE"))

proc `screenposition`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `scrollbar=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR")) == "YES"

proc `size=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: FlatFrame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FlatFrame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary flatframe
proc `theme`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary flatframe
proc `tip`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: FlatFrame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FlatFrame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: FlatFrame_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FlatFrame_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: FlatFrame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FlatFrame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary flatframe
proc `tipicon`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary flatframe
proc `tipmarkup`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: FlatFrame_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FlatFrame_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `title=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    # TITLE (non inheritable): Text the user will see at the top of
    # the frame.
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary flatframe
proc `title`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

# TODO unknown: flatframe TITLEALIGNMENT Unknown Binary
proc `titlealignment`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLEALIGNMENT"))

# TODO unknown: flatframe TITLEBGCOLOR Unknown Binary
proc `titlebgcolor`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLEBGCOLOR"))

# TODO unknown: flatframe TITLECOLOR Unknown Binary
proc `titlecolor`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLECOLOR"))

proc `titleimage=`*(ih: FlatFrame_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # TITLEIMAGE (non inheritable): image name to be used in title.
    # Use IupSetHandle or IupSetAttributeHandle to associate an image
    # to a name. See also IupImage.
    SetAttributeHandle(cast[PIhandle](ih), cstring("TITLEIMAGE"), cast[PIhandle](handle))

proc `titleimage`*(ih: FlatFrame_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("TITLEIMAGE"), cast[PIhandle](handle))

proc `titleimage`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLEIMAGE"))

# TODO unknown: flatframe TITLEIMAGEPOSITION Unknown Binary
proc `titleimageposition`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLEIMAGEPOSITION"))

# TODO unknown: flatframe TITLEIMAGESPACING Unknown Binary
proc `titleimagespacing`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLEIMAGESPACING"))

# TODO unknown: flatframe TITLELINE Unknown Binary
proc `titleline`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLELINE"))

# TODO unknown: flatframe TITLELINECOLOR Unknown Binary
proc `titlelinecolor`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLELINECOLOR"))

# TODO unknown: flatframe TITLELINEWIDTH Unknown Binary
proc `titlelinewidth`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLELINEWIDTH"))

# TODO unknown: flatframe TITLEPADDING Unknown Binary
proc `titlepadding`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLEPADDING"))

# TODO unknown: flatframe TITLETEXTALIGNMENT Unknown Binary
proc `titletextalignment`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLETEXTALIGNMENT"))

# TODO unknown: flatframe TITLETEXTCLIP Unknown Binary
proc `titletextclip`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLETEXTCLIP"))

# TODO unknown: flatframe TITLETEXTELLIPSIS Unknown Binary
proc `titletextellipsis`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLETEXTELLIPSIS"))

# TODO unknown: flatframe TITLETEXTORIENTATION Unknown Binary
proc `titletextorientation`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLETEXTORIENTATION"))

# TODO unknown: flatframe TITLETEXTWRAP Unknown Binary
proc `titletextwrap`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLETEXTWRAP"))

proc `touch=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOUCH")) == "YES"

proc `usersize=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: FlatFrame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FlatFrame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wheeldropfocus=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS")) == "YES"

proc `wid`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

proc `xautohide=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE")) == "YES"

proc `xdisplay`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XDISPLAY"))

# TODO unknown: flatframe XFONTID Unknown Binary
proc `xfontid`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `xhidden`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XHIDDEN")) == "YES"

proc `xmax=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax=`*(ih: FlatFrame_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: FlatFrame_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMAX"))

proc `xmin=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin=`*(ih: FlatFrame_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: FlatFrame_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMIN"))

# TODO unknown: flatframe XWINDOW Unknown Binary
proc `xwindow`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `yautohide=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide=`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: FlatFrame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE")) == "YES"

proc `yhidden`*(ih: FlatFrame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YHIDDEN")) == "YES"

proc `ymax=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax=`*(ih: FlatFrame_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: FlatFrame_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMAX"))

proc `ymin=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin=`*(ih: FlatFrame_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: FlatFrame_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: FlatFrame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMIN"))

proc `zorder=`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: FlatFrame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `destroy_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: FlatFrame_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FlatFrame_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `focus_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `keypress_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    # KEYPRESS_CB KEYPRESS_CB Action generated when a key is pressed
    # or released. If the key is pressed and held several calls will
    # occur. It is called after the callback K_ANY is processed.
    # Callback int function(Ihandle *ih, int c, int press); [in C]
    # ih:keypress_cb(c, press: number) -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. c:
    # identifier of typed key. Please refer to the Keyboard Codes
    # table for a list of possible values. press: 1 is the user
    # pressed the key or 0 otherwise. Returns: If IUP_IGNORE is
    # returned the key is ignored by the system. IUP_CLOSE will be
    # processed. Affects IupCanvas
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB")))

proc `killfocus_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `postmessage_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `scroll_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    # SCROLL_CB SCROLL_CB Called when some manipulation is made to the
    # scrollbar. The canvas is automatically redrawn only if this
    # callback is NOT defined. (GTK 2.8) Also the POSX and POSY values
    # will not be correctly updated for older GTK versions. In Ubuntu,
    # when liboverlay-scrollbar is enabled (the new tiny auto-hide
    # scrollbar) only the IUP_SBPOSV and IUP_SBPOSH codes are used.
    # Callback int function(Ihandle *ih, int op, float posx, float
    # posy); [in C] ih:scroll_cb(op, posx, posy: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. op: indicates the operation performed on the
    # scrollbar. If the manipulation was made on the vertical
    # scrollbar, it can have the following values: IUP_SBUP - line up
    # IUP_SBDN - line down IUP_SBPGUP - page up IUP_SBPGDN - page down
    # IUP_SBPOSV - vertical positioning IUP_SBDRAGV - vertical drag If
    # it was on the horizontal scrollbar, the following values are
    # valid: IUP_SBLEFT - column left IUP_SBRIGHT - column right
    # IUP_SBPGLEFT - page left IUP_SBPGRIGHT - page right IUP_SBPOSH -
    # horizontal positioning IUP_SBDRAGH - horizontal drag posx, posy:
    # the same as the ACTION canvas callback (corresponding to the
    # values of attributes POSX and POSY). Notes IUP_SBDRAGH and
    # IUP_SBDRAGV are not supported in GTK. During drag IUP_SBPOSH and
    # IUP_SBPOSV are used. In Windows, after a drag when mouse is
    # released IUP_SBPOSH or IUP_SBPOSV are called. Affects IupCanvas,
    # IupGLCanvas, SCROLLBAR
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SCROLL_CB")))

proc `unmap_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `wheel_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # WHEEL_CB WHEEL_CB Action generated when the mouse wheel is
    # rotated. If this callback is not defined the wheel will
    # automatically scroll the canvas in the vertical direction by
    # some lines, the SCROLL_CB callback if defined will be called
    # with the IUP_SBDRAGV operation. Callback int function(Ihandle
    # *ih, float delta, int x, int y, char *status); [in C]
    # ih:wheel_cb(delta, x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. delta: the amount the wheel was rotated in notches.
    # x, y: position in the canvas where the event has occurred, in
    # pixels. status: status of mouse buttons and certain keyboard
    # keys at the moment the event was generated. The same macros used
    # for BUTTON_CB can be used for this status. Notes In Motif and
    # GTK delta is always 1 or -1. In Windows is some situations delta
    # can reach the value of two. In the future with more precise
    # wheels this increment can be changed. Affects IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WHEEL_CB")))

proc `wom_cb=`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # WOM_CB WOM_CB Action generated when an audio device receives an
    # event. [Windows Only] Callback int function(Ihandle *ih, int
    # state); [in C] ih:wom_cb(state: number) -> (ret: number) [in
    # Lua] ih: identifies the element that activated the event. state:
    # can be opening=1, done=0, or closing=-1. Notes This callback is
    # used to syncronize video playback with audio. It is sent when
    # the audio device: Message Description opening is opened by using
    # the waveOutOpen function. done is finished with a data block
    # sent by using the waveOutWrite function. closing is closed by
    # using the waveOutClose function. You must use the HWND attribute
    # when calling waveOutOpen in the dwCallback parameter and set
    # fdwOpen to CALLBACK_WINDOW. Affects IupDialog, IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: FlatFrame_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: FlatFrame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WOM_CB")))

proc FlatLabel*(title: string): FlatLabel_t {.cdecl.} =
    # Creates an interface element that is a label, but it does not
    # have native decorations. Its visual presentation can contain a
    # text and/or an image. It behaves just like an IupLabel, but
    # since it is not a native control it has more flexibility for
    # additional options. It inherits from IupCanvas.
    return FlatLabel_t(niupc.FlatLabel(cstring(title)))

proc `active=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    # ACTIVE, FONT, EXPAND, SCREENPOSITION, POSITION, MINSIZE,
    # MAXSIZE, WID, TIP, SIZE, RASTERSIZE, ZORDER, VISIBLE, THEME:
    # also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `alignment=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    # ALIGNMENT (non inheritable): horizontal and vertical alignment
    # of the set image+text. Possible values: "ALEFT", "ACENTER" and
    # "ARIGHT", combined to "ATOP", "ACENTER" and "ABOTTOM". Default:
    # "ALEFT:ACENTER". Partial values are also accepted, like "ARIGHT"
    # or ":ATOP", the other value will be obtained from the default
    # value. Alignment does not includes the padding area.
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"))

proc `backimage=`*(ih: FlatLabel_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # BACKIMAGE (non inheritable): image name to be used as
    # background. Use IupSetHandle or IupSetAttributeHandle to
    # associate an image to a name. See also IupImage.
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGE"), cast[PIhandle](handle))

proc `backimage`*(ih: FlatLabel_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGE"), cast[PIhandle](handle))

proc `backimage`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGE"))

proc `backimagezoom=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    # BACKIMAGEZOOM (non inheritable): if set the back image will be
    # zoomed to occupy the full background. Aspect ratio is NOT
    # preserved. Can be Yes or No. Default: No. (since 3.25)
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring(value))

proc `backimagezoom`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring(value))

proc `backimagezoom=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring((if yes: "YES" else: "NO")))

proc `backimagezoom`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring((if yes: "YES" else: "NO")))

proc `backimagezoom`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM")) == "YES"

proc `backingstore=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE")) == "YES"

proc `bgcolor=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    # BGCOLOR: ignored. It will use the background color of the native
    # parent.
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: FlatLabel_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FlatLabel_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    # BORDER (creation only): the default value is "NO". This is the
    # IupCanvas border.
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `canfocus=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `cpadding=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    # CPADDING: same as PADDING but using the units of the SIZE
    # attribute. It will actually set the PADDING attribute. (since
    # 3.29)
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding=`*(ih: FlatLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: FlatLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CPADDING"))

proc `cspacing=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    # CSPACING: same as SPACING but using the units of the vertical
    # part of the SIZE attribute. It will actually set the SPACING
    # attribute. (since 3.29)
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(value))

proc `cspacing`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(value))

proc `cspacing=`*(ih: FlatLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(&"{x}"))

proc `cspacing`*(ih: FlatLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(&"{x}"))

proc `cspacing`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CSPACING"))

proc `cursor=`*(ih: FlatLabel_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FlatLabel_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `dragdrop=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary flatlabel
proc `dragtypes`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

# TODO unknown: flatlabel DRAWABLE Unknown Binary
proc `drawable`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWABLE"))

proc `drawbgcolor=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor=`*(ih: FlatLabel_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: FlatLabel_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"))

proc `drawcolor=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor=`*(ih: FlatLabel_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: FlatLabel_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"))

proc `drawdriver`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWDRIVER"))

proc `drawfont=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

proc `drawfont`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

# TODO ??? String Binary flatlabel
proc `drawfont`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"))

proc `drawlinewidth=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth=`*(ih: FlatLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: FlatLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"))

proc `drawmakeinactive=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE")) == "YES"

proc `drawsize`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSIZE"))

proc `drawstyle=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"))

proc `drawtextalignment=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"))

proc `drawtextclip=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP")) == "YES"

proc `drawtextellipsis=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS")) == "YES"

proc `drawtextlayoutcenter=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER")) == "YES"

proc `drawtextorientation=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation=`*(ih: FlatLabel_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: FlatLabel_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"))

proc `drawtextwrap=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP")) == "YES"

proc `dropfilestarget=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary flatlabel
proc `droptypes`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `dx=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx=`*(ih: FlatLabel_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: FlatLabel_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DX"))

proc `dy=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy=`*(ih: FlatLabel_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: FlatLabel_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DY"))

proc `expand=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable): The default value is "NO".
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: FlatLabel_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FlatLabel_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `fgcolor=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    # FGCOLOR: Text color. Default: the global attribute DLGFGCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: FlatLabel_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: FlatLabel_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

proc `fittobackimage=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    # FITTOBACKIMAGE (non inheritable): enable the natural size to be
    # computed from the BACKIMAGE. If BACKIMAGE is not defined will be
    # ignored. Can be Yes or No. Default: No.
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring(value))

proc `fittobackimage`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring(value))

proc `fittobackimage=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring((if yes: "YES" else: "NO")))

proc `fittobackimage`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring((if yes: "YES" else: "NO")))

proc `fittobackimage`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE")) == "YES"

proc `floating=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary flatlabel
proc `font`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary flatlabel
proc `fontface`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: FlatLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FlatLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary flatlabel
proc `fontstyle`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `frontimage=`*(ih: FlatLabel_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # FRONTIMAGE (non inheritable): image name to be used as
    # foreground. The foreground image is drawn in the same position
    # as the background, but it is drawn at last. Use IupSetHandle or
    # IupSetAttributeHandle to associate an image to a name. See also
    # IupImage.
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGE"), cast[PIhandle](handle))

proc `frontimage`*(ih: FlatLabel_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGE"), cast[PIhandle](handle))

proc `frontimage`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRONTIMAGE"))

proc `frontimageinactive=`*(ih: FlatLabel_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGEINACTIVE"), cast[PIhandle](handle))

proc `frontimageinactive`*(ih: FlatLabel_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGEINACTIVE"), cast[PIhandle](handle))

proc `frontimageinactive`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRONTIMAGEINACTIVE"))

proc `handlename=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary flatlabel
proc `handlename`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `image=`*(ih: FlatLabel_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGE (non inheritable): Image name. Use IupSetHandle or
    # IupSetAttributeHandle to associate an image to a name. See also
    # IupImage.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: FlatLabel_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGE"))

proc `imageinactive=`*(ih: FlatLabel_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGEINACTIVE (non inheritable): Image name of the element when
    # inactive. If it is not defined then the IMAGE is used and its
    # colors will be replaced by a modified version creating the
    # disabled effect.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEINACTIVE"), cast[PIhandle](handle))

proc `imageinactive`*(ih: FlatLabel_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEINACTIVE"), cast[PIhandle](handle))

proc `imageinactive`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEINACTIVE"))

proc `imageposition=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    # IMAGEPOSITION (non inheritable): Position of the image relative
    # to the text when both are displayed. Can be: LEFT, RIGHT, TOP,
    # BOTTOM. Default: LEFT.
    SetAttribute(cast[PIhandle](ih), cstring("IMAGEPOSITION"), cstring(value))

proc `imageposition`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("IMAGEPOSITION"), cstring(value))

proc `imageposition`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEPOSITION"))

proc `linex=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex=`*(ih: FlatLabel_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: FlatLabel_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEX"))

proc `liney=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney=`*(ih: FlatLabel_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: FlatLabel_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEY"))

proc `maxsize=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: FlatLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FlatLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: FlatLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FlatLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary flatlabel
proc `name`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary flatlabel
proc `normalizergroup`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary flatlabel
proc `ntheme`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `padding=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    # PADDING: internal margin. Works just like the MARGIN attribute
    # of the IupHbox and IupVbox containers, but uses a different name
    # to avoid inheritance problems. Default value: "0x0". Alignment
    # does not includes the padding area. The natural size will be a
    # combination of the size of the image and the title, if any, plus
    # PADDING and SPACING (if both image and title are present).
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding=`*(ih: FlatLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: FlatLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PADDING"))

# TODO unknown: flatlabel PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: flatlabel PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: FlatLabel_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FlatLabel_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `posx=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx=`*(ih: FlatLabel_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: FlatLabel_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSX"))

proc `posy=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy=`*(ih: FlatLabel_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: FlatLabel_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSY"))

proc `propagatefocus=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: FlatLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FlatLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `sb_resize`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_RESIZE"))

proc `screenposition`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `scrollbar=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR")) == "YES"

proc `size=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: FlatLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FlatLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `spacing=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    # SPACING (non inheritable): spacing between the image and the
    # text. Default: "2". The natural size will be a combination of
    # the size of the image and the title, if any, plus PADDING and
    # SPACING (if both image and title are present).
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(value))

proc `spacing`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(value))

proc `spacing=`*(ih: FlatLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(&"{x}"))

proc `spacing`*(ih: FlatLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(&"{x}"))

proc `spacing`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPACING"))

proc `textalignment=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    # TEXTALIGNMENT (non inheritable): Horizontal text alignment for
    # multiple lines. Can be: ALEFT, ARIGHT or ACENTER. Default:
    # ALEFT. (since 3.22)
    SetAttribute(cast[PIhandle](ih), cstring("TEXTALIGNMENT"), cstring(value))

proc `textalignment`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTALIGNMENT"), cstring(value))

proc `textalignment`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTALIGNMENT"))

# TODO unknown: flatlabel TEXTCLIP Unknown Binary
proc `textclip`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTCLIP"))

proc `textellipsis=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    # TEXTELLIPSIS (non inheritable): If the text is larger that its
    # box, an ellipsis ("...") will be placed near the last visible
    # part of the text and replace the invisible part. It will be
    # ignored when TEXTWRAP=Yes. (since 3.25)
    SetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS"), cstring(value))

proc `textellipsis`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS"), cstring(value))

proc `textellipsis=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `textellipsis`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `textellipsis`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS")) == "YES"

proc `textorientation=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    # TEXTORIENTATION (non inheritable): text angle in degrees and
    # counterclockwise. The text size will adapt to include the
    # rotated space. (since 3.25)
    SetAttribute(cast[PIhandle](ih), cstring("TEXTORIENTATION"), cstring(value))

proc `textorientation`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTORIENTATION"), cstring(value))

proc `textorientation=`*(ih: FlatLabel_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTORIENTATION"), cstring(&"{x}"))

proc `textorientation`*(ih: FlatLabel_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTORIENTATION"), cstring(&"{x}"))

proc `textorientation`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTORIENTATION"))

proc `textwrap=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    # TEXTWRAP (non inheritable): For single line texts if the text is
    # larger than its box the line will be automatically broken in
    # multiple lines. Notice that this is done internally by the
    # system, the element natural size will still use only a single
    # line. For the remaining lines to be visible the element should
    # use EXPAND=VERTICAL or set a SIZE/RASTERSIZE with enough height
    # for the wrapped lines. (since 3.25)
    SetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP"), cstring(value))

proc `textwrap`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP"), cstring(value))

proc `textwrap=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `textwrap`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `textwrap`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP")) == "YES"

proc `theme=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary flatlabel
proc `theme`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary flatlabel
proc `tip`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: FlatLabel_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FlatLabel_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: FlatLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FlatLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: FlatLabel_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FlatLabel_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary flatlabel
proc `tipicon`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary flatlabel
proc `tipmarkup`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: FlatLabel_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FlatLabel_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `title=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    # TITLE (non inheritable): Label's text. The '\n' character is
    # accepted for line change.
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary flatlabel
proc `title`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

proc `touch=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOUCH")) == "YES"

proc `usersize=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: FlatLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FlatLabel_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wheeldropfocus=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS")) == "YES"

proc `wid`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

proc `xautohide=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE")) == "YES"

proc `xdisplay`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XDISPLAY"))

# TODO unknown: flatlabel XFONTID Unknown Binary
proc `xfontid`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `xhidden`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XHIDDEN")) == "YES"

proc `xmax=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax=`*(ih: FlatLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: FlatLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMAX"))

proc `xmin=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin=`*(ih: FlatLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: FlatLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMIN"))

# TODO unknown: flatlabel XWINDOW Unknown Binary
proc `xwindow`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `yautohide=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide=`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: FlatLabel_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE")) == "YES"

proc `yhidden`*(ih: FlatLabel_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YHIDDEN")) == "YES"

proc `ymax=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax=`*(ih: FlatLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: FlatLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMAX"))

proc `ymin=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin=`*(ih: FlatLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: FlatLabel_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: FlatLabel_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMIN"))

proc `zorder=`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: FlatLabel_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `destroy_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: FlatLabel_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FlatLabel_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `focus_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `keypress_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    # KEYPRESS_CB KEYPRESS_CB Action generated when a key is pressed
    # or released. If the key is pressed and held several calls will
    # occur. It is called after the callback K_ANY is processed.
    # Callback int function(Ihandle *ih, int c, int press); [in C]
    # ih:keypress_cb(c, press: number) -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. c:
    # identifier of typed key. Please refer to the Keyboard Codes
    # table for a list of possible values. press: 1 is the user
    # pressed the key or 0 otherwise. Returns: If IUP_IGNORE is
    # returned the key is ignored by the system. IUP_CLOSE will be
    # processed. Affects IupCanvas
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB")))

proc `killfocus_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `postmessage_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `scroll_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    # SCROLL_CB SCROLL_CB Called when some manipulation is made to the
    # scrollbar. The canvas is automatically redrawn only if this
    # callback is NOT defined. (GTK 2.8) Also the POSX and POSY values
    # will not be correctly updated for older GTK versions. In Ubuntu,
    # when liboverlay-scrollbar is enabled (the new tiny auto-hide
    # scrollbar) only the IUP_SBPOSV and IUP_SBPOSH codes are used.
    # Callback int function(Ihandle *ih, int op, float posx, float
    # posy); [in C] ih:scroll_cb(op, posx, posy: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. op: indicates the operation performed on the
    # scrollbar. If the manipulation was made on the vertical
    # scrollbar, it can have the following values: IUP_SBUP - line up
    # IUP_SBDN - line down IUP_SBPGUP - page up IUP_SBPGDN - page down
    # IUP_SBPOSV - vertical positioning IUP_SBDRAGV - vertical drag If
    # it was on the horizontal scrollbar, the following values are
    # valid: IUP_SBLEFT - column left IUP_SBRIGHT - column right
    # IUP_SBPGLEFT - page left IUP_SBPGRIGHT - page right IUP_SBPOSH -
    # horizontal positioning IUP_SBDRAGH - horizontal drag posx, posy:
    # the same as the ACTION canvas callback (corresponding to the
    # values of attributes POSX and POSY). Notes IUP_SBDRAGH and
    # IUP_SBDRAGV are not supported in GTK. During drag IUP_SBPOSH and
    # IUP_SBPOSV are used. In Windows, after a drag when mouse is
    # released IUP_SBPOSH or IUP_SBPOSV are called. Affects IupCanvas,
    # IupGLCanvas, SCROLLBAR
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SCROLL_CB")))

proc `unmap_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `wheel_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # WHEEL_CB WHEEL_CB Action generated when the mouse wheel is
    # rotated. If this callback is not defined the wheel will
    # automatically scroll the canvas in the vertical direction by
    # some lines, the SCROLL_CB callback if defined will be called
    # with the IUP_SBDRAGV operation. Callback int function(Ihandle
    # *ih, float delta, int x, int y, char *status); [in C]
    # ih:wheel_cb(delta, x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. delta: the amount the wheel was rotated in notches.
    # x, y: position in the canvas where the event has occurred, in
    # pixels. status: status of mouse buttons and certain keyboard
    # keys at the moment the event was generated. The same macros used
    # for BUTTON_CB can be used for this status. Notes In Motif and
    # GTK delta is always 1 or -1. In Windows is some situations delta
    # can reach the value of two. In the future with more precise
    # wheels this increment can be changed. Affects IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WHEEL_CB")))

proc `wom_cb=`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # WOM_CB WOM_CB Action generated when an audio device receives an
    # event. [Windows Only] Callback int function(Ihandle *ih, int
    # state); [in C] ih:wom_cb(state: number) -> (ret: number) [in
    # Lua] ih: identifies the element that activated the event. state:
    # can be opening=1, done=0, or closing=-1. Notes This callback is
    # used to syncronize video playback with audio. It is sent when
    # the audio device: Message Description opening is opened by using
    # the waveOutOpen function. done is finished with a data block
    # sent by using the waveOutWrite function. closing is closed by
    # using the waveOutClose function. You must use the HWND attribute
    # when calling waveOutOpen in the dwCallback parameter and set
    # fdwOpen to CALLBACK_WINDOW. Affects IupDialog, IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: FlatLabel_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: FlatLabel_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WOM_CB")))

proc FlatList*(): FlatList_t {.cdecl.} =
    # Creates an interface element that displays a list of items, but
    # it does not have native decorations. It behaves like IupList
    # when DROPDOWN=NO and EDITBOX=NO. It inherits from IupCanvas.
    return FlatList_t(niupc.FlatList())

proc `active=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `alignment=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # ALIGNMENT (non inheritable): horizontal and vertical alignment
    # of the set image+text for each item. Possible values: "ALEFT",
    # "ACENTER" and "ARIGHT", combined to "ATOP", "ACENTER" and
    # "ABOTTOM". Default: "ALEFT:ACENTER". Partial values are also
    # accepted, like "ARIGHT" or ":ATOP", the other value will be
    # obtained from the default value. Alignment does not includes the
    # padding area.
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"))

proc `appenditem=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # APPENDITEM (write-only): inserts an item after the last item.
    # Ignored if set before map.
    SetAttribute(cast[PIhandle](ih), cstring("APPENDITEM"), cstring(value))

proc `appenditem`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("APPENDITEM"), cstring(value))

# TODO ??? String Binary flatlist
proc `arrowimages=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGES"), cstring(value))

proc `arrowimages`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGES"), cstring(value))

proc `arrowimages=`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGES"), cstring(&"{x}"))

proc `arrowimages`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGES"), cstring(&"{x}"))

proc `arrowimages`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGES"))

proc `backimage=`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # BACKIMAGE (non inheritable): image name to be used as
    # background. Use IupSetHandle or IupSetAttributeHandle to
    # associate an image to a name. See also IupImage.
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGE"), cast[PIhandle](handle))

proc `backimage`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGE"), cast[PIhandle](handle))

proc `backimage`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGE"))

proc `backimagezoom=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # BACKIMAGEZOOM (non inheritable): if set the back image will be
    # zoomed to occupy the full background. Aspect ratio is NOT
    # preserved. Can be Yes or No. Default: No.
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring(value))

proc `backimagezoom`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring(value))

proc `backimagezoom=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring((if yes: "YES" else: "NO")))

proc `backimagezoom`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring((if yes: "YES" else: "NO")))

proc `backimagezoom`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM")) == "YES"

proc `backingstore=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE")) == "YES"

proc `bgcolor=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # BGCOLOR: Background color of the text. Default: the global
    # attribute TXTBGCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: FlatList_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FlatList_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # BORDER (creation only): the default value is "NO". This is the
    # IupCanvas border. It is displayed around the scrollbars.
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `bordercolor=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # BORDERCOLOR: color used for the internal border. Default: "50
    # 150 255". This is for the internal border.
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(value))

proc `bordercolor`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(value))

proc `bordercolor=`*(ih: FlatList_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bordercolor`*(ih: FlatList_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bordercolor`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"))

proc `borderwidth=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # BORDERWIDTH: line width used for the internal border. Default:
    # "0". The internal borders are hidden by simply setting this
    # value to 0. It is drawn inside the canvas, so inside the
    # scrollbars.
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(value))

proc `borderwidth`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(value))

proc `borderwidth=`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(&"{x}"))

proc `borderwidth`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(&"{x}"))

proc `borderwidth`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"))

proc `canfocus=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `count`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("COUNT"))

proc `cpadding=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # CPADDING: same as PADDING but using the units of the SIZE
    # attribute. It will actually set the PADDING attribute. (since
    # 3.29)
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding=`*(ih: FlatList_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: FlatList_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CPADDING"))

proc `cspacing=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # CSPACING: same as SPACING but using the units of the vertical
    # part of the SIZE attribute. It will actually set the SPACING
    # attribute. (since 3.29)
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(value))

proc `cspacing`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(value))

proc `cspacing=`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(&"{x}"))

proc `cspacing`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(&"{x}"))

proc `cspacing`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CSPACING"))

proc `cursor=`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `dragdrop=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragdroplist=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # DRAGDROPLIST (non inheritable): prepare the Drag & Drop
    # callbacks to support drag and drop of items between lists
    # (IupList or IupFlatList), in the same IUP application. Drag &
    # Drop attributes still need to be set in order to activate the
    # drag & drop support, so the application can control if this list
    # will be source and/or target. Default: NO.
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROPLIST"), cstring(value))

proc `dragdroplist`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROPLIST"), cstring(value))

proc `dragdroplist=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROPLIST"), cstring((if yes: "YES" else: "NO")))

proc `dragdroplist`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROPLIST"), cstring((if yes: "YES" else: "NO")))

proc `dragdroplist`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROPLIST")) == "YES"

proc `dragsource=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary flatlist
proc `dragtypes`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

# TODO unknown: flatlist DRAWABLE Unknown Binary
proc `drawable`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWABLE"))

proc `drawbgcolor=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor=`*(ih: FlatList_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: FlatList_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"))

proc `drawcolor=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor=`*(ih: FlatList_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: FlatList_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"))

proc `drawdriver`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWDRIVER"))

proc `drawfont=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

proc `drawfont`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

# TODO ??? String Binary flatlist
proc `drawfont`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"))

proc `drawlinewidth=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth=`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"))

proc `drawmakeinactive=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE")) == "YES"

proc `drawsize`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSIZE"))

proc `drawstyle=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"))

proc `drawtextalignment=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"))

proc `drawtextclip=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP")) == "YES"

proc `drawtextellipsis=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS")) == "YES"

proc `drawtextlayoutcenter=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER")) == "YES"

proc `drawtextorientation=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation=`*(ih: FlatList_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: FlatList_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"))

proc `drawtextwrap=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP")) == "YES"

proc `dropfilestarget=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # DROPFILESTARGET (non inheritable): Enable or disable the drop of
    # files. Default: NO, but if DROPFILES_CB is defined when the
    # element is mapped then it will be automatically enabled.
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary flatlist
proc `droptypes`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `dx=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx=`*(ih: FlatList_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: FlatList_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DX"))

proc `dy=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy=`*(ih: FlatList_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: FlatList_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DY"))

proc `expand=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: FlatList_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FlatList_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `fgcolor=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # FGCOLOR: Text color. Default: the global attribute TXTFGCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: FlatList_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: FlatList_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

proc `fittobackimage=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # FITTOBACKIMAGE (non inheritable): enable the natural size to be
    # computed from the BACKIMAGE. If BACKIMAGE is not defined will be
    # ignored. Can be Yes or No. Default: No.
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring(value))

proc `fittobackimage`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring(value))

proc `fittobackimage=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring((if yes: "YES" else: "NO")))

proc `fittobackimage`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring((if yes: "YES" else: "NO")))

proc `fittobackimage`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE")) == "YES"

# TODO unknown: flatlist FLATSCROLLBAR Unknown Binary
proc `flatscrollbar`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLATSCROLLBAR"))

proc `floating=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

# TODO unknown: flatlist FLOATINGDELAY Unknown Binary
proc `floatingdelay`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATINGDELAY"))

proc `focusfeedback=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # FOCUSFEEDBACK (non inheritable): draw the focus feedback. Can be
    # Yes or No. Default: Yes.
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring(value))

proc `focusfeedback`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring(value))

proc `focusfeedback=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring((if yes: "YES" else: "NO")))

proc `focusfeedback`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring((if yes: "YES" else: "NO")))

proc `focusfeedback`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK")) == "YES"

proc `font=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary flatlist
proc `font`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary flatlist
proc `fontface`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary flatlist
proc `fontstyle`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary flatlist
proc `handlename`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `hasfocus`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HASFOCUS")) == "YES"

proc `hlcolor=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # HLCOLOR: color of a filled box drawn over the selected item.
    # Default: "TXTHLCOLOR".
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(value))

proc `hlcolor`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(value))

proc `hlcolor=`*(ih: FlatList_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `hlcolor`*(ih: FlatList_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `hlcolor`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"))

proc `hlcoloralpha=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # HLCOLORALPHA: the transparency used to draw the selection.
    # Default: 128. If set to 0 the selection box is not drawn.
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLORALPHA"), cstring(value))

proc `hlcoloralpha`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLORALPHA"), cstring(value))

proc `hlcoloralpha=`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLORALPHA"), cstring(&"{x}"))

proc `hlcoloralpha`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLORALPHA"), cstring(&"{x}"))

proc `hlcoloralpha`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HLCOLORALPHA"))

proc `iconspacing=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # ICONSPACING (non inheritable): spacing between the image and the
    # text. Default: "2".
    SetAttribute(cast[PIhandle](ih), cstring("ICONSPACING"), cstring(value))

proc `iconspacing`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ICONSPACING"), cstring(value))

proc `iconspacing=`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ICONSPACING"), cstring(&"{x}"))

proc `iconspacing`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ICONSPACING"), cstring(&"{x}"))

proc `iconspacing`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ICONSPACING"))

# TODO getter flatlist IDVALUE
# TODO getter flatlist IMAGE
# TODO getter flatlist IMAGENATIVEHANDLE
proc `imageposition=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # IMAGEPOSITION (non inheritable): Position of the image relative
    # to the text when both are displayed. Can be: LEFT, RIGHT, TOP,
    # BOTTOM. Default: LEFT.
    SetAttribute(cast[PIhandle](ih), cstring("IMAGEPOSITION"), cstring(value))

proc `imageposition`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("IMAGEPOSITION"), cstring(value))

proc `imageposition`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEPOSITION"))

# TODO getter flatlist INSERTITEM
# TODO getter flatlist ITEMBGCOLOR
# TODO getter flatlist ITEMFGCOLOR
# TODO getter flatlist ITEMFONT
# TODO getter flatlist ITEMFONTSIZE
# TODO getter flatlist ITEMFONTSTYLE
# TODO getter flatlist ITEMTIP
proc `linex=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex=`*(ih: FlatList_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: FlatList_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEX"))

proc `liney=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney=`*(ih: FlatList_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: FlatList_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEY"))

proc `maxsize=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: FlatList_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FlatList_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: FlatList_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FlatList_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `multiple=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # MULTIPLE (creation only): Allows selecting several items
    # simultaneously (multiple list). Default: "NO".
    SetAttribute(cast[PIhandle](ih), cstring("MULTIPLE"), cstring(value))

proc `multiple`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MULTIPLE"), cstring(value))

proc `multiple=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MULTIPLE"), cstring((if yes: "YES" else: "NO")))

proc `multiple`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MULTIPLE"), cstring((if yes: "YES" else: "NO")))

proc `multiple`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MULTIPLE")) == "YES"

proc `name=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary flatlist
proc `name`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary flatlist
proc `normalizergroup`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary flatlist
proc `ntheme`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `padding=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # PADDING: internal margin of each item. Works just like the
    # MARGIN attribute of the IupHbox and IupVbox containers, but uses
    # a different name to avoid inheritance problems. Alignment does
    # not includes the padding area. Default value: "2x2".
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding=`*(ih: FlatList_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: FlatList_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PADDING"))

# TODO unknown: flatlist PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: flatlist PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: FlatList_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FlatList_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `posx=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx=`*(ih: FlatList_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: FlatList_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSX"))

proc `posy=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy=`*(ih: FlatList_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: FlatList_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSY"))

proc `propagatefocus=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # PROPAGATEFOCUS (non inheritable): enables the focus callback
    # forwarding to the next native parent with FOCUS_CB defined.
    # Default: NO.
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `pscolor=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # PSCOLOR: background color of a selected item. If not defined
    # BACKCOLORid will be used. (since 3.30)
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(value))

proc `pscolor`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(value))

proc `pscolor=`*(ih: FlatList_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `pscolor`*(ih: FlatList_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `pscolor`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"))

proc `rastersize=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: FlatList_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FlatList_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `removeitem=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # REMOVEITEM (write-only): removes the given value. value starts
    # at 1. If value is NULL or "ALL" removes all the items. Different
    # from IupList, can be set before map.
    SetAttribute(cast[PIhandle](ih), cstring("REMOVEITEM"), cstring(value))

proc `removeitem`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("REMOVEITEM"), cstring(value))

proc `removeitem=`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("REMOVEITEM"), cstring(&"{x}"))

proc `removeitem`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("REMOVEITEM"), cstring(&"{x}"))

# TODO unknown: flatlist SB_BACKCOLOR Unknown Binary
proc `sb_backcolor`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_BACKCOLOR"))

# TODO unknown: flatlist SB_FORECOLOR Unknown Binary
proc `sb_forecolor`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_FORECOLOR"))

# TODO unknown: flatlist SB_HIGHCOLOR Unknown Binary
proc `sb_highcolor`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_HIGHCOLOR"))

proc `sb_imagebottom=`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOM"), cast[PIhandle](handle))

proc `sb_imagebottom`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOM"), cast[PIhandle](handle))

proc `sb_imagebottom`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOM"))

proc `sb_imagebottomhighlight=`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagebottomhighlight`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagebottomhighlight`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMHIGHLIGHT"))

proc `sb_imagebottominactive=`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMINACTIVE"), cast[PIhandle](handle))

proc `sb_imagebottominactive`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMINACTIVE"), cast[PIhandle](handle))

proc `sb_imagebottominactive`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMINACTIVE"))

proc `sb_imagebottompress=`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMPRESS"), cast[PIhandle](handle))

proc `sb_imagebottompress`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMPRESS"), cast[PIhandle](handle))

proc `sb_imagebottompress`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMPRESS"))

proc `sb_imageleft=`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFT"), cast[PIhandle](handle))

proc `sb_imageleft`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFT"), cast[PIhandle](handle))

proc `sb_imageleft`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGELEFT"))

proc `sb_imagelefthighlight=`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFTHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagelefthighlight`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFTHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagelefthighlight`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGELEFTHIGHLIGHT"))

proc `sb_imageleftinactive=`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFTINACTIVE"), cast[PIhandle](handle))

proc `sb_imageleftinactive`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFTINACTIVE"), cast[PIhandle](handle))

proc `sb_imageleftinactive`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGELEFTINACTIVE"))

proc `sb_imageleftpress=`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFTPRESS"), cast[PIhandle](handle))

proc `sb_imageleftpress`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFTPRESS"), cast[PIhandle](handle))

proc `sb_imageleftpress`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGELEFTPRESS"))

proc `sb_imageright=`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHT"), cast[PIhandle](handle))

proc `sb_imageright`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHT"), cast[PIhandle](handle))

proc `sb_imageright`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGERIGHT"))

proc `sb_imagerighthighlight=`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHTHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagerighthighlight`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHTHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagerighthighlight`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGERIGHTHIGHLIGHT"))

proc `sb_imagerightinactive=`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHTINACTIVE"), cast[PIhandle](handle))

proc `sb_imagerightinactive`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHTINACTIVE"), cast[PIhandle](handle))

proc `sb_imagerightinactive`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGERIGHTINACTIVE"))

proc `sb_imagerightpress=`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHTPRESS"), cast[PIhandle](handle))

proc `sb_imagerightpress`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHTPRESS"), cast[PIhandle](handle))

proc `sb_imagerightpress`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGERIGHTPRESS"))

proc `sb_imagetop=`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOP"), cast[PIhandle](handle))

proc `sb_imagetop`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOP"), cast[PIhandle](handle))

proc `sb_imagetop`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGETOP"))

proc `sb_imagetophighlight=`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOPHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagetophighlight`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOPHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagetophighlight`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGETOPHIGHLIGHT"))

proc `sb_imagetopinactive=`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOPINACTIVE"), cast[PIhandle](handle))

proc `sb_imagetopinactive`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOPINACTIVE"), cast[PIhandle](handle))

proc `sb_imagetopinactive`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGETOPINACTIVE"))

proc `sb_imagetoppress=`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOPPRESS"), cast[PIhandle](handle))

proc `sb_imagetoppress`*(ih: FlatList_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOPPRESS"), cast[PIhandle](handle))

proc `sb_imagetoppress`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGETOPPRESS"))

# TODO unknown: flatlist SB_PRESSCOLOR Unknown Binary
proc `sb_presscolor`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_PRESSCOLOR"))

proc `sb_resize`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_RESIZE"))

proc `screenposition`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `scrollbar=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # SCROLLBAR (read-only): is always "NO". So the IupCanvas native
    # scrollbars are hidden. See the FLATSCROLLBAR attribute bellow.
    # YAUTOHIDE and XAUTOHIDE will be always Yes.
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR")) == "YES"

# TODO unknown: flatlist SCROLLBARSIZE Unknown Binary
proc `scrollbarsize`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBARSIZE"))

# TODO unknown: flatlist SHOWARROWS Unknown Binary
proc `showarrows`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWARROWS"))

proc `showdragdrop=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # SHOWDRAGDROP (creation only) (non inheritable): enables the
    # internal drag and drop of items in the same list, and enables
    # the DRAGDROP_CB callback. Default: "NO". Works only if
    # MULTIPLE=NO. Drag & Drop attributes are NOT used.
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDRAGDROP"), cstring(value))

proc `showdragdrop`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDRAGDROP"), cstring(value))

proc `showdragdrop=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `showdragdrop`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `showdragdrop`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWDRAGDROP")) == "YES"

# TODO unknown: flatlist SHOWFLOATING Unknown Binary
proc `showfloating`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWFLOATING"))

# TODO unknown: flatlist SHOWTRANSPARENT Unknown Binary
proc `showtransparent`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWTRANSPARENT"))

proc `size=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # SIZE: Size of the list. The Natural Size is defined by the
    # number of elements in the list and the with of the largest item,
    # the default has room for 5 characters in 1 item. The Natural
    # Size ignores the list contents if VISIBLECOLUMNS or VISIBLELINES
    # attributes are defined.
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: FlatList_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FlatList_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `spacing=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # SPACING: internal space between each item. Different from
    # IupList, it does not affects the internal margin. Not drawn with
    # any item background color. Default: 0
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(value))

proc `spacing`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(value))

proc `spacing=`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(&"{x}"))

proc `spacing`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(&"{x}"))

proc `spacing`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPACING"))

proc `textalignment=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # TEXTALIGNMENT (non inheritable): Horizontal text alignment for
    # multiple lines. Can be: ALEFT, ARIGHT or ACENTER. Default:
    # ALEFT.
    SetAttribute(cast[PIhandle](ih), cstring("TEXTALIGNMENT"), cstring(value))

proc `textalignment`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTALIGNMENT"), cstring(value))

proc `textalignment`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTALIGNMENT"))

proc `textellipsis=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # TEXTELLIPSIS (non inheritable): If the text is larger that its
    # box, an ellipsis ("...") will be placed near the last visible
    # part of the text and replace the invisible part. It will be
    # ignored when TEXTWRAP=Yes.
    SetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS"), cstring(value))

proc `textellipsis`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS"), cstring(value))

proc `textellipsis=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `textellipsis`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `textellipsis`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS")) == "YES"

proc `textpscolor=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # TEXTPSCOLOR: foreground color of a selected item. If not defined
    # FORECOLORid will be used. (since 3.30)
    SetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"), cstring(value))

proc `textpscolor`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"), cstring(value))

proc `textpscolor=`*(ih: FlatList_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `textpscolor`*(ih: FlatList_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `textpscolor`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"))

proc `textwrap=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # TEXTWRAP (non inheritable): For single line texts if the text is
    # larger than its box the line will be automatically broken in
    # multiple lines. Notice that this is done internally by the
    # system, the element natural size will still use only a single
    # line. For the remaining lines to be visible the element should
    # use EXPAND=VERTICAL or set a SIZE/RASTERSIZE with enough height
    # for the wrapped lines.
    SetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP"), cstring(value))

proc `textwrap`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP"), cstring(value))

proc `textwrap=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `textwrap`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `textwrap`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP")) == "YES"

proc `theme=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary flatlist
proc `theme`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary flatlist
proc `tip`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: FlatList_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FlatList_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: FlatList_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FlatList_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary flatlist
proc `tipicon`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary flatlist
proc `tipmarkup`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: FlatList_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FlatList_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `topitem=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # TOPITEM (write-only): position the given item at the top of the
    # list or near to make it visible.
    SetAttribute(cast[PIhandle](ih), cstring("TOPITEM"), cstring(value))

proc `topitem`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPITEM"), cstring(value))

proc `topitem=`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPITEM"), cstring(&"{x}"))

proc `topitem`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPITEM"), cstring(&"{x}"))

proc `touch=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOUCH")) == "YES"

proc `usersize=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: FlatList_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FlatList_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # VALUE (non inheritable): Depends on the selection mode:
    # MULTIPLE=YES: Sequence of '+' and '-' symbols indicating the
    # state of each item. When setting this value, the user must
    # provide the same amount of '+' and '-' symbols as the amount of
    # items in the list. It can use ' ' (space) or another character
    # so the current selection on that item will remain the same
    # (since 3.28). MULTIPLE=NO: Integer number representing the
    # selected item in the list (begins at 1). It returns NULL if
    # there is no selected item. For both cases, when setting NULL all
    # items are deselected. The non changed items marked with 'x' are
    # simulated internally by IUP in all systems. If you add or remove
    # items to/from the list and you count on the 'x' values, then
    # after adding/removing items set the VALUE attribute to ensure
    # proper 'x' values.
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

# TODO ??? String Binary flatlist
proc `value`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `valuestring=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # VALUESTRING (non inheritable): changes or retrieves the value
    # attribute using a string of an item. Works only when
    # MULTIPLE=NO. When set it will search for the first item with the
    # same string.
    SetAttribute(cast[PIhandle](ih), cstring("VALUESTRING"), cstring(value))

proc `valuestring`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUESTRING"), cstring(value))

# TODO ??? String Binary flatlist
proc `valuestring`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUESTRING"))

proc `visible=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `visiblecolumns=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # VISIBLECOLUMNS: Defines the number of visible columns for the
    # Natural Size, this means that will act also as minimum number of
    # visible columns. It uses a wider character size then the one
    # used for the SIZE attribute so strings will fit better without
    # the need of extra columns. Set this attribute to speed Natural
    # Size computation for very large lists.
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"), cstring(value))

proc `visiblecolumns`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"), cstring(value))

proc `visiblecolumns=`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"), cstring(&"{x}"))

proc `visiblecolumns`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"), cstring(&"{x}"))

proc `visiblecolumns`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"))

proc `visiblelines=`*(ih: FlatList_t, value: string) {.cdecl.} =
    # VISIBLELINES: Defines the number of visible lines for the
    # Natural Size, this means that will act also as minimum number of
    # visible lines.
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLELINES"), cstring(value))

proc `visiblelines`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLELINES"), cstring(value))

proc `visiblelines=`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLELINES"), cstring(&"{x}"))

proc `visiblelines`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLELINES"), cstring(&"{x}"))

proc `visiblelines`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLELINES"))

proc `wheeldropfocus=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus=`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: FlatList_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS")) == "YES"

proc `wid`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

proc `xautohide`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE")) == "YES"

proc `xdisplay`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XDISPLAY"))

# TODO unknown: flatlist XFONTID Unknown Binary
proc `xfontid`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `xhidden`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XHIDDEN")) == "YES"

proc `xmax=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax=`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMAX"))

proc `xmin=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin=`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMIN"))

# TODO unknown: flatlist XWINDOW Unknown Binary
proc `xwindow`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `yautohide`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE")) == "YES"

proc `yhidden`*(ih: FlatList_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YHIDDEN")) == "YES"

proc `ymax=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax=`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMAX"))

proc `ymin=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin=`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: FlatList_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: FlatList_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMIN"))

proc `zorder=`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: FlatList_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: FlatList_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: FlatList_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `dblclick_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle, item: cint, text: cstring): cint {.cdecl.}) {.cdecl.} =
    # DBLCLICK_CB: Action generated when the user double click an
    # item. int function (Ihandle *ih, int item, char *text); [in
    # C]ih:dblclick_cb(item: number, text: string) -> (ret: number)
    # [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("DBLCLICK_CB"), cast[Icallback](cb))

proc `dblclick_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle, item: cint, text: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DBLCLICK_CB"), cast[Icallback](cb))

proc `dblclick_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DBLCLICK_CB")))

proc `destroy_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragdrop_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle, drag_id, drop_id, isshift, iscontrol: cint): cint {.cdecl.}) {.cdecl.} =
    # DRAGDROP_CB: Action generated when an internal drag and drop is
    # executed. Only active if SHOWDRAGDROP=YES. int function(Ihandle
    # *ih, int drag_id, int drop_id, int isshift, int iscontrol); [in
    # C] ih:dragdrop_cb(drag_id, drop_id, isshift, iscontrol: number)
    # -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("DRAGDROP_CB"), cast[Icallback](cb))

proc `dragdrop_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle, drag_id, drop_id, isshift, iscontrol: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDROP_CB"), cast[Icallback](cb))

proc `dragdrop_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDROP_CB")))

proc `dragend_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: FlatList_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FlatList_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `flat_action=`*(ih: FlatList_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cint): cint {.cdecl.}) {.cdecl.} =
    # FLAT_ACTION: Action generated when the state of an item in the
    # list is interactively changed. int function (Ihandle *ih, char
    # *text, int item, int state); [in C]ih:action(text: string, item,
    # state: number) -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("FLAT_ACTION"), cast[Icallback](cb))

proc `flat_action`*(ih: FlatList_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_ACTION"), cast[Icallback](cb))

proc `flat_action`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_ACTION")))

proc `flat_button_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_BUTTON_CB"), cast[Icallback](cb))

proc `flat_button_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_BUTTON_CB"), cast[Icallback](cb))

proc `flat_button_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_BUTTON_CB")))

proc `flat_focus_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_FOCUS_CB"), cast[Icallback](cb))

proc `flat_focus_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_FOCUS_CB"), cast[Icallback](cb))

proc `flat_focus_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_FOCUS_CB")))

proc `flat_leavewindow_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `flat_leavewindow_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `flat_leavewindow_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_LEAVEWINDOW_CB")))

proc `flat_motion_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_MOTION_CB"), cast[Icallback](cb))

proc `flat_motion_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_MOTION_CB"), cast[Icallback](cb))

proc `flat_motion_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_MOTION_CB")))

proc `focus_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `keypress_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    # KEYPRESS_CB KEYPRESS_CB Action generated when a key is pressed
    # or released. If the key is pressed and held several calls will
    # occur. It is called after the callback K_ANY is processed.
    # Callback int function(Ihandle *ih, int c, int press); [in C]
    # ih:keypress_cb(c, press: number) -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. c:
    # identifier of typed key. Please refer to the Keyboard Codes
    # table for a list of possible values. press: 1 is the user
    # pressed the key or 0 otherwise. Returns: If IUP_IGNORE is
    # returned the key is ignored by the system. IUP_CLOSE will be
    # processed. Affects IupCanvas
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB")))

proc `killfocus_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: FlatList_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FlatList_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `multiselect_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle, value: cstring): cint {.cdecl.}) {.cdecl.} =
    # MULTISELECT_CB: Action generated when the state of an item in
    # the multiple selection list is interactively changed. But it is
    # called only when the interaction is over. int function (Ihandle
    # *ih, char *value); [in C]ih:multiselect_cb(value: string) ->
    # (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("MULTISELECT_CB"), cast[Icallback](cb))

proc `multiselect_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle, value: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MULTISELECT_CB"), cast[Icallback](cb))

proc `multiselect_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MULTISELECT_CB")))

proc `postmessage_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `scroll_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    # SCROLL_CB SCROLL_CB Called when some manipulation is made to the
    # scrollbar. The canvas is automatically redrawn only if this
    # callback is NOT defined. (GTK 2.8) Also the POSX and POSY values
    # will not be correctly updated for older GTK versions. In Ubuntu,
    # when liboverlay-scrollbar is enabled (the new tiny auto-hide
    # scrollbar) only the IUP_SBPOSV and IUP_SBPOSH codes are used.
    # Callback int function(Ihandle *ih, int op, float posx, float
    # posy); [in C] ih:scroll_cb(op, posx, posy: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. op: indicates the operation performed on the
    # scrollbar. If the manipulation was made on the vertical
    # scrollbar, it can have the following values: IUP_SBUP - line up
    # IUP_SBDN - line down IUP_SBPGUP - page up IUP_SBPGDN - page down
    # IUP_SBPOSV - vertical positioning IUP_SBDRAGV - vertical drag If
    # it was on the horizontal scrollbar, the following values are
    # valid: IUP_SBLEFT - column left IUP_SBRIGHT - column right
    # IUP_SBPGLEFT - page left IUP_SBPGRIGHT - page right IUP_SBPOSH -
    # horizontal positioning IUP_SBDRAGH - horizontal drag posx, posy:
    # the same as the ACTION canvas callback (corresponding to the
    # values of attributes POSX and POSY). Notes IUP_SBDRAGH and
    # IUP_SBDRAGV are not supported in GTK. During drag IUP_SBPOSH and
    # IUP_SBPOSV are used. In Windows, after a drag when mouse is
    # released IUP_SBPOSH or IUP_SBPOSV are called. Affects IupCanvas,
    # IupGLCanvas, SCROLLBAR
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SCROLL_CB")))

proc `unmap_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `valuechanged_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # VALUECHANGED_CB: Called after the selection was interactively
    # changed. int function(Ihandle *ih); [in C]ih:valuechanged_cb()
    # -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB")))

proc `wheel_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # WHEEL_CB WHEEL_CB Action generated when the mouse wheel is
    # rotated. If this callback is not defined the wheel will
    # automatically scroll the canvas in the vertical direction by
    # some lines, the SCROLL_CB callback if defined will be called
    # with the IUP_SBDRAGV operation. Callback int function(Ihandle
    # *ih, float delta, int x, int y, char *status); [in C]
    # ih:wheel_cb(delta, x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. delta: the amount the wheel was rotated in notches.
    # x, y: position in the canvas where the event has occurred, in
    # pixels. status: status of mouse buttons and certain keyboard
    # keys at the moment the event was generated. The same macros used
    # for BUTTON_CB can be used for this status. Notes In Motif and
    # GTK delta is always 1 or -1. In Windows is some situations delta
    # can reach the value of two. In the future with more precise
    # wheels this increment can be changed. Affects IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WHEEL_CB")))

proc `wom_cb=`*(ih: FlatList_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # WOM_CB WOM_CB Action generated when an audio device receives an
    # event. [Windows Only] Callback int function(Ihandle *ih, int
    # state); [in C] ih:wom_cb(state: number) -> (ret: number) [in
    # Lua] ih: identifies the element that activated the event. state:
    # can be opening=1, done=0, or closing=-1. Notes This callback is
    # used to syncronize video playback with audio. It is sent when
    # the audio device: Message Description opening is opened by using
    # the waveOutOpen function. done is finished with a data block
    # sent by using the waveOutWrite function. closing is closed by
    # using the waveOutClose function. You must use the HWND attribute
    # when calling waveOutOpen in the dwCallback parameter and set
    # fdwOpen to CALLBACK_WINDOW. Affects IupDialog, IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: FlatList_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: FlatList_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WOM_CB")))

proc FlatScrollBox*(child: IUPhandle_t): FlatScrollBox_t {.cdecl.} =
    # Creates a native container that allows its child to be scrolled.
    # It inherits from IupCanvas. The difference from IupScrollBox is
    # that its scrollbars are drawn.
    return FlatScrollBox_t(niupc.FlatScrollBox(cast[PIhandle](child)))

proc `active=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `arrowimages=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGES"), cstring(value))

proc `arrowimages`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGES"), cstring(value))

proc `arrowimages=`*(ih: FlatScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGES"), cstring(&"{x}"))

proc `arrowimages`*(ih: FlatScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGES"), cstring(&"{x}"))

proc `arrowimages`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGES"))

proc `backingstore=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore=`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE")) == "YES"

proc `bgcolor=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    # BGCOLOR: will always use the background color of the native
    # parent.
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: FlatScrollBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FlatScrollBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `canfocus=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    # CANFOCUS: is set to NO.
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `canvasbox=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    # CANVASBOX (non inheritable): enable the behavior of a canvas box
    # instead of a regular container. This will affect the EXPAND
    # attribute, the Natural size computation, and child layout
    # distribution. Can be Yes or No. Default: No.
    SetAttribute(cast[PIhandle](ih), cstring("CANVASBOX"), cstring(value))

proc `canvasbox`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANVASBOX"), cstring(value))

proc `canvasbox=`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANVASBOX"), cstring((if yes: "YES" else: "NO")))

proc `canvasbox`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANVASBOX"), cstring((if yes: "YES" else: "NO")))

proc `canvasbox`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANVASBOX")) == "YES"

proc `charsize`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `childoffset=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    # CHILDOFFSET: Allow to specify a position offset for the child.
    # Available for native containers only. It will not affect the
    # natural size, and allows to position controls outside the client
    # area. Format "dxxdy", where dx and dy are integer values
    # corresponding to the horizontal and vertical offsets,
    # respectively, in pixels. Default: 0x0.
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset=`*(ih: FlatScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: FlatScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"))

proc `clientoffset`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `cursor=`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `dragdrop=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary flatscrollbox
proc `dragtypes`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

# TODO unknown: flatscrollbox DRAWABLE Unknown Binary
proc `drawable`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWABLE"))

proc `drawbgcolor=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor=`*(ih: FlatScrollBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: FlatScrollBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"))

proc `drawcolor=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor=`*(ih: FlatScrollBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: FlatScrollBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"))

proc `drawdriver`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWDRIVER"))

proc `drawfont=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

proc `drawfont`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

# TODO ??? String Binary flatscrollbox
proc `drawfont`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"))

proc `drawlinewidth=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth=`*(ih: FlatScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: FlatScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"))

proc `drawmakeinactive=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive=`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE")) == "YES"

proc `drawsize`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSIZE"))

proc `drawstyle=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"))

proc `drawtextalignment=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"))

proc `drawtextclip=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip=`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP")) == "YES"

proc `drawtextellipsis=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis=`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS")) == "YES"

proc `drawtextlayoutcenter=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter=`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER")) == "YES"

proc `drawtextorientation=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation=`*(ih: FlatScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: FlatScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"))

proc `drawtextwrap=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap=`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP")) == "YES"

proc `dropfilestarget=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary flatscrollbox
proc `droptypes`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `dx=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx=`*(ih: FlatScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: FlatScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DX"))

proc `dy=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy=`*(ih: FlatScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: FlatScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DY"))

proc `expand=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable): The default value is "YES".
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: FlatScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FlatScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

# TODO unknown: flatscrollbox FLATSCROLLBAR Unknown Binary
proc `flatscrollbar`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLATSCROLLBAR"))

proc `floating=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

# TODO unknown: flatscrollbox FLOATINGDELAY Unknown Binary
proc `floatingdelay`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATINGDELAY"))

proc `font=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary flatscrollbox
proc `font`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary flatscrollbox
proc `fontface`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: FlatScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FlatScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary flatscrollbox
proc `fontstyle`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary flatscrollbox
proc `handlename`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `layoutdrag=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    # LAYOUTDRAG (non inheritable): When the scrollbar is moved
    # automatically update the children layout. Default: YES. If set
    # to NO then the layout will be updated only when the mouse drag
    # is released.
    SetAttribute(cast[PIhandle](ih), cstring("LAYOUTDRAG"), cstring(value))

proc `layoutdrag`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LAYOUTDRAG"), cstring(value))

proc `layoutdrag=`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LAYOUTDRAG"), cstring((if yes: "YES" else: "NO")))

proc `layoutdrag`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LAYOUTDRAG"), cstring((if yes: "YES" else: "NO")))

proc `layoutdrag`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LAYOUTDRAG")) == "YES"

proc `linex=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex=`*(ih: FlatScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: FlatScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEX"))

proc `liney=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney=`*(ih: FlatScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: FlatScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEY"))

proc `maxsize=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: FlatScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FlatScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: FlatScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FlatScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary flatscrollbox
proc `name`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary flatscrollbox
proc `normalizergroup`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary flatscrollbox
proc `ntheme`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: flatscrollbox PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: flatscrollbox PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: FlatScrollBox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FlatScrollBox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `posx=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx=`*(ih: FlatScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: FlatScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSX"))

proc `posy=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy=`*(ih: FlatScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: FlatScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSY"))

proc `propagatefocus=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: FlatScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FlatScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

# TODO unknown: flatscrollbox SB_BACKCOLOR Unknown Binary
proc `sb_backcolor`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_BACKCOLOR"))

# TODO unknown: flatscrollbox SB_FORECOLOR Unknown Binary
proc `sb_forecolor`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_FORECOLOR"))

# TODO unknown: flatscrollbox SB_HIGHCOLOR Unknown Binary
proc `sb_highcolor`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_HIGHCOLOR"))

proc `sb_imagebottom=`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOM"), cast[PIhandle](handle))

proc `sb_imagebottom`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOM"), cast[PIhandle](handle))

proc `sb_imagebottom`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOM"))

proc `sb_imagebottomhighlight=`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagebottomhighlight`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagebottomhighlight`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMHIGHLIGHT"))

proc `sb_imagebottominactive=`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMINACTIVE"), cast[PIhandle](handle))

proc `sb_imagebottominactive`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMINACTIVE"), cast[PIhandle](handle))

proc `sb_imagebottominactive`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMINACTIVE"))

proc `sb_imagebottompress=`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMPRESS"), cast[PIhandle](handle))

proc `sb_imagebottompress`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMPRESS"), cast[PIhandle](handle))

proc `sb_imagebottompress`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMPRESS"))

proc `sb_imageleft=`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFT"), cast[PIhandle](handle))

proc `sb_imageleft`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFT"), cast[PIhandle](handle))

proc `sb_imageleft`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGELEFT"))

proc `sb_imagelefthighlight=`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFTHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagelefthighlight`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFTHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagelefthighlight`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGELEFTHIGHLIGHT"))

proc `sb_imageleftinactive=`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFTINACTIVE"), cast[PIhandle](handle))

proc `sb_imageleftinactive`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFTINACTIVE"), cast[PIhandle](handle))

proc `sb_imageleftinactive`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGELEFTINACTIVE"))

proc `sb_imageleftpress=`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFTPRESS"), cast[PIhandle](handle))

proc `sb_imageleftpress`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFTPRESS"), cast[PIhandle](handle))

proc `sb_imageleftpress`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGELEFTPRESS"))

proc `sb_imageright=`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHT"), cast[PIhandle](handle))

proc `sb_imageright`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHT"), cast[PIhandle](handle))

proc `sb_imageright`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGERIGHT"))

proc `sb_imagerighthighlight=`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHTHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagerighthighlight`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHTHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagerighthighlight`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGERIGHTHIGHLIGHT"))

proc `sb_imagerightinactive=`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHTINACTIVE"), cast[PIhandle](handle))

proc `sb_imagerightinactive`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHTINACTIVE"), cast[PIhandle](handle))

proc `sb_imagerightinactive`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGERIGHTINACTIVE"))

proc `sb_imagerightpress=`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHTPRESS"), cast[PIhandle](handle))

proc `sb_imagerightpress`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHTPRESS"), cast[PIhandle](handle))

proc `sb_imagerightpress`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGERIGHTPRESS"))

proc `sb_imagetop=`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOP"), cast[PIhandle](handle))

proc `sb_imagetop`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOP"), cast[PIhandle](handle))

proc `sb_imagetop`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGETOP"))

proc `sb_imagetophighlight=`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOPHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagetophighlight`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOPHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagetophighlight`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGETOPHIGHLIGHT"))

proc `sb_imagetopinactive=`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOPINACTIVE"), cast[PIhandle](handle))

proc `sb_imagetopinactive`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOPINACTIVE"), cast[PIhandle](handle))

proc `sb_imagetopinactive`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGETOPINACTIVE"))

proc `sb_imagetoppress=`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOPPRESS"), cast[PIhandle](handle))

proc `sb_imagetoppress`*(ih: FlatScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOPPRESS"), cast[PIhandle](handle))

proc `sb_imagetoppress`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGETOPPRESS"))

# TODO unknown: flatscrollbox SB_PRESSCOLOR Unknown Binary
proc `sb_presscolor`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_PRESSCOLOR"))

proc `sb_resize`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_RESIZE"))

proc `screenposition`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `scrollbar`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR")) == "YES"

# TODO unknown: flatscrollbox SCROLLBARSIZE Unknown Binary
proc `scrollbarsize`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBARSIZE"))

proc `scrollto=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    # SCROLLTO (write-only): position the scroll at the given x,y
    # coordinates relative to the box top-left corner. Format "x,y".
    # Value can also be TOP or BOTTOM for a vertical scroll to the top
    # or to the bottom of the scroll range.
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTO"), cstring(value))

proc `scrollto`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTO"), cstring(value))

proc `scrollto=`*(ih: FlatScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTO"), cstring(&"{x}"))

proc `scrollto`*(ih: FlatScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTO"), cstring(&"{x}"))

proc `scrolltochild=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    # SCROLLTOCHILD (write-only): position the scroll at the top-left
    # corner of the given child located by its name. Use IupSetHandle
    # or IupSetAttributeHandle to associate an Ihandle* to a name. The
    # child must be contained in the Scrollbox hierarchy.
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTOCHILD"), cstring(value))

proc `scrolltochild`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTOCHILD"), cstring(value))

# TODO ??? String Binary flatscrollbox
proc `scrolltochild_handle=`*(ih: FlatScrollBox_t, handle: User_t) {.cdecl.} =
    # SCROLLTOCHILD_HANDLE (write-only): same as SCROLLTOCHILD but
    # directly using the child handle.
    SetAttributeHandle(cast[PIhandle](ih), cstring("SCROLLTOCHILD_HANDLE"), cast[PIhandle](handle))

proc `scrolltochild_handle`*(ih: FlatScrollBox_t, handle: User_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SCROLLTOCHILD_HANDLE"), cast[PIhandle](handle))

# TODO unknown: flatscrollbox SHOWARROWS Unknown Binary
proc `showarrows`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWARROWS"))

# TODO unknown: flatscrollbox SHOWFLOATING Unknown Binary
proc `showfloating`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWFLOATING"))

# TODO unknown: flatscrollbox SHOWTRANSPARENT Unknown Binary
proc `showtransparent`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWTRANSPARENT"))

proc `size=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: FlatScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FlatScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary flatscrollbox
proc `theme`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary flatscrollbox
proc `tip`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: FlatScrollBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FlatScrollBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: FlatScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FlatScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: FlatScrollBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FlatScrollBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary flatscrollbox
proc `tipicon`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary flatscrollbox
proc `tipmarkup`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: FlatScrollBox_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FlatScrollBox_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `touch=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch=`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOUCH")) == "YES"

proc `usersize=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: FlatScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FlatScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wheeldropfocus=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    # WHEELDROPFOCUS: set to Yes. (since 3.28)
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus=`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: FlatScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS")) == "YES"

proc `wid`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

proc `xautohide`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE")) == "YES"

proc `xdisplay`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XDISPLAY"))

# TODO unknown: flatscrollbox XFONTID Unknown Binary
proc `xfontid`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `xhidden`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XHIDDEN")) == "YES"

proc `xmax=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax=`*(ih: FlatScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: FlatScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMAX"))

proc `xmin=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin=`*(ih: FlatScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: FlatScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMIN"))

# TODO unknown: flatscrollbox XWINDOW Unknown Binary
proc `xwindow`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `yautohide`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE")) == "YES"

proc `yhidden`*(ih: FlatScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YHIDDEN")) == "YES"

proc `ymax=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax=`*(ih: FlatScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: FlatScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMAX"))

proc `ymin=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin=`*(ih: FlatScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: FlatScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: FlatScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMIN"))

proc `zorder=`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: FlatScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `destroy_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: FlatScrollBox_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FlatScrollBox_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `focus_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `keypress_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    # KEYPRESS_CB KEYPRESS_CB Action generated when a key is pressed
    # or released. If the key is pressed and held several calls will
    # occur. It is called after the callback K_ANY is processed.
    # Callback int function(Ihandle *ih, int c, int press); [in C]
    # ih:keypress_cb(c, press: number) -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. c:
    # identifier of typed key. Please refer to the Keyboard Codes
    # table for a list of possible values. press: 1 is the user
    # pressed the key or 0 otherwise. Returns: If IUP_IGNORE is
    # returned the key is ignored by the system. IUP_CLOSE will be
    # processed. Affects IupCanvas
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB")))

proc `killfocus_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `layoutupdate_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LAYOUTUPDATE_CB: Action generated when the layout is updated
    # after a scroll operation. (since 3.24)
    SetCallback(cast[PIhandle](ih), cstring("LAYOUTUPDATE_CB"), cast[Icallback](cb))

proc `layoutupdate_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LAYOUTUPDATE_CB"), cast[Icallback](cb))

proc `layoutupdate_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LAYOUTUPDATE_CB")))

proc `ldestroy_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `postmessage_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `scroll_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    # SCROLL_CB SCROLL_CB Called when some manipulation is made to the
    # scrollbar. The canvas is automatically redrawn only if this
    # callback is NOT defined. (GTK 2.8) Also the POSX and POSY values
    # will not be correctly updated for older GTK versions. In Ubuntu,
    # when liboverlay-scrollbar is enabled (the new tiny auto-hide
    # scrollbar) only the IUP_SBPOSV and IUP_SBPOSH codes are used.
    # Callback int function(Ihandle *ih, int op, float posx, float
    # posy); [in C] ih:scroll_cb(op, posx, posy: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. op: indicates the operation performed on the
    # scrollbar. If the manipulation was made on the vertical
    # scrollbar, it can have the following values: IUP_SBUP - line up
    # IUP_SBDN - line down IUP_SBPGUP - page up IUP_SBPGDN - page down
    # IUP_SBPOSV - vertical positioning IUP_SBDRAGV - vertical drag If
    # it was on the horizontal scrollbar, the following values are
    # valid: IUP_SBLEFT - column left IUP_SBRIGHT - column right
    # IUP_SBPGLEFT - page left IUP_SBPGRIGHT - page right IUP_SBPOSH -
    # horizontal positioning IUP_SBDRAGH - horizontal drag posx, posy:
    # the same as the ACTION canvas callback (corresponding to the
    # values of attributes POSX and POSY). Notes IUP_SBDRAGH and
    # IUP_SBDRAGV are not supported in GTK. During drag IUP_SBPOSH and
    # IUP_SBPOSV are used. In Windows, after a drag when mouse is
    # released IUP_SBPOSH or IUP_SBPOSV are called. Affects IupCanvas,
    # IupGLCanvas, SCROLLBAR
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SCROLL_CB")))

proc `unmap_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `wheel_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # WHEEL_CB WHEEL_CB Action generated when the mouse wheel is
    # rotated. If this callback is not defined the wheel will
    # automatically scroll the canvas in the vertical direction by
    # some lines, the SCROLL_CB callback if defined will be called
    # with the IUP_SBDRAGV operation. Callback int function(Ihandle
    # *ih, float delta, int x, int y, char *status); [in C]
    # ih:wheel_cb(delta, x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. delta: the amount the wheel was rotated in notches.
    # x, y: position in the canvas where the event has occurred, in
    # pixels. status: status of mouse buttons and certain keyboard
    # keys at the moment the event was generated. The same macros used
    # for BUTTON_CB can be used for this status. Notes In Motif and
    # GTK delta is always 1 or -1. In Windows is some situations delta
    # can reach the value of two. In the future with more precise
    # wheels this increment can be changed. Affects IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WHEEL_CB")))

proc `wom_cb=`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # WOM_CB WOM_CB Action generated when an audio device receives an
    # event. [Windows Only] Callback int function(Ihandle *ih, int
    # state); [in C] ih:wom_cb(state: number) -> (ret: number) [in
    # Lua] ih: identifies the element that activated the event. state:
    # can be opening=1, done=0, or closing=-1. Notes This callback is
    # used to syncronize video playback with audio. It is sent when
    # the audio device: Message Description opening is opened by using
    # the waveOutOpen function. done is finished with a data block
    # sent by using the waveOutWrite function. closing is closed by
    # using the waveOutClose function. You must use the HWND attribute
    # when calling waveOutOpen in the dwCallback parameter and set
    # fdwOpen to CALLBACK_WINDOW. Affects IupDialog, IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: FlatScrollBox_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: FlatScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WOM_CB")))

proc FlatSeparator*(): FlatSeparator_t {.cdecl.} =
    # Creates an interface element that is a Separator, but it does
    # not have native decorations. It inherits from IupCanvas.
    return FlatSeparator_t(niupc.FlatSeparator())

proc `active=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `backingstore=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE")) == "YES"

proc `barsize=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    # BARSIZE (non inheritable): controls the size of the separator in
    # the opposite direction of its orientation. Default: 5.
    SetAttribute(cast[PIhandle](ih), cstring("BARSIZE"), cstring(value))

proc `barsize`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BARSIZE"), cstring(value))

proc `barsize=`*(ih: FlatSeparator_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BARSIZE"), cstring(&"{x}"))

proc `barsize`*(ih: FlatSeparator_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BARSIZE"), cstring(&"{x}"))

proc `barsize`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BARSIZE"))

proc `bgcolor=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: FlatSeparator_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FlatSeparator_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `canfocus=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `color=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    # COLOR (non inheritable): Changes the color of the separator.
    # Default: "192 192 192".
    SetAttribute(cast[PIhandle](ih), cstring("COLOR"), cstring(value))

proc `color`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COLOR"), cstring(value))

proc `color=`*(ih: FlatSeparator_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `color`*(ih: FlatSeparator_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `color`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("COLOR"))

proc `cursor=`*(ih: FlatSeparator_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FlatSeparator_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `dragdrop=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary flatseparator
proc `dragtypes`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

# TODO unknown: flatseparator DRAWABLE Unknown Binary
proc `drawable`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWABLE"))

proc `drawbgcolor=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor=`*(ih: FlatSeparator_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: FlatSeparator_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"))

proc `drawcolor=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor=`*(ih: FlatSeparator_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: FlatSeparator_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"))

proc `drawdriver`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWDRIVER"))

proc `drawfont=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

proc `drawfont`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

# TODO ??? String Binary flatseparator
proc `drawfont`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"))

proc `drawlinewidth=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth=`*(ih: FlatSeparator_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: FlatSeparator_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"))

proc `drawmakeinactive=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE")) == "YES"

proc `drawsize`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSIZE"))

proc `drawstyle=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"))

proc `drawtextalignment=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"))

proc `drawtextclip=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP")) == "YES"

proc `drawtextellipsis=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS")) == "YES"

proc `drawtextlayoutcenter=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER")) == "YES"

proc `drawtextorientation=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation=`*(ih: FlatSeparator_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: FlatSeparator_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"))

proc `drawtextwrap=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP")) == "YES"

proc `dropfilestarget=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary flatseparator
proc `droptypes`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `dx=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx=`*(ih: FlatSeparator_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: FlatSeparator_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DX"))

proc `dy=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy=`*(ih: FlatSeparator_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: FlatSeparator_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DY"))

proc `expand=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable): Its behavior depends on the
    # orientation. It will expand in the direction of the separator,
    # but occupying only the available space.
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: FlatSeparator_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FlatSeparator_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    # FONT, SIZE, RASTERSIZE, CLIENTSIZE, CLIENTOFFSET, POSITION,
    # MINSIZE, MAXSIZE, THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary flatseparator
proc `font`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary flatseparator
proc `fontface`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: FlatSeparator_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FlatSeparator_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary flatseparator
proc `fontstyle`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary flatseparator
proc `handlename`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `linex=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex=`*(ih: FlatSeparator_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: FlatSeparator_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEX"))

proc `liney=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney=`*(ih: FlatSeparator_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: FlatSeparator_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEY"))

proc `maxsize=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: FlatSeparator_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FlatSeparator_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: FlatSeparator_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FlatSeparator_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary flatseparator
proc `name`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary flatseparator
proc `normalizergroup`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary flatseparator
proc `ntheme`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `orientation=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    # ORIENTATION (non inheritable): Indicates the orientation of the
    # separator. Possible values are "VERTICAL" or "HORIZONTAL".
    # Default: "VERTICAL".
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"))

# TODO unknown: flatseparator PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: flatseparator PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: FlatSeparator_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FlatSeparator_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `posx=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx=`*(ih: FlatSeparator_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: FlatSeparator_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSX"))

proc `posy=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy=`*(ih: FlatSeparator_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: FlatSeparator_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSY"))

proc `propagatefocus=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: FlatSeparator_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FlatSeparator_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `sb_resize`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_RESIZE"))

proc `screenposition`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `scrollbar=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR")) == "YES"

proc `size=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: FlatSeparator_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FlatSeparator_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

# TODO unknown: flatseparator STYLE Unknown Binary
proc `style`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("STYLE"))

proc `theme=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary flatseparator
proc `theme`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary flatseparator
proc `tip`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: FlatSeparator_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FlatSeparator_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: FlatSeparator_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FlatSeparator_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: FlatSeparator_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FlatSeparator_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary flatseparator
proc `tipicon`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary flatseparator
proc `tipmarkup`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: FlatSeparator_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FlatSeparator_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `touch=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOUCH")) == "YES"

proc `usersize=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: FlatSeparator_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FlatSeparator_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wheeldropfocus=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS")) == "YES"

proc `wid`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

proc `xautohide=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE")) == "YES"

proc `xdisplay`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XDISPLAY"))

# TODO unknown: flatseparator XFONTID Unknown Binary
proc `xfontid`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `xhidden`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XHIDDEN")) == "YES"

proc `xmax=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax=`*(ih: FlatSeparator_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: FlatSeparator_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMAX"))

proc `xmin=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin=`*(ih: FlatSeparator_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: FlatSeparator_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMIN"))

# TODO unknown: flatseparator XWINDOW Unknown Binary
proc `xwindow`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `yautohide=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide=`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: FlatSeparator_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE")) == "YES"

proc `yhidden`*(ih: FlatSeparator_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YHIDDEN")) == "YES"

proc `ymax=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax=`*(ih: FlatSeparator_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: FlatSeparator_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMAX"))

proc `ymin=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin=`*(ih: FlatSeparator_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: FlatSeparator_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: FlatSeparator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMIN"))

proc `zorder=`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: FlatSeparator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `destroy_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: FlatSeparator_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FlatSeparator_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `focus_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `keypress_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    # KEYPRESS_CB KEYPRESS_CB Action generated when a key is pressed
    # or released. If the key is pressed and held several calls will
    # occur. It is called after the callback K_ANY is processed.
    # Callback int function(Ihandle *ih, int c, int press); [in C]
    # ih:keypress_cb(c, press: number) -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. c:
    # identifier of typed key. Please refer to the Keyboard Codes
    # table for a list of possible values. press: 1 is the user
    # pressed the key or 0 otherwise. Returns: If IUP_IGNORE is
    # returned the key is ignored by the system. IUP_CLOSE will be
    # processed. Affects IupCanvas
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB")))

proc `killfocus_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `postmessage_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `scroll_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    # SCROLL_CB SCROLL_CB Called when some manipulation is made to the
    # scrollbar. The canvas is automatically redrawn only if this
    # callback is NOT defined. (GTK 2.8) Also the POSX and POSY values
    # will not be correctly updated for older GTK versions. In Ubuntu,
    # when liboverlay-scrollbar is enabled (the new tiny auto-hide
    # scrollbar) only the IUP_SBPOSV and IUP_SBPOSH codes are used.
    # Callback int function(Ihandle *ih, int op, float posx, float
    # posy); [in C] ih:scroll_cb(op, posx, posy: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. op: indicates the operation performed on the
    # scrollbar. If the manipulation was made on the vertical
    # scrollbar, it can have the following values: IUP_SBUP - line up
    # IUP_SBDN - line down IUP_SBPGUP - page up IUP_SBPGDN - page down
    # IUP_SBPOSV - vertical positioning IUP_SBDRAGV - vertical drag If
    # it was on the horizontal scrollbar, the following values are
    # valid: IUP_SBLEFT - column left IUP_SBRIGHT - column right
    # IUP_SBPGLEFT - page left IUP_SBPGRIGHT - page right IUP_SBPOSH -
    # horizontal positioning IUP_SBDRAGH - horizontal drag posx, posy:
    # the same as the ACTION canvas callback (corresponding to the
    # values of attributes POSX and POSY). Notes IUP_SBDRAGH and
    # IUP_SBDRAGV are not supported in GTK. During drag IUP_SBPOSH and
    # IUP_SBPOSV are used. In Windows, after a drag when mouse is
    # released IUP_SBPOSH or IUP_SBPOSV are called. Affects IupCanvas,
    # IupGLCanvas, SCROLLBAR
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SCROLL_CB")))

proc `unmap_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `wheel_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # WHEEL_CB WHEEL_CB Action generated when the mouse wheel is
    # rotated. If this callback is not defined the wheel will
    # automatically scroll the canvas in the vertical direction by
    # some lines, the SCROLL_CB callback if defined will be called
    # with the IUP_SBDRAGV operation. Callback int function(Ihandle
    # *ih, float delta, int x, int y, char *status); [in C]
    # ih:wheel_cb(delta, x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. delta: the amount the wheel was rotated in notches.
    # x, y: position in the canvas where the event has occurred, in
    # pixels. status: status of mouse buttons and certain keyboard
    # keys at the moment the event was generated. The same macros used
    # for BUTTON_CB can be used for this status. Notes In Motif and
    # GTK delta is always 1 or -1. In Windows is some situations delta
    # can reach the value of two. In the future with more precise
    # wheels this increment can be changed. Affects IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WHEEL_CB")))

proc `wom_cb=`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # WOM_CB WOM_CB Action generated when an audio device receives an
    # event. [Windows Only] Callback int function(Ihandle *ih, int
    # state); [in C] ih:wom_cb(state: number) -> (ret: number) [in
    # Lua] ih: identifies the element that activated the event. state:
    # can be opening=1, done=0, or closing=-1. Notes This callback is
    # used to syncronize video playback with audio. It is sent when
    # the audio device: Message Description opening is opened by using
    # the waveOutOpen function. done is finished with a data block
    # sent by using the waveOutWrite function. closing is closed by
    # using the waveOutClose function. You must use the HWND attribute
    # when calling waveOutOpen in the dwCallback parameter and set
    # fdwOpen to CALLBACK_WINDOW. Affects IupDialog, IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: FlatSeparator_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: FlatSeparator_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WOM_CB")))

macro FlatTabs*(args: varargs[untyped]): FlatTabs_t =
    # Creates a native container for composing elements in hidden
    # layers with only one layer visible (just like IupZbox), but its
    # visibility can be interactively controlled. The interaction is
    # done in a line of tabs with titles and arranged according to the
    # tab type. Also known as Notebook in native systems. Identical to
    # the IupTabs control but the decorations and buttons are manually
    # drawn. It inherits from IupCanvas.


    result = nnkCall.newTree(
        nnkDotExpr.newTree(
            newIdentNode("niup"),
            newIdentNode("FlatTabs_t")
          ),
       )
    let inner = nnkCall.newTree(
            newIdentNode("FlatTabs")
          )

    if args.len > 0:
        for i in 0 ..< args.len:
          inner.add nnkCast.newTree(newIdentNode("PIhandle"), args[i])
    inner.add newNilLit()
    result.add inner


proc `active=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    # ACTIVE, FONT, SCREENPOSITION, POSITION, CLIENTSIZE,
    # CLIENTOFFSET, MINSIZE, MAXSIZE, WID, TIP, RASTERSIZE, ZORDER,
    # VISIBLE, THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `backingstore=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE")) == "YES"

proc `bgcolor=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    # BGCOLOR: background color for the current Tab and the children.
    # Default: "255 255 255". It is non inheritable, but when set will
    # internally propagate to the children (since 3.25).
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: FlatTabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FlatTabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `canfocus=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    # CANFOCUS (creation only) (non inheritable): enables the focus
    # traversal of the control. Default: YES.
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `childoffset=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    # CHILDOFFSET: Allow to specify a position offset for the child.
    # Available for native containers only. It will not affect the
    # natural size, and allows to position controls outside the client
    # area. Format "dxxdy", where dx and dy are integer values
    # corresponding to the horizontal and vertical offsets,
    # respectively, in pixels. Default: 0x0.
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset=`*(ih: FlatTabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: FlatTabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"))

proc `childsizeall=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    # CHILDSIZEALL (non inheritable): compute the natural size using
    # all children. If set to NO will compute using only the current
    # tab. Default: Yes. (since 3.27)
    SetAttribute(cast[PIhandle](ih), cstring("CHILDSIZEALL"), cstring(value))

proc `childsizeall`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDSIZEALL"), cstring(value))

proc `childsizeall=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDSIZEALL"), cstring((if yes: "YES" else: "NO")))

proc `childsizeall`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDSIZEALL"), cstring((if yes: "YES" else: "NO")))

proc `childsizeall`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHILDSIZEALL")) == "YES"

proc `clientoffset`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

# TODO unknown: flattabs CLOSEHIGHCOLOR Unknown Binary
proc `closehighcolor`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLOSEHIGHCOLOR"))

proc `closeimage=`*(ih: FlatTabs_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # CLOSEIMAGE: image name to be used in the close button. Use
    # IupSetHandle or IupSetAttributeHandle to associate an image to a
    # name. n starts at 0. See also IupImage. Default: "IMGFLATCLOSE".
    SetAttributeHandle(cast[PIhandle](ih), cstring("CLOSEIMAGE"), cast[PIhandle](handle))

proc `closeimage`*(ih: FlatTabs_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CLOSEIMAGE"), cast[PIhandle](handle))

proc `closeimage`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLOSEIMAGE"))

proc `closeimagehighlight=`*(ih: FlatTabs_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # CLOSEIMAGEHIGHLIGHT: image name to be used in the close button
    # in highlight state.
    SetAttributeHandle(cast[PIhandle](ih), cstring("CLOSEIMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `closeimagehighlight`*(ih: FlatTabs_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CLOSEIMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `closeimagehighlight`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLOSEIMAGEHIGHLIGHT"))

proc `closeimageinactive=`*(ih: FlatTabs_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # CLOSEIMAGEINACTIVE: image name to be used in the close button in
    # inactive state. If it is not defined then the CLOSEIMAGE is used
    # and its colors will be replaced by a modified version creating
    # the disabled effect. (since 3.22)
    SetAttributeHandle(cast[PIhandle](ih), cstring("CLOSEIMAGEINACTIVE"), cast[PIhandle](handle))

proc `closeimageinactive`*(ih: FlatTabs_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CLOSEIMAGEINACTIVE"), cast[PIhandle](handle))

proc `closeimageinactive`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLOSEIMAGEINACTIVE"))

proc `closeimagepress=`*(ih: FlatTabs_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # CLOSEIMAGEPRESS: image name to be used in the close button in
    # pressed state. Default: "IMGFLATCLOSEPRESS".
    SetAttributeHandle(cast[PIhandle](ih), cstring("CLOSEIMAGEPRESS"), cast[PIhandle](handle))

proc `closeimagepress`*(ih: FlatTabs_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CLOSEIMAGEPRESS"), cast[PIhandle](handle))

proc `closeimagepress`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLOSEIMAGEPRESS"))

# TODO unknown: flattabs CLOSEPRESSCOLOR Unknown Binary
proc `closepresscolor`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLOSEPRESSCOLOR"))

proc `count`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("COUNT"))

proc `cursor=`*(ih: FlatTabs_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FlatTabs_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `dragdrop=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary flattabs
proc `dragtypes`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

# TODO unknown: flattabs DRAWABLE Unknown Binary
proc `drawable`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWABLE"))

proc `drawbgcolor=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor=`*(ih: FlatTabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: FlatTabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"))

proc `drawcolor=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor=`*(ih: FlatTabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: FlatTabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"))

proc `drawdriver`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWDRIVER"))

proc `drawfont=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

proc `drawfont`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

# TODO ??? String Binary flattabs
proc `drawfont`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"))

proc `drawlinewidth=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth=`*(ih: FlatTabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: FlatTabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"))

proc `drawmakeinactive=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE")) == "YES"

proc `drawsize`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSIZE"))

proc `drawstyle=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"))

proc `drawtextalignment=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"))

proc `drawtextclip=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP")) == "YES"

proc `drawtextellipsis=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS")) == "YES"

proc `drawtextlayoutcenter=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER")) == "YES"

proc `drawtextorientation=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation=`*(ih: FlatTabs_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: FlatTabs_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"))

proc `drawtextwrap=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP")) == "YES"

proc `dropfilestarget=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary flattabs
proc `droptypes`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `dx=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx=`*(ih: FlatTabs_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: FlatTabs_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DX"))

proc `dy=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy=`*(ih: FlatTabs_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: FlatTabs_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DY"))

proc `expand=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    # EXPAND: The default value is "YES".
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

# TODO unknown: flattabs EXPANDBUTTON Unknown Binary
proc `expandbutton`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDBUTTON"))

# TODO unknown: flattabs EXPANDBUTTONPOS Unknown Binary
proc `expandbuttonpos`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDBUTTONPOS"))

# TODO unknown: flattabs EXPANDBUTTONSTATE Unknown Binary
proc `expandbuttonstate`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDBUTTONSTATE"))

proc `expandweight=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: FlatTabs_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FlatTabs_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

# TODO getter flattabs EXTRAACTIVE
# TODO getter flattabs EXTRAALIGNMENT
# TODO getter flattabs EXTRABORDERCOLOR
# TODO getter flattabs EXTRABORDERWIDTH
proc `extrabuttons=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    # EXTRABUTTONS: sets the number of extra image buttons at right in
    # the free space area. There can be any number of buttons. See the
    # EXTRABUTTON_CB callback. Default: 0.
    SetAttribute(cast[PIhandle](ih), cstring("EXTRABUTTONS"), cstring(value))

proc `extrabuttons`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXTRABUTTONS"), cstring(value))

proc `extrabuttons=`*(ih: FlatTabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXTRABUTTONS"), cstring(&"{x}"))

proc `extrabuttons`*(ih: FlatTabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXTRABUTTONS"), cstring(&"{x}"))

proc `extrabuttons`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXTRABUTTONS"))

# TODO getter flattabs EXTRAFONT
# TODO getter flattabs EXTRAFORECOLOR
# TODO getter flattabs EXTRAHIGHCOLOR
# TODO getter flattabs EXTRAIMAGE
# TODO getter flattabs EXTRAIMAGEHIGHLIGHT
# TODO getter flattabs EXTRAIMAGEINACTIVE
# TODO getter flattabs EXTRAIMAGEPRESS
# TODO getter flattabs EXTRAPRESSCOLOR
# TODO getter flattabs EXTRASHOWBORDER
# TODO getter flattabs EXTRATIP
# TODO getter flattabs EXTRATITLE
# TODO getter flattabs EXTRATOGGLE
# TODO getter flattabs EXTRAVALUE
# TODO unknown: flattabs FIXEDWIDTH Unknown Binary
proc `fixedwidth`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FIXEDWIDTH"))

proc `floating=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    # FLOATING (non inheritable) (at children only): If a child has
    # FLOATING=YES then its size and position will be ignored by the
    # layout processing. Default: "NO". (since 3.27)
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `focusfeedback=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    # FOCUSFEEDBACK (non inheritable): draw the focus feedback. Can be
    # Yes or No. Default: Yes. (since 3.27)
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring(value))

proc `focusfeedback`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring(value))

proc `focusfeedback=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring((if yes: "YES" else: "NO")))

proc `focusfeedback`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring((if yes: "YES" else: "NO")))

proc `focusfeedback`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK")) == "YES"

proc `font=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary flattabs
proc `font`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary flattabs
proc `fontface`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: FlatTabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FlatTabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary flattabs
proc `fontstyle`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `forecolor=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    # FORECOLOR: text color for the current Tab. Default: "50 150
    # 255".
    SetAttribute(cast[PIhandle](ih), cstring("FORECOLOR"), cstring(value))

proc `forecolor`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FORECOLOR"), cstring(value))

proc `forecolor=`*(ih: FlatTabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FORECOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `forecolor`*(ih: FlatTabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FORECOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `forecolor`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FORECOLOR"))

proc `handlename=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary flattabs
proc `handlename`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `hasfocus`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HASFOCUS")) == "YES"

proc `highcolor=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    # HIGHCOLOR: text color for the highlighted Tab. The current Tab
    # is never highlighted, so it affects only the other tabs. If not
    # defined FORECOLOR will be used.
    SetAttribute(cast[PIhandle](ih), cstring("HIGHCOLOR"), cstring(value))

proc `highcolor`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIGHCOLOR"), cstring(value))

proc `highcolor=`*(ih: FlatTabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIGHCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `highcolor`*(ih: FlatTabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIGHCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `highcolor`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIGHCOLOR"))

proc `linex=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex=`*(ih: FlatTabs_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: FlatTabs_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEX"))

proc `liney=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney=`*(ih: FlatTabs_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: FlatTabs_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEY"))

proc `maxsize=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: FlatTabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FlatTabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: FlatTabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FlatTabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary flattabs
proc `name`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary flattabs
proc `normalizergroup`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary flattabs
proc `ntheme`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: flattabs PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: flattabs PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: FlatTabs_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FlatTabs_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `posx=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx=`*(ih: FlatTabs_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: FlatTabs_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSX"))

proc `posy=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy=`*(ih: FlatTabs_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: FlatTabs_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSY"))

proc `propagatefocus=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    # PROPAGATEFOCUS (non inheritable): enables the focus callback
    # forwarding to the next native parent with FOCUS_CB defined.
    # Default: NO. (since 3.23)
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: FlatTabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FlatTabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `sb_resize`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_RESIZE"))

proc `screenposition`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `scrollbar`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR")) == "YES"

proc `showclose=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    # SHOWCLOSE: enables the close button on each tab. Default value:
    # "NO". By default when closed the tab is hidden. To change that
    # behavior use the TABCLOSE_CB callback.
    SetAttribute(cast[PIhandle](ih), cstring("SHOWCLOSE"), cstring(value))

proc `showclose`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWCLOSE"), cstring(value))

proc `showclose=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWCLOSE"), cstring((if yes: "YES" else: "NO")))

proc `showclose`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWCLOSE"), cstring((if yes: "YES" else: "NO")))

proc `showclose`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWCLOSE")) == "YES"

# TODO unknown: flattabs SHOWLINES Unknown Binary
proc `showlines`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWLINES"))

proc `size=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    # SIZE: The default size is the smallest size that fits its
    # largest child. All child elements are considered even invisible
    # ones.
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: FlatTabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FlatTabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

# TODO getter flattabs TABACTIVE
# TODO getter flattabs TABBACKCOLOR
# TODO unknown: flattabs TABCHANGEONCHECK Unknown Binary
proc `tabchangeoncheck`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABCHANGEONCHECK"))

# TODO getter flattabs TABFONT
# TODO getter flattabs TABFONTSIZE
# TODO getter flattabs TABFONTSTYLE
# TODO getter flattabs TABFORECOLOR
# TODO getter flattabs TABHIGHCOLOR
# TODO getter flattabs TABIMAGE
proc `taborientation=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    # TABORIENTATION (non inheritable): the orientation of tab text,
    # which can be "HORIZONTAL" or "VERTICAL". Default is
    # "HORIZONTAL". When set to vertical it will simply set
    # TABSTEXTORIENTATION to 90. (since 3.25)
    SetAttribute(cast[PIhandle](ih), cstring("TABORIENTATION"), cstring(value))

proc `taborientation`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TABORIENTATION"), cstring(value))

proc `taborientation`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABORIENTATION"))

# TODO unknown: flattabs TABSALIGNMENT Unknown Binary
proc `tabsalignment`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABSALIGNMENT"))

# TODO unknown: flattabs TABSBACKCOLOR Unknown Binary
proc `tabsbackcolor`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABSBACKCOLOR"))

# TODO unknown: flattabs TABSFONT Unknown Binary
proc `tabsfont`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABSFONT"))

proc `tabsfontsize=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    # TABSFONTSIZE: text font size. When change will actually set
    # TABSFONT.
    SetAttribute(cast[PIhandle](ih), cstring("TABSFONTSIZE"), cstring(value))

proc `tabsfontsize`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TABSFONTSIZE"), cstring(value))

proc `tabsfontsize=`*(ih: FlatTabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TABSFONTSIZE"), cstring(&"{x}"))

proc `tabsfontsize`*(ih: FlatTabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TABSFONTSIZE"), cstring(&"{x}"))

proc `tabsfontsize`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABSFONTSIZE"))

# TODO unknown: flattabs TABSFONTSTYLE Unknown Binary
proc `tabsfontstyle`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABSFONTSTYLE"))

# TODO unknown: flattabs TABSFORECOLOR Unknown Binary
proc `tabsforecolor`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABSFORECOLOR"))

# TODO unknown: flattabs TABSHIGHCOLOR Unknown Binary
proc `tabshighcolor`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABSHIGHCOLOR"))

# TODO unknown: flattabs TABSIMAGEPOSITION Unknown Binary
proc `tabsimageposition`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABSIMAGEPOSITION"))

# TODO unknown: flattabs TABSIMAGESPACING Unknown Binary
proc `tabsimagespacing`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABSIMAGESPACING"))

# TODO unknown: flattabs TABSLINECOLOR Unknown Binary
proc `tabslinecolor`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABSLINECOLOR"))

# TODO unknown: flattabs TABSPADDING Unknown Binary
proc `tabspadding`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABSPADDING"))

# TODO unknown: flattabs TABSTEXTALIGNMENT Unknown Binary
proc `tabstextalignment`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABSTEXTALIGNMENT"))

# TODO unknown: flattabs TABSTEXTCLIP Unknown Binary
proc `tabstextclip`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABSTEXTCLIP"))

# TODO unknown: flattabs TABSTEXTELLIPSIS Unknown Binary
proc `tabstextellipsis`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABSTEXTELLIPSIS"))

# TODO unknown: flattabs TABSTEXTORIENTATION Unknown Binary
proc `tabstextorientation`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABSTEXTORIENTATION"))

# TODO unknown: flattabs TABSTEXTWRAP Unknown Binary
proc `tabstextwrap`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABSTEXTWRAP"))

# TODO getter flattabs TABTIP
# TODO getter flattabs TABTITLE
proc `tabtype=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    # TABTYPE (non inheritable): the type of tabs, which can be "TOP",
    # "BOTTOM", "LEFT" or "RIGHT". Default is "TOP". It will not
    # automatically change the TABORIENTATION. When changed with the
    # dialog visible the application should call IupRefresh or
    # IupRefresh children to updated the layout when ready. (since
    # 3.27)
    SetAttribute(cast[PIhandle](ih), cstring("TABTYPE"), cstring(value))

proc `tabtype`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TABTYPE"), cstring(value))

proc `tabtype`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABTYPE"))

# TODO getter flattabs TABVISIBLE
proc `theme=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary flattabs
proc `theme`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary flattabs
proc `tip`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: FlatTabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FlatTabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: FlatTabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FlatTabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: FlatTabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FlatTabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary flattabs
proc `tipicon`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary flattabs
proc `tipmarkup`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: FlatTabs_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FlatTabs_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `touch=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOUCH")) == "YES"

proc `usersize=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: FlatTabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FlatTabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    # VALUE: Changes the current tab by its name. The value passed
    # must be the name of one of the elements contained in the tabs.
    # Use IupSetHandle or IupSetAttributeHandle to associate a child
    # to a name. In Lua you can also use the element reference
    # directly. When the tabs is created, the first element inserted
    # is set as the current tab. When the current tab is changed is
    # also scrolled to be visible (since 3.23).
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

# TODO ??? String Binary flattabs
proc `value`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `valuepos=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    # VALUEPOS: Changes the current tab by its position, starting at
    # 0.
    SetAttribute(cast[PIhandle](ih), cstring("VALUEPOS"), cstring(value))

proc `valuepos`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUEPOS"), cstring(value))

proc `valuepos=`*(ih: FlatTabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUEPOS"), cstring(&"{x}"))

proc `valuepos`*(ih: FlatTabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUEPOS"), cstring(&"{x}"))

proc `valuepos`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUEPOS"))

proc `value_handle=`*(ih: FlatTabs_t, handle: User_t) {.cdecl.} =
    # VALUE_HANDLE: Changes the current tab by its handle. The value
    # passed must be the handle of a child contained in the tabs.
    SetAttributeHandle(cast[PIhandle](ih), cstring("VALUE_HANDLE"), cast[PIhandle](handle))

proc `value_handle`*(ih: FlatTabs_t, handle: User_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("VALUE_HANDLE"), cast[PIhandle](handle))

proc `value_handle`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE_HANDLE"))

proc `visible=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wheeldropfocus=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS")) == "YES"

proc `wid`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

proc `xautohide=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE")) == "YES"

proc `xdisplay`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XDISPLAY"))

# TODO unknown: flattabs XFONTID Unknown Binary
proc `xfontid`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `xhidden`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XHIDDEN")) == "YES"

proc `xmax=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax=`*(ih: FlatTabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: FlatTabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMAX"))

proc `xmin=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin=`*(ih: FlatTabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: FlatTabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMIN"))

# TODO unknown: flattabs XWINDOW Unknown Binary
proc `xwindow`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `yautohide=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide=`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: FlatTabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE")) == "YES"

proc `yhidden`*(ih: FlatTabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YHIDDEN")) == "YES"

proc `ymax=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax=`*(ih: FlatTabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: FlatTabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMAX"))

proc `ymin=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin=`*(ih: FlatTabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: FlatTabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: FlatTabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMIN"))

proc `zorder=`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: FlatTabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `destroy_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: FlatTabs_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FlatTabs_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `extrabutton_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    # EXTRABUTTON_CB: Action generated when any mouse button is
    # pressed or released. (since 3.22) int function(Ihandle* ih, int
    # button, int pressed); [in C] ih:extrabutton_cb(button, pressed:
    # number) -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("EXTRABUTTON_CB"), cast[Icallback](cb))

proc `extrabutton_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("EXTRABUTTON_CB"), cast[Icallback](cb))

proc `extrabutton_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("EXTRABUTTON_CB")))

proc `flat_button_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_BUTTON_CB"), cast[Icallback](cb))

proc `flat_button_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_BUTTON_CB"), cast[Icallback](cb))

proc `flat_button_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_BUTTON_CB")))

proc `flat_getfocus_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_GETFOCUS_CB"), cast[Icallback](cb))

proc `flat_getfocus_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_GETFOCUS_CB"), cast[Icallback](cb))

proc `flat_getfocus_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_GETFOCUS_CB")))

proc `flat_killfocus_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_KILLFOCUS_CB"), cast[Icallback](cb))

proc `flat_killfocus_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_KILLFOCUS_CB"), cast[Icallback](cb))

proc `flat_killfocus_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_KILLFOCUS_CB")))

proc `flat_leavewindow_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `flat_leavewindow_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `flat_leavewindow_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_LEAVEWINDOW_CB")))

proc `flat_motion_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_MOTION_CB"), cast[Icallback](cb))

proc `flat_motion_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_MOTION_CB"), cast[Icallback](cb))

proc `flat_motion_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_MOTION_CB")))

proc `focus_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `keypress_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    # KEYPRESS_CB KEYPRESS_CB Action generated when a key is pressed
    # or released. If the key is pressed and held several calls will
    # occur. It is called after the callback K_ANY is processed.
    # Callback int function(Ihandle *ih, int c, int press); [in C]
    # ih:keypress_cb(c, press: number) -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. c:
    # identifier of typed key. Please refer to the Keyboard Codes
    # table for a list of possible values. press: 1 is the user
    # pressed the key or 0 otherwise. Returns: If IUP_IGNORE is
    # returned the key is ignored by the system. IUP_CLOSE will be
    # processed. Affects IupCanvas
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB")))

proc `killfocus_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `postmessage_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `rightclick_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # RIGHTCLICK_CB: Callback called when the user clicks on some tab
    # using the right mouse button. int function(Ihandle* ih, int
    # pos); [in C] ih:rightclick_cb(pos: number) -> (ret: number) [in
    # Lua]
    SetCallback(cast[PIhandle](ih), cstring("RIGHTCLICK_CB"), cast[Icallback](cb))

proc `rightclick_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RIGHTCLICK_CB"), cast[Icallback](cb))

proc `rightclick_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RIGHTCLICK_CB")))

proc `scroll_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    # SCROLL_CB SCROLL_CB Called when some manipulation is made to the
    # scrollbar. The canvas is automatically redrawn only if this
    # callback is NOT defined. (GTK 2.8) Also the POSX and POSY values
    # will not be correctly updated for older GTK versions. In Ubuntu,
    # when liboverlay-scrollbar is enabled (the new tiny auto-hide
    # scrollbar) only the IUP_SBPOSV and IUP_SBPOSH codes are used.
    # Callback int function(Ihandle *ih, int op, float posx, float
    # posy); [in C] ih:scroll_cb(op, posx, posy: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. op: indicates the operation performed on the
    # scrollbar. If the manipulation was made on the vertical
    # scrollbar, it can have the following values: IUP_SBUP - line up
    # IUP_SBDN - line down IUP_SBPGUP - page up IUP_SBPGDN - page down
    # IUP_SBPOSV - vertical positioning IUP_SBDRAGV - vertical drag If
    # it was on the horizontal scrollbar, the following values are
    # valid: IUP_SBLEFT - column left IUP_SBRIGHT - column right
    # IUP_SBPGLEFT - page left IUP_SBPGRIGHT - page right IUP_SBPOSH -
    # horizontal positioning IUP_SBDRAGH - horizontal drag posx, posy:
    # the same as the ACTION canvas callback (corresponding to the
    # values of attributes POSX and POSY). Notes IUP_SBDRAGH and
    # IUP_SBDRAGV are not supported in GTK. During drag IUP_SBPOSH and
    # IUP_SBPOSV are used. In Windows, after a drag when mouse is
    # released IUP_SBPOSH or IUP_SBPOSV are called. Affects IupCanvas,
    # IupGLCanvas, SCROLLBAR
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SCROLL_CB")))

proc `tabchangepos_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    # TABCHANGEPOS_CB: Callback called when the user changes the
    # current tab. Called only when TABCHANGE_CB is not defined. int
    # function(Ihandle* ih, int new_pos, int old_pos); [in C]
    # ih:tabchange_cb(new_pos, old_pos: number) -> (ret: number) [in
    # Lua]
    SetCallback(cast[PIhandle](ih), cstring("TABCHANGEPOS_CB"), cast[Icallback](cb))

proc `tabchangepos_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("TABCHANGEPOS_CB"), cast[Icallback](cb))

proc `tabchangepos_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("TABCHANGEPOS_CB")))

proc `tabchange_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: PIhandle, arg3: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # TABCHANGE_CB: Callback called when the user changes the current
    # tab. int function(Ihandle* ih, Ihandle* new_tab, Ihandle*
    # old_tab); [in C] ih:tabchange_cb(new_tab, old_tab: ihandle) ->
    # (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("TABCHANGE_CB"), cast[Icallback](cb))

proc `tabchange_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: PIhandle, arg3: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("TABCHANGE_CB"), cast[Icallback](cb))

proc `tabchange_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("TABCHANGE_CB")))

proc `tabclose_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # TABCLOSE_CB: Callback called when the user clicks on the close
    # button. Called only when SHOWCLOSE=Yes. int function(Ihandle*
    # ih, int pos); [in C] ih:tabclose_cb(pos: number) -> (ret:
    # number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("TABCLOSE_CB"), cast[Icallback](cb))

proc `tabclose_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("TABCLOSE_CB"), cast[Icallback](cb))

proc `tabclose_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("TABCLOSE_CB")))

proc `unmap_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `wheel_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # WHEEL_CB WHEEL_CB Action generated when the mouse wheel is
    # rotated. If this callback is not defined the wheel will
    # automatically scroll the canvas in the vertical direction by
    # some lines, the SCROLL_CB callback if defined will be called
    # with the IUP_SBDRAGV operation. Callback int function(Ihandle
    # *ih, float delta, int x, int y, char *status); [in C]
    # ih:wheel_cb(delta, x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. delta: the amount the wheel was rotated in notches.
    # x, y: position in the canvas where the event has occurred, in
    # pixels. status: status of mouse buttons and certain keyboard
    # keys at the moment the event was generated. The same macros used
    # for BUTTON_CB can be used for this status. Notes In Motif and
    # GTK delta is always 1 or -1. In Windows is some situations delta
    # can reach the value of two. In the future with more precise
    # wheels this increment can be changed. Affects IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WHEEL_CB")))

proc `wom_cb=`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # WOM_CB WOM_CB Action generated when an audio device receives an
    # event. [Windows Only] Callback int function(Ihandle *ih, int
    # state); [in C] ih:wom_cb(state: number) -> (ret: number) [in
    # Lua] ih: identifies the element that activated the event. state:
    # can be opening=1, done=0, or closing=-1. Notes This callback is
    # used to syncronize video playback with audio. It is sent when
    # the audio device: Message Description opening is opened by using
    # the waveOutOpen function. done is finished with a data block
    # sent by using the waveOutWrite function. closing is closed by
    # using the waveOutClose function. You must use the HWND attribute
    # when calling waveOutOpen in the dwCallback parameter and set
    # fdwOpen to CALLBACK_WINDOW. Affects IupDialog, IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: FlatTabs_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: FlatTabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WOM_CB")))

proc FlatToggle*(title: string): FlatToggle_t {.cdecl.} =
    # Creates an interface element that is a toggle, but it does not
    # have native decorations. When selected, this element activates a
    # function in the application. Its visual presentation can contain
    # a text and/or an image. It behaves just like an IupToggle, but
    # since it is not a native control it has more flexibility for
    # additional options. It inherits from IupCanvas.
    return FlatToggle_t(niupc.FlatToggle(cstring(title)))

proc `active=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # ACTIVE, FONT, EXPAND, SCREENPOSITION, POSITION, MINSIZE,
    # MAXSIZE, WID, TIP, SIZE, RASTERSIZE, ZORDER, VISIBLE, THEME:
    # also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `alignment=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # ALIGNMENT (non inheritable): horizontal and vertical alignment
    # of the set image+text. Possible values: "ALEFT", "ACENTER" and
    # "ARIGHT", combined to "ATOP", "ACENTER" and "ABOTTOM". Default:
    # "ACENTER:ACENTER". Partial values are also accepted, like
    # "ARIGHT" or ":ATOP", the other value will be obtained from the
    # default value. Alignment does not includes the padding area.
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"))

proc `backimage=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # BACKIMAGE (non inheritable): image name to be used as
    # background. Use IupSetHandle or IupSetAttributeHandle to
    # associate an image to a name. See also IupImage.
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGE"), cast[PIhandle](handle))

proc `backimage`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGE"), cast[PIhandle](handle))

proc `backimage`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGE"))

proc `backimagehighlight=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # BACKIMAGEHIGHLIGHT (non inheritable): background image name of
    # the element in highlight state. If it is not defined then the
    # BACKIMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `backimagehighlight`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `backimagehighlight`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEHIGHLIGHT"))

proc `backimageinactive=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # BACKIMAGEINACTIVE (non inheritable): background image name of
    # the element when inactive. If it is not defined then the
    # BACKIMAGE is used and its colors will be replaced by a modified
    # version creating the disabled effect.
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGEINACTIVE"), cast[PIhandle](handle))

proc `backimageinactive`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGEINACTIVE"), cast[PIhandle](handle))

proc `backimageinactive`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEINACTIVE"))

proc `backimagepress=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # BACKIMAGEPRESS (non inheritable): background image name of the
    # element in pressed state. If it is not defined then the
    # BACKIMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGEPRESS"), cast[PIhandle](handle))

proc `backimagepress`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGEPRESS"), cast[PIhandle](handle))

proc `backimagepress`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEPRESS"))

proc `backimagezoom=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # BACKIMAGEZOOM (non inheritable): if set the back image will be
    # zoomed to occupy the full background. Aspect ratio is NOT
    # preserved. Can be Yes or No. Default: No. (since 3.25)
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring(value))

proc `backimagezoom`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring(value))

proc `backimagezoom=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring((if yes: "YES" else: "NO")))

proc `backimagezoom`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring((if yes: "YES" else: "NO")))

proc `backimagezoom`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM")) == "YES"

proc `backingstore=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE")) == "YES"

proc `bgcolor=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # BGCOLOR: Background color. If text and image are not defined,
    # the button is configured to simply show a color, in this case
    # set the button size because the natural size will be very small.
    # If not defined it will use the background color of the native
    # parent.
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # BORDER (creation only): the default value is "NO". This is the
    # IupCanvas border.
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `bordercolor=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # BORDERCOLOR: color used for borders. Default: "50 150 255". This
    # is for the IupFlatToggle drawn border.
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(value))

proc `bordercolor`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(value))

proc `bordercolor=`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bordercolor`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bordercolor`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"))

proc `borderhlcolor=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # BORDERHLCOLOR: color used for borders when highlighted. Default
    # use BORDERCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("BORDERHLCOLOR"), cstring(value))

proc `borderhlcolor`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERHLCOLOR"), cstring(value))

proc `borderhlcolor=`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERHLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `borderhlcolor`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERHLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `borderhlcolor`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERHLCOLOR"))

proc `borderpscolor=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # BORDERPSCOLOR: color used for borders when pressed or selected.
    # Default use BORDERCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("BORDERPSCOLOR"), cstring(value))

proc `borderpscolor`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERPSCOLOR"), cstring(value))

proc `borderpscolor=`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERPSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `borderpscolor`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERPSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `borderpscolor`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERPSCOLOR"))

proc `borderwidth=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # BORDERWIDTH: line width used for borders. Default: "1". Any
    # borders can be hidden by simply setting this value to 0. This is
    # for the IupFlatToggle drawn border. When the check box is shown
    # the borders are not shown, and the background is not
    # highlighted.
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(value))

proc `borderwidth`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(value))

proc `borderwidth=`*(ih: FlatToggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(&"{x}"))

proc `borderwidth`*(ih: FlatToggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(&"{x}"))

proc `borderwidth`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"))

proc `canfocus=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # CANFOCUS (creation only) (non inheritable): enables the focus
    # traversal of the control. In Windows the button will respect
    # CANFOCUS in opposite to the other controls. Default: YES.
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

# TODO unknown: flattoggle CHECKALIGN Unknown Binary
proc `checkalign`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHECKALIGN"))

# TODO unknown: flattoggle CHECKBGCOLOR Unknown Binary
proc `checkbgcolor`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHECKBGCOLOR"))

# TODO unknown: flattoggle CHECKFGCOLOR Unknown Binary
proc `checkfgcolor`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHECKFGCOLOR"))

# TODO unknown: flattoggle CHECKHLCOLOR Unknown Binary
proc `checkhlcolor`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHECKHLCOLOR"))

proc `checkimage=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # CHECKIMAGE (non inheritable): image name to be used as check box
    # when VALUE=OFF, be sure the image size is equal to CHECKSIZE-2.
    # Use IupSetHandle or IupSetAttributeHandle to associate an image
    # to a name. See also IupImage. If this attribute is defined the
    # check box is not drawn, the images will be used instead.
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGE"), cast[PIhandle](handle))

proc `checkimage`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGE"), cast[PIhandle](handle))

proc `checkimage`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHECKIMAGE"))

proc `checkimagehighlight=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # CHECKIMAGEHIGHLIGHT (non inheritable): check box image name of
    # the element in highlight state when VALUE=OFF. If it is not
    # defined then the CHECKIMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `checkimagehighlight`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `checkimagehighlight`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHECKIMAGEHIGHLIGHT"))

proc `checkimageinactive=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # CHECKIMAGEINACTIVE (non inheritable): check box image name of
    # the element when inactive and VALUE=OFF. If it is not defined
    # then the CHECKIMAGE is used and its colors will be replaced by a
    # modified version creating the disabled effect.
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGEINACTIVE"), cast[PIhandle](handle))

proc `checkimageinactive`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGEINACTIVE"), cast[PIhandle](handle))

proc `checkimageinactive`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHECKIMAGEINACTIVE"))

proc `checkimagenotdef=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGENOTDEF"), cast[PIhandle](handle))

proc `checkimagenotdef`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGENOTDEF"), cast[PIhandle](handle))

proc `checkimagenotdef`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHECKIMAGENOTDEF"))

proc `checkimagenotdefhighlight=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGENOTDEFHIGHLIGHT"), cast[PIhandle](handle))

proc `checkimagenotdefhighlight`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGENOTDEFHIGHLIGHT"), cast[PIhandle](handle))

proc `checkimagenotdefhighlight`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHECKIMAGENOTDEFHIGHLIGHT"))

proc `checkimagenotdefinactive=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGENOTDEFINACTIVE"), cast[PIhandle](handle))

proc `checkimagenotdefinactive`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGENOTDEFINACTIVE"), cast[PIhandle](handle))

proc `checkimagenotdefinactive`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHECKIMAGENOTDEFINACTIVE"))

proc `checkimagenotdefpress=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGENOTDEFPRESS"), cast[PIhandle](handle))

proc `checkimagenotdefpress`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGENOTDEFPRESS"), cast[PIhandle](handle))

proc `checkimagenotdefpress`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHECKIMAGENOTDEFPRESS"))

proc `checkimageon=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGEON"), cast[PIhandle](handle))

proc `checkimageon`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGEON"), cast[PIhandle](handle))

proc `checkimageon`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHECKIMAGEON"))

proc `checkimageonhighlight=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGEONHIGHLIGHT"), cast[PIhandle](handle))

proc `checkimageonhighlight`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGEONHIGHLIGHT"), cast[PIhandle](handle))

proc `checkimageonhighlight`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHECKIMAGEONHIGHLIGHT"))

proc `checkimageoninactive=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGEONINACTIVE"), cast[PIhandle](handle))

proc `checkimageoninactive`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGEONINACTIVE"), cast[PIhandle](handle))

proc `checkimageoninactive`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHECKIMAGEONINACTIVE"))

proc `checkimageonpress=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGEONPRESS"), cast[PIhandle](handle))

proc `checkimageonpress`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGEONPRESS"), cast[PIhandle](handle))

proc `checkimageonpress`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHECKIMAGEONPRESS"))

proc `checkimagepress=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # CHECKIMAGEPRESS (non inheritable): check box image name of the
    # element in pressed state when VALUE=OFF. If it is not defined
    # then the CHECKIMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGEPRESS"), cast[PIhandle](handle))

proc `checkimagepress`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CHECKIMAGEPRESS"), cast[PIhandle](handle))

proc `checkimagepress`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHECKIMAGEPRESS"))

# TODO unknown: flattoggle CHECKPSCOLOR Unknown Binary
proc `checkpscolor`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHECKPSCOLOR"))

# TODO unknown: flattoggle CHECKRIGHT Unknown Binary
proc `checkright`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHECKRIGHT"))

# TODO unknown: flattoggle CHECKSIZE Unknown Binary
proc `checksize`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHECKSIZE"))

# TODO unknown: flattoggle CHECKSPACING Unknown Binary
proc `checkspacing`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHECKSPACING"))

proc `cpadding=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # CPADDING: same as PADDING but using the units of the SIZE
    # attribute. It will actually set the PADDING attribute. (since
    # 3.29)
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding=`*(ih: FlatToggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: FlatToggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CPADDING"))

proc `cspacing=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # CSPACING: same as SPACING but using the units of the vertical
    # part of the SIZE attribute. It will actually set the SPACING
    # attribute. (since 3.29)
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(value))

proc `cspacing`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(value))

proc `cspacing=`*(ih: FlatToggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(&"{x}"))

proc `cspacing`*(ih: FlatToggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(&"{x}"))

proc `cspacing`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CSPACING"))

proc `cursor=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `dragdrop=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary flattoggle
proc `dragtypes`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

# TODO unknown: flattoggle DRAWABLE Unknown Binary
proc `drawable`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWABLE"))

proc `drawbgcolor=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor=`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"))

proc `drawcolor=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor=`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"))

proc `drawdriver`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWDRIVER"))

proc `drawfont=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

proc `drawfont`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

# TODO ??? String Binary flattoggle
proc `drawfont`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"))

proc `drawlinewidth=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth=`*(ih: FlatToggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: FlatToggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"))

proc `drawmakeinactive=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE")) == "YES"

proc `drawsize`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSIZE"))

proc `drawstyle=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"))

proc `drawtextalignment=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"))

proc `drawtextclip=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP")) == "YES"

proc `drawtextellipsis=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS")) == "YES"

proc `drawtextlayoutcenter=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER")) == "YES"

proc `drawtextorientation=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation=`*(ih: FlatToggle_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: FlatToggle_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"))

proc `drawtextwrap=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP")) == "YES"

proc `dropfilestarget=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary flattoggle
proc `droptypes`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `dx=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx=`*(ih: FlatToggle_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: FlatToggle_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DX"))

proc `dy=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy=`*(ih: FlatToggle_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: FlatToggle_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DY"))

proc `expand=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable): The default value is "NO".
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: FlatToggle_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FlatToggle_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `fgcolor=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # FGCOLOR: Text color. Default: the global attribute DLGFGCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

proc `fittobackimage=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # FITTOBACKIMAGE (non inheritable): enable the natural size to be
    # computed from the BACKIMAGE. If BACKIMAGE is not defined will be
    # ignored. Can be Yes or No. Default: No.
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring(value))

proc `fittobackimage`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring(value))

proc `fittobackimage=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring((if yes: "YES" else: "NO")))

proc `fittobackimage`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring((if yes: "YES" else: "NO")))

proc `fittobackimage`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE")) == "YES"

proc `floating=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `focusfeedback=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # FOCUSFEEDBACK (non inheritable): draw the focus feedback. Can be
    # Yes or No. Default: Yes. (since 3.26)
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring(value))

proc `focusfeedback`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring(value))

proc `focusfeedback=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring((if yes: "YES" else: "NO")))

proc `focusfeedback`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring((if yes: "YES" else: "NO")))

proc `focusfeedback`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK")) == "YES"

proc `font=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary flattoggle
proc `font`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary flattoggle
proc `fontface`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: FlatToggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FlatToggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary flattoggle
proc `fontstyle`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `frontimage=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # FRONTIMAGE (non inheritable): image name to be used as
    # foreground. The foreground image is drawn in the same position
    # as the background, but it is drawn at last. Use IupSetHandle or
    # IupSetAttributeHandle to associate an image to a name. See also
    # IupImage.
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGE"), cast[PIhandle](handle))

proc `frontimage`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGE"), cast[PIhandle](handle))

proc `frontimage`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRONTIMAGE"))

proc `frontimagehighlight=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # FRONTIMAGEHIGHLIGHT (non inheritable): foreground image name of
    # the element in highlight state. If it is not defined then the
    # FRONTIMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `frontimagehighlight`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `frontimagehighlight`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRONTIMAGEHIGHLIGHT"))

proc `frontimageinactive=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # FRONTIMAGEINACTIVE (non inheritable): foreground image name of
    # the element when inactive. If it is not defined then the
    # FRONTIMAGE is used and its colors will be replaced by a modified
    # version creating the disabled effect.
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGEINACTIVE"), cast[PIhandle](handle))

proc `frontimageinactive`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGEINACTIVE"), cast[PIhandle](handle))

proc `frontimageinactive`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRONTIMAGEINACTIVE"))

proc `frontimagepress=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # FRONTIMAGEPRESS (non inheritable): foreground image name of the
    # element in pressed state. If it is not defined then the
    # FRONTIMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGEPRESS"), cast[PIhandle](handle))

proc `frontimagepress`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("FRONTIMAGEPRESS"), cast[PIhandle](handle))

proc `frontimagepress`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FRONTIMAGEPRESS"))

proc `handlename=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary flattoggle
proc `handlename`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `hasfocus`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HASFOCUS")) == "YES"

proc `highlighted`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIGHLIGHTED")) == "YES"

proc `hlcolor=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # HLCOLOR: background color used to indicate a highlight state.
    # Pre-defined to "200 225 245". Can be set to NULL. If NULL
    # BGCOLOR will be used instead.
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(value))

proc `hlcolor`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(value))

proc `hlcolor=`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `hlcolor`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `hlcolor`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"))

proc `ignoreradio=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # IGNORERADIO (non inheritable): when set the toggle will not
    # behave as a radio when inside an IupRadio hierarchy.
    SetAttribute(cast[PIhandle](ih), cstring("IGNORERADIO"), cstring(value))

proc `ignoreradio`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("IGNORERADIO"), cstring(value))

proc `ignoreradio=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("IGNORERADIO"), cstring((if yes: "YES" else: "NO")))

proc `ignoreradio`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("IGNORERADIO"), cstring((if yes: "YES" else: "NO")))

proc `ignoreradio`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IGNORERADIO")) == "YES"

proc `image=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGE (non inheritable): Image name. Use IupSetHandle or
    # IupSetAttributeHandle to associate an image to a name. See also
    # IupImage.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGE"))

proc `imagehighlight=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGEHIGHLIGHT (non inheritable): Image name of the element in
    # highlight state. If it is not defined then the IMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `imagehighlight`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `imagehighlight`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEHIGHLIGHT"))

proc `imageinactive=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGEINACTIVE (non inheritable): Image name of the element when
    # inactive. If it is not defined then the IMAGE is used and its
    # colors will be replaced by a modified version creating the
    # disabled effect. Finally notice that the name of the secondary
    # image attributes are different (for instance IMINACTIVE is
    # IMAGEINACTIVE, IMPRESS is IMAGEPRESS, and so on).
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEINACTIVE"), cast[PIhandle](handle))

proc `imageinactive`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEINACTIVE"), cast[PIhandle](handle))

proc `imageinactive`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEINACTIVE"))

proc `imageposition=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # IMAGEPOSITION (non inheritable): Position of the image relative
    # to the text when both are displayed. Can be: LEFT, RIGHT, TOP,
    # BOTTOM. Default: LEFT.
    SetAttribute(cast[PIhandle](ih), cstring("IMAGEPOSITION"), cstring(value))

proc `imageposition`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("IMAGEPOSITION"), cstring(value))

proc `imageposition`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEPOSITION"))

proc `imagepress=`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGEPRESS (non inheritable): Image name of the element in
    # pressed state. If it is not defined then the IMAGE is used.
    # Finally notice that the name of the secondary image attributes
    # are different (for instance IMINACTIVE is IMAGEINACTIVE, IMPRESS
    # is IMAGEPRESS, and so on).
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEPRESS"), cast[PIhandle](handle))

proc `imagepress`*(ih: FlatToggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEPRESS"), cast[PIhandle](handle))

proc `imagepress`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEPRESS"))

proc `linex=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex=`*(ih: FlatToggle_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: FlatToggle_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEX"))

proc `liney=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney=`*(ih: FlatToggle_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: FlatToggle_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEY"))

proc `maxsize=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: FlatToggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FlatToggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: FlatToggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FlatToggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary flattoggle
proc `name`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary flattoggle
proc `normalizergroup`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary flattoggle
proc `ntheme`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `padding=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # PADDING: internal margin. Works just like the MARGIN attribute
    # of the IupHbox and IupVbox containers, but uses a different name
    # to avoid inheritance problems. Alignment does not includes the
    # padding area. Default value: "0x0". Value can be
    # DEFAULTBUTTONPADDING, so the global attribute of this name will
    # be used instead (since 3.29). The natural size will be a
    # combination of the size of the image and the title, if any, plus
    # PADDING and SPACING (if both image and title are present), and
    # the check box if visible.
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding=`*(ih: FlatToggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: FlatToggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PADDING"))

# TODO unknown: flattoggle PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: flattoggle PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: FlatToggle_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FlatToggle_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `posx=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx=`*(ih: FlatToggle_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: FlatToggle_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSX"))

proc `posy=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy=`*(ih: FlatToggle_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: FlatToggle_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSY"))

proc `pressed`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PRESSED")) == "YES"

proc `propagatefocus=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # PROPAGATEFOCUS (non inheritable): enables the focus callback
    # forwarding to the next native parent with FOCUS_CB defined.
    # Default: NO.
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `pscolor=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # PSCOLOR: background color used to indicate a press state. Pre-
    # defined to "150 200 235". Can be set to NULL. If NULL BGCOLOR
    # will be used instead.
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(value))

proc `pscolor`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(value))

proc `pscolor=`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `pscolor`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `pscolor`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"))

proc `radio`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RADIO")) == "YES"

proc `rastersize=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: FlatToggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FlatToggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `sb_resize`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_RESIZE"))

proc `screenposition`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `scrollbar=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR")) == "YES"

# TODO unknown: flattoggle SELECTEDNOTIFY Unknown Binary
proc `selectednotify`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SELECTEDNOTIFY"))

proc `showborder=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # SHOWBORDER: by default borders are drawn only when the button is
    # highlighted, if SHOWBORDER=Yes borders are always show. When
    # SHOWBORDER=Yes and BGCOLOR is not defined, the actual BGCOLOR
    # will be a darker version of the background color of the native
    # parent.
    SetAttribute(cast[PIhandle](ih), cstring("SHOWBORDER"), cstring(value))

proc `showborder`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWBORDER"), cstring(value))

proc `showborder=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWBORDER"), cstring((if yes: "YES" else: "NO")))

proc `showborder`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWBORDER"), cstring((if yes: "YES" else: "NO")))

proc `showborder`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWBORDER")) == "YES"

proc `size=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: FlatToggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FlatToggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `spacing=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # SPACING (non inheritable): spacing between the image and the
    # text. Default: "2". The natural size will be a combination of
    # the size of the image and the title, if any, plus PADDING and
    # SPACING (if both image and title are present), and the check box
    # if visible.
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(value))

proc `spacing`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(value))

proc `spacing=`*(ih: FlatToggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(&"{x}"))

proc `spacing`*(ih: FlatToggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(&"{x}"))

proc `spacing`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPACING"))

proc `textalignment=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # TEXTALIGNMENT (non inheritable): Horizontal text alignment for
    # multiple lines. Can be: ALEFT, ARIGHT or ACENTER. Default:
    # ALEFT.
    SetAttribute(cast[PIhandle](ih), cstring("TEXTALIGNMENT"), cstring(value))

proc `textalignment`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTALIGNMENT"), cstring(value))

proc `textalignment`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTALIGNMENT"))

# TODO unknown: flattoggle TEXTCLIP Unknown Binary
proc `textclip`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTCLIP"))

proc `textellipsis=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # TEXTELLIPSIS (non inheritable): If the text is larger that its
    # box, an ellipsis ("...") will be placed near the last visible
    # part of the text and replace the invisible part. It will be
    # ignored when TEXTWRAP=Yes. (since 3.25)
    SetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS"), cstring(value))

proc `textellipsis`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS"), cstring(value))

proc `textellipsis=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `textellipsis`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `textellipsis`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTELLIPSIS")) == "YES"

proc `texthlcolor=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # TEXTHLCOLOR: text color used to indicate a highlight state. If
    # not defined FGCOLOR will be used instead. (since 3.26)
    SetAttribute(cast[PIhandle](ih), cstring("TEXTHLCOLOR"), cstring(value))

proc `texthlcolor`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTHLCOLOR"), cstring(value))

proc `texthlcolor=`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTHLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `texthlcolor`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTHLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `texthlcolor`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTHLCOLOR"))

proc `textorientation=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # TEXTORIENTATION (non inheritable): text angle in degrees and
    # counterclockwise. The text size will adapt to include the
    # rotated space. (since 3.25)
    SetAttribute(cast[PIhandle](ih), cstring("TEXTORIENTATION"), cstring(value))

proc `textorientation`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTORIENTATION"), cstring(value))

proc `textorientation=`*(ih: FlatToggle_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTORIENTATION"), cstring(&"{x}"))

proc `textorientation`*(ih: FlatToggle_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTORIENTATION"), cstring(&"{x}"))

proc `textorientation`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTORIENTATION"))

proc `textpscolor=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # TEXTPSCOLOR: text color used to indicate a press state. If not
    # defined FGCOLOR will be used instead. (since 3.26)
    SetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"), cstring(value))

proc `textpscolor`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"), cstring(value))

proc `textpscolor=`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `textpscolor`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `textpscolor`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"))

proc `textwrap=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # TEXTWRAP (non inheritable): For single line texts if the text is
    # larger than its box the line will be automatically broken in
    # multiple lines. Notice that this is done internally by the
    # system, the element natural size will still use only a single
    # line. For the remaining lines to be visible the element should
    # use EXPAND=VERTICAL or set a SIZE/RASTERSIZE with enough height
    # for the wrapped lines. (since 3.25)
    SetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP"), cstring(value))

proc `textwrap`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP"), cstring(value))

proc `textwrap=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `textwrap`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `textwrap`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTWRAP")) == "YES"

proc `theme=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary flattoggle
proc `theme`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary flattoggle
proc `tip`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: FlatToggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FlatToggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FlatToggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary flattoggle
proc `tipicon`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary flattoggle
proc `tipmarkup`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: FlatToggle_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FlatToggle_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `title=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # TITLE (non inheritable): toggle text. The '\n' character is
    # accepted for line change.
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary flattoggle
proc `title`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

proc `touch=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOUCH")) == "YES"

proc `usersize=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: FlatToggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FlatToggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    # VALUE (non inheritable): Toggle's state. Values can be "ON",
    # "OFF" or "TOGGLE". If 3STATE=YES then can also be "NOTDEF".
    # Default: "OFF". The TOGGLE option will invert the current state.
    # Can only be set to ON if the toggle is inside a radio, it will
    # automatically set to OFF the previous toggle that was ON in the
    # radio.
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

# TODO ??? String Binary flattoggle
proc `value`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `visible=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wheeldropfocus=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS")) == "YES"

proc `wid`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

proc `xautohide=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE")) == "YES"

proc `xdisplay`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XDISPLAY"))

# TODO unknown: flattoggle XFONTID Unknown Binary
proc `xfontid`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `xhidden`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XHIDDEN")) == "YES"

proc `xmax=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax=`*(ih: FlatToggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: FlatToggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMAX"))

proc `xmin=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin=`*(ih: FlatToggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: FlatToggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMIN"))

# TODO unknown: flattoggle XWINDOW Unknown Binary
proc `xwindow`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `yautohide=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide=`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: FlatToggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE")) == "YES"

proc `yhidden`*(ih: FlatToggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YHIDDEN")) == "YES"

proc `ymax=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax=`*(ih: FlatToggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: FlatToggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMAX"))

proc `ymin=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin=`*(ih: FlatToggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: FlatToggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: FlatToggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMIN"))

proc `zorder=`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: FlatToggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `destroy_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: FlatToggle_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FlatToggle_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `flat_action=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # FLAT_ACTION: Action generated when the button 1 (usually left)
    # is selected. This callback is called only after the mouse is
    # released and when it is released inside the button area. int
    # function(Ihandle* ih, int state); [in C]ih:action(state: number)
    # -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("FLAT_ACTION"), cast[Icallback](cb))

proc `flat_action`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_ACTION"), cast[Icallback](cb))

proc `flat_action`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_ACTION")))

proc `flat_button_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_BUTTON_CB"), cast[Icallback](cb))

proc `flat_button_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_BUTTON_CB"), cast[Icallback](cb))

proc `flat_button_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_BUTTON_CB")))

proc `flat_enterwindow_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_ENTERWINDOW_CB"), cast[Icallback](cb))

proc `flat_enterwindow_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_ENTERWINDOW_CB"), cast[Icallback](cb))

proc `flat_enterwindow_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_ENTERWINDOW_CB")))

proc `flat_focus_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_FOCUS_CB"), cast[Icallback](cb))

proc `flat_focus_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_FOCUS_CB"), cast[Icallback](cb))

proc `flat_focus_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_FOCUS_CB")))

proc `flat_leavewindow_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `flat_leavewindow_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `flat_leavewindow_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_LEAVEWINDOW_CB")))

proc `flat_motion_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_MOTION_CB"), cast[Icallback](cb))

proc `flat_motion_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_MOTION_CB"), cast[Icallback](cb))

proc `flat_motion_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_MOTION_CB")))

proc `focus_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `keypress_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    # KEYPRESS_CB KEYPRESS_CB Action generated when a key is pressed
    # or released. If the key is pressed and held several calls will
    # occur. It is called after the callback K_ANY is processed.
    # Callback int function(Ihandle *ih, int c, int press); [in C]
    # ih:keypress_cb(c, press: number) -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. c:
    # identifier of typed key. Please refer to the Keyboard Codes
    # table for a list of possible values. press: 1 is the user
    # pressed the key or 0 otherwise. Returns: If IUP_IGNORE is
    # returned the key is ignored by the system. IUP_CLOSE will be
    # processed. Affects IupCanvas
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB")))

proc `killfocus_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `postmessage_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `scroll_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    # SCROLL_CB SCROLL_CB Called when some manipulation is made to the
    # scrollbar. The canvas is automatically redrawn only if this
    # callback is NOT defined. (GTK 2.8) Also the POSX and POSY values
    # will not be correctly updated for older GTK versions. In Ubuntu,
    # when liboverlay-scrollbar is enabled (the new tiny auto-hide
    # scrollbar) only the IUP_SBPOSV and IUP_SBPOSH codes are used.
    # Callback int function(Ihandle *ih, int op, float posx, float
    # posy); [in C] ih:scroll_cb(op, posx, posy: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. op: indicates the operation performed on the
    # scrollbar. If the manipulation was made on the vertical
    # scrollbar, it can have the following values: IUP_SBUP - line up
    # IUP_SBDN - line down IUP_SBPGUP - page up IUP_SBPGDN - page down
    # IUP_SBPOSV - vertical positioning IUP_SBDRAGV - vertical drag If
    # it was on the horizontal scrollbar, the following values are
    # valid: IUP_SBLEFT - column left IUP_SBRIGHT - column right
    # IUP_SBPGLEFT - page left IUP_SBPGRIGHT - page right IUP_SBPOSH -
    # horizontal positioning IUP_SBDRAGH - horizontal drag posx, posy:
    # the same as the ACTION canvas callback (corresponding to the
    # values of attributes POSX and POSY). Notes IUP_SBDRAGH and
    # IUP_SBDRAGV are not supported in GTK. During drag IUP_SBPOSH and
    # IUP_SBPOSV are used. In Windows, after a drag when mouse is
    # released IUP_SBPOSH or IUP_SBPOSV are called. Affects IupCanvas,
    # IupGLCanvas, SCROLLBAR
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SCROLL_CB")))

proc `unmap_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `valuechanged_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # VALUECHANGED_CB: Called after the value was interactively
    # changed by the user. Called after the ACTION callback, but under
    # the same context. int function(Ihandle *ih); [in
    # C]ih:valuechanged_cb() -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB")))

proc `wheel_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # WHEEL_CB WHEEL_CB Action generated when the mouse wheel is
    # rotated. If this callback is not defined the wheel will
    # automatically scroll the canvas in the vertical direction by
    # some lines, the SCROLL_CB callback if defined will be called
    # with the IUP_SBDRAGV operation. Callback int function(Ihandle
    # *ih, float delta, int x, int y, char *status); [in C]
    # ih:wheel_cb(delta, x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. delta: the amount the wheel was rotated in notches.
    # x, y: position in the canvas where the event has occurred, in
    # pixels. status: status of mouse buttons and certain keyboard
    # keys at the moment the event was generated. The same macros used
    # for BUTTON_CB can be used for this status. Notes In Motif and
    # GTK delta is always 1 or -1. In Windows is some situations delta
    # can reach the value of two. In the future with more precise
    # wheels this increment can be changed. Affects IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WHEEL_CB")))

proc `wom_cb=`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # WOM_CB WOM_CB Action generated when an audio device receives an
    # event. [Windows Only] Callback int function(Ihandle *ih, int
    # state); [in C] ih:wom_cb(state: number) -> (ret: number) [in
    # Lua] ih: identifies the element that activated the event. state:
    # can be opening=1, done=0, or closing=-1. Notes This callback is
    # used to syncronize video playback with audio. It is sent when
    # the audio device: Message Description opening is opened by using
    # the waveOutOpen function. done is finished with a data block
    # sent by using the waveOutWrite function. closing is closed by
    # using the waveOutClose function. You must use the HWND attribute
    # when calling waveOutOpen in the dwCallback parameter and set
    # fdwOpen to CALLBACK_WINDOW. Affects IupDialog, IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: FlatToggle_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: FlatToggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WOM_CB")))

proc FlatTree*(): FlatTree_t {.cdecl.} =
    # Creates a tree containing nodes of branches or leaves. Both
    # branches and leaves can have an associated text and image. The
    # branches can be expanded or collapsed. When a branch is
    # expanded, its immediate children are visible, and when it is
    # collapsed they are hidden. The leaves can generate an "executed"
    # or "renamed" actions, branches can only generate a "renamed"
    # action. The focus node is the node with the focus rectangle,
    # marked nodes have their background inverted. It behaves like
    # IupFlatTree but it does not depends on the native system. It
    # inherits from IupCanvas.
    return FlatTree_t(niupc.FlatTree())

proc `active=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

# TODO getter flattree ADDBRANCH
proc `addexpanded=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ADDEXPANDED"), cstring(value))

proc `addexpanded`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ADDEXPANDED"), cstring(value))

proc `addexpanded=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ADDEXPANDED"), cstring((if yes: "YES" else: "NO")))

proc `addexpanded`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ADDEXPANDED"), cstring((if yes: "YES" else: "NO")))

proc `addexpanded`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ADDEXPANDED")) == "YES"

# TODO getter flattree ADDLEAF
proc `arrowimages=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGES"), cstring(value))

proc `arrowimages`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGES"), cstring(value))

proc `arrowimages=`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGES"), cstring(&"{x}"))

proc `arrowimages`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGES"), cstring(&"{x}"))

proc `arrowimages`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ARROWIMAGES"))

proc `autoredraw=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    # AUTOREDRAW BGCOLOR BORDERCOLOR(*)BORDERWIDTH(*)COUNT
    # EXPANDEXTRATEXTWIDTH(*) FGCOLORHLCOLOR(*)
    # HLCOLORALPHA(*)PSCOLOR(*)TEXTPSCOLOR(*)ICONSPACING(*)
    # INDENTATION RASTERSIZE SPACING TOPITEM
    SetAttribute(cast[PIhandle](ih), cstring("AUTOREDRAW"), cstring(value))

proc `autoredraw`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOREDRAW"), cstring(value))

proc `autoredraw=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOREDRAW"), cstring((if yes: "YES" else: "NO")))

proc `autoredraw`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOREDRAW"), cstring((if yes: "YES" else: "NO")))

# TODO getter flattree BACKCOLOR
proc `backimage=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGE"), cast[PIhandle](handle))

proc `backimage`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGE"), cast[PIhandle](handle))

proc `backimage`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGE"))

proc `backimagezoom=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring(value))

proc `backimagezoom`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring(value))

proc `backimagezoom=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring((if yes: "YES" else: "NO")))

proc `backimagezoom`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring((if yes: "YES" else: "NO")))

proc `backimagezoom`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM")) == "YES"

proc `backingstore=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE")) == "YES"

proc `bgcolor=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    # AUTOREDRAW BGCOLOR BORDERCOLOR(*)BORDERWIDTH(*)COUNT
    # EXPANDEXTRATEXTWIDTH(*) FGCOLORHLCOLOR(*)
    # HLCOLORALPHA(*)PSCOLOR(*)TEXTPSCOLOR(*)ICONSPACING(*)
    # INDENTATION RASTERSIZE SPACING TOPITEM
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: FlatTree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FlatTree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `bordercolor=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(value))

proc `bordercolor`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(value))

proc `bordercolor=`*(ih: FlatTree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bordercolor`*(ih: FlatTree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bordercolor`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"))

proc `borderwidth=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(value))

proc `borderwidth`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(value))

proc `borderwidth=`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(&"{x}"))

proc `borderwidth`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(&"{x}"))

proc `borderwidth`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"))

# TODO unknown: flattree BUTTONBGCOLOR Unknown Binary
proc `buttonbgcolor`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BUTTONBGCOLOR"))

# TODO unknown: flattree BUTTONBRDCOLOR Unknown Binary
proc `buttonbrdcolor`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BUTTONBRDCOLOR"))

# TODO unknown: flattree BUTTONFGCOLOR Unknown Binary
proc `buttonfgcolor`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BUTTONFGCOLOR"))

proc `buttonminusimage=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BUTTONMINUSIMAGE"), cast[PIhandle](handle))

proc `buttonminusimage`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BUTTONMINUSIMAGE"), cast[PIhandle](handle))

proc `buttonminusimage`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BUTTONMINUSIMAGE"))

proc `buttonplusimage=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BUTTONPLUSIMAGE"), cast[PIhandle](handle))

proc `buttonplusimage`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BUTTONPLUSIMAGE"), cast[PIhandle](handle))

proc `buttonplusimage`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BUTTONPLUSIMAGE"))

# TODO unknown: flattree BUTTONSIZE Unknown Binary
proc `buttonsize`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BUTTONSIZE"))

proc `canfocus=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

# TODO getter flattree CHILDCOUNT
# TODO getter flattree COLOR
# TODO getter flattree COPYNODE
proc `count`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("COUNT"))

proc `cspacing=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(value))

proc `cspacing`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(value))

proc `cspacing=`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(&"{x}"))

proc `cspacing`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(&"{x}"))

proc `cspacing`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CSPACING"))

proc `cursor=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

# TODO getter flattree DELNODE
# TODO getter flattree DEPTH
proc `dragdrop=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragdroptree=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    # DRAGDROPTREE DROPFILESTARGET DROPEQUALDRAG SHOWDRAGDROP
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROPTREE"), cstring(value))

proc `dragdroptree`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROPTREE"), cstring(value))

proc `dragdroptree=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROPTREE"), cstring((if yes: "YES" else: "NO")))

proc `dragdroptree`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROPTREE"), cstring((if yes: "YES" else: "NO")))

proc `dragdroptree`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROPTREE")) == "YES"

proc `dragsource=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary flattree
proc `dragtypes`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

# TODO unknown: flattree DRAWABLE Unknown Binary
proc `drawable`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWABLE"))

proc `drawbgcolor=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor=`*(ih: FlatTree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: FlatTree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"))

proc `drawcolor=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor=`*(ih: FlatTree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: FlatTree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"))

proc `drawdriver`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWDRIVER"))

proc `drawfont=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

proc `drawfont`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

# TODO ??? String Binary flattree
proc `drawfont`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"))

proc `drawlinewidth=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth=`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"))

proc `drawmakeinactive=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE")) == "YES"

proc `drawsize`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSIZE"))

proc `drawstyle=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"))

proc `drawtextalignment=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"))

proc `drawtextclip=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP")) == "YES"

proc `drawtextellipsis=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS")) == "YES"

proc `drawtextlayoutcenter=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER")) == "YES"

proc `drawtextorientation=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation=`*(ih: FlatTree_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: FlatTree_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"))

proc `drawtextwrap=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP")) == "YES"

proc `dropequaldrag=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    # DRAGDROPTREE DROPFILESTARGET DROPEQUALDRAG SHOWDRAGDROP
    SetAttribute(cast[PIhandle](ih), cstring("DROPEQUALDRAG"), cstring(value))

proc `dropequaldrag`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPEQUALDRAG"), cstring(value))

proc `dropequaldrag=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPEQUALDRAG"), cstring((if yes: "YES" else: "NO")))

proc `dropequaldrag`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPEQUALDRAG"), cstring((if yes: "YES" else: "NO")))

proc `dropequaldrag`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPEQUALDRAG")) == "YES"

proc `dropfilestarget=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    # DRAGDROPTREE DROPFILESTARGET DROPEQUALDRAG SHOWDRAGDROP
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary flattree
proc `droptypes`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `dx=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx=`*(ih: FlatTree_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: FlatTree_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DX"))

proc `dy=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy=`*(ih: FlatTree_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: FlatTree_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DY"))

# TODO unknown: flattree EMPTYTOGGLE Unknown Binary
proc `emptytoggle`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EMPTYTOGGLE"))

proc `expand=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandall=`*(ih: FlatTree_t, ) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDALL"), cstring(""))

proc `expandall`*(ih: FlatTree_t, ) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDALL"), cstring(""))

proc `expandweight=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: FlatTree_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FlatTree_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

# TODO getter flattree EXTRATEXT
# TODO unknown: flattree EXTRATEXTWIDTH Unknown Binary
proc `extratextwidth`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXTRATEXTWIDTH"))

proc `fgcolor=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: FlatTree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: FlatTree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

# TODO getter flattree FIRST
# TODO unknown: flattree FLATSCROLLBAR Unknown Binary
proc `flatscrollbar`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLATSCROLLBAR"))

proc `floating=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

# TODO unknown: flattree FLOATINGDELAY Unknown Binary
proc `floatingdelay`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATINGDELAY"))

proc `focusfeedback=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring(value))

proc `focusfeedback`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring(value))

proc `focusfeedback=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring((if yes: "YES" else: "NO")))

proc `focusfeedback`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring((if yes: "YES" else: "NO")))

proc `focusfeedback`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK")) == "YES"

proc `font=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary flattree
proc `font`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary flattree
proc `fontface`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary flattree
proc `fontstyle`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary flattree
proc `handlename`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `hasfocus`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HASFOCUS")) == "YES"

proc `hidebuttons=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    # HIDELINES HIDEBUTTONS LINECOLOR(*)
    # BUTTONBGCOLOR(*)BUTTONFGCOLOR(*) BUTTONBRDCOLOR(*)BUTTONSIZE(*)
    # BUTTONPLUSIMAGE(*)BUTTONMINUSIMAGE(*)
    SetAttribute(cast[PIhandle](ih), cstring("HIDEBUTTONS"), cstring(value))

proc `hidebuttons`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDEBUTTONS"), cstring(value))

proc `hidebuttons=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDEBUTTONS"), cstring((if yes: "YES" else: "NO")))

proc `hidebuttons`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDEBUTTONS"), cstring((if yes: "YES" else: "NO")))

proc `hidebuttons`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIDEBUTTONS")) == "YES"

proc `hidelines=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    # HIDELINES HIDEBUTTONS LINECOLOR(*)
    # BUTTONBGCOLOR(*)BUTTONFGCOLOR(*) BUTTONBRDCOLOR(*)BUTTONSIZE(*)
    # BUTTONPLUSIMAGE(*)BUTTONMINUSIMAGE(*)
    SetAttribute(cast[PIhandle](ih), cstring("HIDELINES"), cstring(value))

proc `hidelines`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDELINES"), cstring(value))

proc `hidelines=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDELINES"), cstring((if yes: "YES" else: "NO")))

proc `hidelines`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDELINES"), cstring((if yes: "YES" else: "NO")))

proc `hidelines`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIDELINES")) == "YES"

proc `hlcolor=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(value))

proc `hlcolor`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(value))

proc `hlcolor=`*(ih: FlatTree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `hlcolor`*(ih: FlatTree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `hlcolor`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"))

proc `hlcoloralpha=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLORALPHA"), cstring(value))

proc `hlcoloralpha`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLORALPHA"), cstring(value))

proc `hlcoloralpha=`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLORALPHA"), cstring(&"{x}"))

proc `hlcoloralpha`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLORALPHA"), cstring(&"{x}"))

proc `hlcoloralpha`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HLCOLORALPHA"))

proc `iconspacing=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ICONSPACING"), cstring(value))

proc `iconspacing`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ICONSPACING"), cstring(value))

proc `iconspacing=`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ICONSPACING"), cstring(&"{x}"))

proc `iconspacing`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ICONSPACING"), cstring(&"{x}"))

proc `iconspacing`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ICONSPACING"))

# TODO getter flattree IMAGE
proc `imagebranchcollapsed=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGEIMAGEEXPANDEDIMAGELEAF IMAGEBRANCHCOLLAPSED
    # IMAGEBRANCHEXPANDEDBACKIMAGE(*)BACKIMAGEZOOM(*)
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEBRANCHCOLLAPSED"), cast[PIhandle](handle))

proc `imagebranchcollapsed`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEBRANCHCOLLAPSED"), cast[PIhandle](handle))

proc `imagebranchcollapsed`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEBRANCHCOLLAPSED"))

proc `imagebranchexpanded=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEBRANCHEXPANDED"), cast[PIhandle](handle))

proc `imagebranchexpanded`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEBRANCHEXPANDED"), cast[PIhandle](handle))

proc `imagebranchexpanded`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEBRANCHEXPANDED"))

# TODO getter flattree IMAGEEXPANDED
proc `imageleaf=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGELEAF"), cast[PIhandle](handle))

proc `imageleaf`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGELEAF"), cast[PIhandle](handle))

proc `imageleaf`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGELEAF"))

proc `indentation=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("INDENTATION"), cstring(value))

proc `indentation`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("INDENTATION"), cstring(value))

proc `indentation=`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("INDENTATION"), cstring(&"{x}"))

proc `indentation`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("INDENTATION"), cstring(&"{x}"))

proc `indentation`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("INDENTATION"))

# TODO getter flattree INSERTBRANCH
# TODO getter flattree INSERTLEAF
# TODO getter flattree ITEMTIP
# TODO getter flattree KIND
# TODO getter flattree LAST
proc `lastaddnode`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LASTADDNODE"))

# TODO unknown: flattree LINECOLOR Unknown Binary
proc `linecolor`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINECOLOR"))

proc `linex=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex=`*(ih: FlatTree_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: FlatTree_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEX"))

proc `liney=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney=`*(ih: FlatTree_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: FlatTree_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEY"))

proc `mark=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    # MARK MARKED MARKEDNODESMARKMODE MARKSTARTMARKWHENTOGGLE
    SetAttribute(cast[PIhandle](ih), cstring("MARK"), cstring(value))

proc `mark`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARK"), cstring(value))

# TODO getter flattree MARKED
proc `markednodes=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKEDNODES"), cstring(value))

proc `markednodes`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKEDNODES"), cstring(value))

# TODO ??? String Binary flattree
proc `markednodes`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MARKEDNODES"))

proc `markmode=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKMODE"), cstring(value))

proc `markmode`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKMODE"), cstring(value))

proc `markmode`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MARKMODE"))

proc `markstart=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKSTART"), cstring(value))

proc `markstart`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKSTART"), cstring(value))

proc `markstart=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKSTART"), cstring((if yes: "YES" else: "NO")))

proc `markstart`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKSTART"), cstring((if yes: "YES" else: "NO")))

proc `markstart`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MARKSTART")) == "YES"

proc `markwhentoggle=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKWHENTOGGLE"), cstring(value))

proc `markwhentoggle`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKWHENTOGGLE"), cstring(value))

proc `markwhentoggle=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKWHENTOGGLE"), cstring((if yes: "YES" else: "NO")))

proc `markwhentoggle`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKWHENTOGGLE"), cstring((if yes: "YES" else: "NO")))

proc `markwhentoggle`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MARKWHENTOGGLE")) == "YES"

proc `maxsize=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: FlatTree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FlatTree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: FlatTree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FlatTree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

# TODO getter flattree MOVENODE
proc `name=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary flattree
proc `name`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

# TODO getter flattree NEXT
proc `normalizergroup=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary flattree
proc `normalizergroup`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary flattree
proc `ntheme`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: flattree PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: flattree PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

# TODO getter flattree PARENT
proc `position=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: FlatTree_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FlatTree_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `posx=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx=`*(ih: FlatTree_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: FlatTree_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSX"))

proc `posy=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy=`*(ih: FlatTree_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: FlatTree_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSY"))

# TODO getter flattree PREVIOUS
proc `propagatefocus=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `pscolor=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(value))

proc `pscolor`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(value))

proc `pscolor=`*(ih: FlatTree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `pscolor`*(ih: FlatTree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `pscolor`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"))

proc `rastersize=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: FlatTree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FlatTree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `rename=`*(ih: FlatTree_t, ) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RENAME"), cstring(""))

proc `rename`*(ih: FlatTree_t, ) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RENAME"), cstring(""))

proc `renamecaret=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RENAMECARET"), cstring(value))

proc `renamecaret`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RENAMECARET"), cstring(value))

# TODO ??? String Binary flattree
proc `renamecaret`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RENAMECARET"))

proc `renameselection=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RENAMESELECTION"), cstring(value))

proc `renameselection`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RENAMESELECTION"), cstring(value))

# TODO ??? String Binary flattree
proc `renameselection`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RENAMESELECTION"))

proc `rootcount`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ROOTCOUNT"))

# TODO unknown: flattree SB_BACKCOLOR Unknown Binary
proc `sb_backcolor`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_BACKCOLOR"))

# TODO unknown: flattree SB_FORECOLOR Unknown Binary
proc `sb_forecolor`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_FORECOLOR"))

# TODO unknown: flattree SB_HIGHCOLOR Unknown Binary
proc `sb_highcolor`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_HIGHCOLOR"))

proc `sb_imagebottom=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOM"), cast[PIhandle](handle))

proc `sb_imagebottom`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOM"), cast[PIhandle](handle))

proc `sb_imagebottom`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOM"))

proc `sb_imagebottomhighlight=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagebottomhighlight`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagebottomhighlight`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMHIGHLIGHT"))

proc `sb_imagebottominactive=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMINACTIVE"), cast[PIhandle](handle))

proc `sb_imagebottominactive`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMINACTIVE"), cast[PIhandle](handle))

proc `sb_imagebottominactive`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMINACTIVE"))

proc `sb_imagebottompress=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMPRESS"), cast[PIhandle](handle))

proc `sb_imagebottompress`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMPRESS"), cast[PIhandle](handle))

proc `sb_imagebottompress`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGEBOTTOMPRESS"))

proc `sb_imageleft=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFT"), cast[PIhandle](handle))

proc `sb_imageleft`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFT"), cast[PIhandle](handle))

proc `sb_imageleft`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGELEFT"))

proc `sb_imagelefthighlight=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFTHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagelefthighlight`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFTHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagelefthighlight`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGELEFTHIGHLIGHT"))

proc `sb_imageleftinactive=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFTINACTIVE"), cast[PIhandle](handle))

proc `sb_imageleftinactive`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFTINACTIVE"), cast[PIhandle](handle))

proc `sb_imageleftinactive`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGELEFTINACTIVE"))

proc `sb_imageleftpress=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFTPRESS"), cast[PIhandle](handle))

proc `sb_imageleftpress`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGELEFTPRESS"), cast[PIhandle](handle))

proc `sb_imageleftpress`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGELEFTPRESS"))

proc `sb_imageright=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHT"), cast[PIhandle](handle))

proc `sb_imageright`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHT"), cast[PIhandle](handle))

proc `sb_imageright`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGERIGHT"))

proc `sb_imagerighthighlight=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHTHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagerighthighlight`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHTHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagerighthighlight`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGERIGHTHIGHLIGHT"))

proc `sb_imagerightinactive=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHTINACTIVE"), cast[PIhandle](handle))

proc `sb_imagerightinactive`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHTINACTIVE"), cast[PIhandle](handle))

proc `sb_imagerightinactive`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGERIGHTINACTIVE"))

proc `sb_imagerightpress=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHTPRESS"), cast[PIhandle](handle))

proc `sb_imagerightpress`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGERIGHTPRESS"), cast[PIhandle](handle))

proc `sb_imagerightpress`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGERIGHTPRESS"))

proc `sb_imagetop=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOP"), cast[PIhandle](handle))

proc `sb_imagetop`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOP"), cast[PIhandle](handle))

proc `sb_imagetop`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGETOP"))

proc `sb_imagetophighlight=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOPHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagetophighlight`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOPHIGHLIGHT"), cast[PIhandle](handle))

proc `sb_imagetophighlight`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGETOPHIGHLIGHT"))

proc `sb_imagetopinactive=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOPINACTIVE"), cast[PIhandle](handle))

proc `sb_imagetopinactive`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOPINACTIVE"), cast[PIhandle](handle))

proc `sb_imagetopinactive`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGETOPINACTIVE"))

proc `sb_imagetoppress=`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOPPRESS"), cast[PIhandle](handle))

proc `sb_imagetoppress`*(ih: FlatTree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SB_IMAGETOPPRESS"), cast[PIhandle](handle))

proc `sb_imagetoppress`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_IMAGETOPPRESS"))

# TODO unknown: flattree SB_PRESSCOLOR Unknown Binary
proc `sb_presscolor`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_PRESSCOLOR"))

proc `sb_resize`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_RESIZE"))

proc `screenposition`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `scrollbar=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR")) == "YES"

# TODO unknown: flattree SCROLLBARSIZE Unknown Binary
proc `scrollbarsize`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBARSIZE"))

# TODO unknown: flattree SHOWARROWS Unknown Binary
proc `showarrows`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWARROWS"))

proc `showdragdrop=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    # DRAGDROPTREE DROPFILESTARGET DROPEQUALDRAG SHOWDRAGDROP
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDRAGDROP"), cstring(value))

proc `showdragdrop`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDRAGDROP"), cstring(value))

proc `showdragdrop=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `showdragdrop`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `showdragdrop`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWDRAGDROP")) == "YES"

# TODO unknown: flattree SHOWFLOATING Unknown Binary
proc `showfloating`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWFLOATING"))

proc `showrename=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWRENAME"), cstring(value))

proc `showrename`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWRENAME"), cstring(value))

proc `showrename=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWRENAME"), cstring((if yes: "YES" else: "NO")))

proc `showrename`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWRENAME"), cstring((if yes: "YES" else: "NO")))

proc `showrename`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWRENAME")) == "YES"

proc `showtoggle=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWTOGGLE"), cstring(value))

proc `showtoggle`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWTOGGLE"), cstring(value))

proc `showtoggle=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWTOGGLE"), cstring((if yes: "YES" else: "NO")))

proc `showtoggle`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWTOGGLE"), cstring((if yes: "YES" else: "NO")))

proc `showtoggle`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWTOGGLE")) == "YES"

# TODO unknown: flattree SHOWTRANSPARENT Unknown Binary
proc `showtransparent`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWTRANSPARENT"))

proc `size=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: FlatTree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FlatTree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `spacing=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    # The SPACING attribute is simply the vertical space between each
    # node, different from the IupTree.
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(value))

proc `spacing`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(value))

proc `spacing=`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(&"{x}"))

proc `spacing`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(&"{x}"))

proc `spacing`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPACING"))

# TODO getter flattree STATE
proc `textpscolor=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"), cstring(value))

proc `textpscolor`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"), cstring(value))

proc `textpscolor=`*(ih: FlatTree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `textpscolor`*(ih: FlatTree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `textpscolor`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXTPSCOLOR"))

proc `theme=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary flattree
proc `theme`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary flattree
proc `tip`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: FlatTree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FlatTree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: FlatTree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FlatTree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary flattree
proc `tipicon`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary flattree
proc `tipmarkup`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: FlatTree_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FlatTree_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

# TODO getter flattree TITLE
# TODO getter flattree TITLEFONT
# TODO getter flattree TITLEFONTSIZE
# TODO getter flattree TITLEFONTSTYLE
# TODO unknown: flattree TOGGLEBGCOLOR Unknown Binary
proc `togglebgcolor`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOGGLEBGCOLOR"))

# TODO unknown: flattree TOGGLEFGCOLOR Unknown Binary
proc `togglefgcolor`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOGGLEFGCOLOR"))

# TODO unknown: flattree TOGGLESIZE Unknown Binary
proc `togglesize`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOGGLESIZE"))

# TODO getter flattree TOGGLEVALUE
# TODO getter flattree TOGGLEVISIBLE
proc `topitem=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPITEM"), cstring(value))

proc `topitem`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPITEM"), cstring(value))

proc `topitem=`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPITEM"), cstring(&"{x}"))

proc `topitem`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPITEM"), cstring(&"{x}"))

# TODO getter flattree TOTALCHILDCOUNT
proc `touch=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOUCH")) == "YES"

# TODO getter flattree USERDATA
proc `usersize=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: FlatTree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FlatTree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value=`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(&"{x}"))

proc `value`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(&"{x}"))

proc `value`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `visible=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wheeldropfocus=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus=`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: FlatTree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS")) == "YES"

proc `wid`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

proc `xautohide`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE")) == "YES"

proc `xdisplay`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XDISPLAY"))

# TODO unknown: flattree XFONTID Unknown Binary
proc `xfontid`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `xhidden`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XHIDDEN")) == "YES"

proc `xmax=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax=`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMAX"))

proc `xmin=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin=`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMIN"))

# TODO unknown: flattree XWINDOW Unknown Binary
proc `xwindow`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `yautohide`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE")) == "YES"

proc `yhidden`*(ih: FlatTree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YHIDDEN")) == "YES"

proc `ymax=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax=`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMAX"))

proc `ymin=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin=`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: FlatTree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: FlatTree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMIN"))

proc `zorder=`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: FlatTree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `branchclose_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BRANCHCLOSE_CB"), cast[Icallback](cb))

proc `branchclose_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BRANCHCLOSE_CB"), cast[Icallback](cb))

proc `branchclose_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BRANCHCLOSE_CB")))

proc `branchopen_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BRANCHOPEN_CB"), cast[Icallback](cb))

proc `branchopen_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BRANCHOPEN_CB"), cast[Icallback](cb))

proc `branchopen_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BRANCHOPEN_CB")))

proc `button_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `destroy_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragdrop_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, drag_id, drop_id, isshift, iscontrol: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDROP_CB"), cast[Icallback](cb))

proc `dragdrop_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, drag_id, drop_id, isshift, iscontrol: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDROP_CB"), cast[Icallback](cb))

proc `dragdrop_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDROP_CB")))

proc `dragend_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: FlatTree_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FlatTree_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `executebranch_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("EXECUTEBRANCH_CB"), cast[Icallback](cb))

proc `executebranch_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("EXECUTEBRANCH_CB"), cast[Icallback](cb))

proc `executebranch_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("EXECUTEBRANCH_CB")))

proc `executeleaf_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("EXECUTELEAF_CB"), cast[Icallback](cb))

proc `executeleaf_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("EXECUTELEAF_CB"), cast[Icallback](cb))

proc `executeleaf_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("EXECUTELEAF_CB")))

proc `flat_button_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_BUTTON_CB"), cast[Icallback](cb))

proc `flat_button_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_BUTTON_CB"), cast[Icallback](cb))

proc `flat_button_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_BUTTON_CB")))

proc `flat_focus_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_FOCUS_CB"), cast[Icallback](cb))

proc `flat_focus_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_FOCUS_CB"), cast[Icallback](cb))

proc `flat_focus_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_FOCUS_CB")))

proc `flat_leavewindow_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `flat_leavewindow_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `flat_leavewindow_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_LEAVEWINDOW_CB")))

proc `flat_motion_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_MOTION_CB"), cast[Icallback](cb))

proc `flat_motion_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_MOTION_CB"), cast[Icallback](cb))

proc `flat_motion_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_MOTION_CB")))

proc `focus_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `keypress_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    # KEYPRESS_CB KEYPRESS_CB Action generated when a key is pressed
    # or released. If the key is pressed and held several calls will
    # occur. It is called after the callback K_ANY is processed.
    # Callback int function(Ihandle *ih, int c, int press); [in C]
    # ih:keypress_cb(c, press: number) -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. c:
    # identifier of typed key. Please refer to the Keyboard Codes
    # table for a list of possible values. press: 1 is the user
    # pressed the key or 0 otherwise. Returns: If IUP_IGNORE is
    # returned the key is ignored by the system. IUP_CLOSE will be
    # processed. Affects IupCanvas
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB")))

proc `killfocus_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FlatTree_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `multiselection_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: ptr cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MULTISELECTION_CB"), cast[Icallback](cb))

proc `multiselection_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: ptr cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MULTISELECTION_CB"), cast[Icallback](cb))

proc `multiselection_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MULTISELECTION_CB")))

proc `multiunselection_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: ptr cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MULTIUNSELECTION_CB"), cast[Icallback](cb))

proc `multiunselection_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: ptr cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MULTIUNSELECTION_CB"), cast[Icallback](cb))

proc `multiunselection_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MULTIUNSELECTION_CB")))

proc `noderemoved_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("NODEREMOVED_CB"), cast[Icallback](cb))

proc `noderemoved_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("NODEREMOVED_CB"), cast[Icallback](cb))

proc `noderemoved_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("NODEREMOVED_CB")))

proc `postmessage_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `rename_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RENAME_CB"), cast[Icallback](cb))

proc `rename_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RENAME_CB"), cast[Icallback](cb))

proc `rename_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RENAME_CB")))

proc `resize_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `rightclick_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RIGHTCLICK_CB"), cast[Icallback](cb))

proc `rightclick_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RIGHTCLICK_CB"), cast[Icallback](cb))

proc `rightclick_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RIGHTCLICK_CB")))

proc `scroll_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    # SCROLL_CB SCROLL_CB Called when some manipulation is made to the
    # scrollbar. The canvas is automatically redrawn only if this
    # callback is NOT defined. (GTK 2.8) Also the POSX and POSY values
    # will not be correctly updated for older GTK versions. In Ubuntu,
    # when liboverlay-scrollbar is enabled (the new tiny auto-hide
    # scrollbar) only the IUP_SBPOSV and IUP_SBPOSH codes are used.
    # Callback int function(Ihandle *ih, int op, float posx, float
    # posy); [in C] ih:scroll_cb(op, posx, posy: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. op: indicates the operation performed on the
    # scrollbar. If the manipulation was made on the vertical
    # scrollbar, it can have the following values: IUP_SBUP - line up
    # IUP_SBDN - line down IUP_SBPGUP - page up IUP_SBPGDN - page down
    # IUP_SBPOSV - vertical positioning IUP_SBDRAGV - vertical drag If
    # it was on the horizontal scrollbar, the following values are
    # valid: IUP_SBLEFT - column left IUP_SBRIGHT - column right
    # IUP_SBPGLEFT - page left IUP_SBPGRIGHT - page right IUP_SBPOSH -
    # horizontal positioning IUP_SBDRAGH - horizontal drag posx, posy:
    # the same as the ACTION canvas callback (corresponding to the
    # values of attributes POSX and POSY). Notes IUP_SBDRAGH and
    # IUP_SBDRAGV are not supported in GTK. During drag IUP_SBPOSH and
    # IUP_SBPOSV are used. In Windows, after a drag when mouse is
    # released IUP_SBPOSH or IUP_SBPOSV are called. Affects IupCanvas,
    # IupGLCanvas, SCROLLBAR
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SCROLL_CB")))

proc `selection_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    # SELECTION_CB: Action generated when an node is selected or
    # deselected. MULTISELECTION_CB: Action generated when multiple
    # nodes are selected with the mouse and the shift key pressed.
    # MULTIUNSELECTION_CB: Action generated before multiple nodes are
    # unselected in one single operation. BRANCHOPEN_CB: Action
    # generated when a branch is expanded. BRANCHCLOSE_CB: Action
    # generated when a branch is collapsed. EXECUTELEAF_CB: Action
    # generated when a leaf is executed. EXECUTEBRANCH_CB: Action
    # generated when a branch is executed. SHOWRENAME_CB: Action
    # generated before a node is renamed. RENAME_CB: Action generated
    # after a node is renamed. DRAGDROP_CB: Action generated when an
    # internal drag & drop is executed. NODEREMOVED_CB: Action
    # generated when a node is about to be removed. RIGHTCLICK_CB:
    # Action generated when the right mouse button is pressed over a
    # node. TOGGLEVALUE_CB: Action generated when the toggle&#39;s
    # state was changed. The callback also receives the new
    # toggle&#39;s state.
    SetCallback(cast[PIhandle](ih), cstring("SELECTION_CB"), cast[Icallback](cb))

proc `selection_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SELECTION_CB"), cast[Icallback](cb))

proc `selection_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SELECTION_CB")))

proc `showrename_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SHOWRENAME_CB"), cast[Icallback](cb))

proc `showrename_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SHOWRENAME_CB"), cast[Icallback](cb))

proc `showrename_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SHOWRENAME_CB")))

proc `togglevalue_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("TOGGLEVALUE_CB"), cast[Icallback](cb))

proc `togglevalue_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("TOGGLEVALUE_CB"), cast[Icallback](cb))

proc `togglevalue_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("TOGGLEVALUE_CB")))

proc `unmap_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `wheel_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # WHEEL_CB WHEEL_CB Action generated when the mouse wheel is
    # rotated. If this callback is not defined the wheel will
    # automatically scroll the canvas in the vertical direction by
    # some lines, the SCROLL_CB callback if defined will be called
    # with the IUP_SBDRAGV operation. Callback int function(Ihandle
    # *ih, float delta, int x, int y, char *status); [in C]
    # ih:wheel_cb(delta, x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. delta: the amount the wheel was rotated in notches.
    # x, y: position in the canvas where the event has occurred, in
    # pixels. status: status of mouse buttons and certain keyboard
    # keys at the moment the event was generated. The same macros used
    # for BUTTON_CB can be used for this status. Notes In Motif and
    # GTK delta is always 1 or -1. In Windows is some situations delta
    # can reach the value of two. In the future with more precise
    # wheels this increment can be changed. Affects IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WHEEL_CB")))

proc `wom_cb=`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # WOM_CB WOM_CB Action generated when an audio device receives an
    # event. [Windows Only] Callback int function(Ihandle *ih, int
    # state); [in C] ih:wom_cb(state: number) -> (ret: number) [in
    # Lua] ih: identifies the element that activated the event. state:
    # can be opening=1, done=0, or closing=-1. Notes This callback is
    # used to syncronize video playback with audio. It is sent when
    # the audio device: Message Description opening is opened by using
    # the waveOutOpen function. done is finished with a data block
    # sent by using the waveOutWrite function. closing is closed by
    # using the waveOutClose function. You must use the HWND attribute
    # when calling waveOutOpen in the dwCallback parameter and set
    # fdwOpen to CALLBACK_WINDOW. Affects IupDialog, IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: FlatTree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: FlatTree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WOM_CB")))

proc FlatVal*(`type`: string): FlatVal_t {.cdecl.} =
    # Creates a Valuator control, but it does not have native
    # decorations. Selects a value in a limited interval. Also known
    # as Scale or Trackbar in native systems. It behaves just like an
    # IupVal, but since it is not a native control it has more
    # flexibility for additional options. But ticks are NOT supported.
    # It inherits from IupCanvas.
    return FlatVal_t(niupc.FlatVal(cstring(`type`)))

proc `active=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    # ACTIVE, EXPAND, FONT, SCREENPOSITION, POSITION, MINSIZE,
    # MAXSIZE, WID, TIP, SIZE, ZORDER, VISIBLE, THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `backimage=`*(ih: FlatVal_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # BACKIMAGE (non inheritable): image name to be used as
    # background. Use IupSetHandle or IupSetAttributeHandle to
    # associate an image to a name. See also IupImage.
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGE"), cast[PIhandle](handle))

proc `backimage`*(ih: FlatVal_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("BACKIMAGE"), cast[PIhandle](handle))

proc `backimage`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGE"))

proc `backimagezoom=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    # BACKIMAGEZOOM (non inheritable): if set the back image will be
    # zoomed to occupy the full background. Aspect ratio is NOT
    # preserved. Can be Yes or No. Default: No.
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring(value))

proc `backimagezoom`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring(value))

proc `backimagezoom=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring((if yes: "YES" else: "NO")))

proc `backimagezoom`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM"), cstring((if yes: "YES" else: "NO")))

proc `backimagezoom`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKIMAGEZOOM")) == "YES"

proc `backingstore=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE")) == "YES"

proc `bgcolor=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    # BGCOLOR: ignored. It will use the background color of the native
    # parent.
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `bordercolor=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    # BORDERCOLOR: color used for borders. Default: "50 150 255". This
    # is for the drawn border.
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(value))

proc `bordercolor`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(value))

proc `bordercolor=`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bordercolor`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bordercolor`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERCOLOR"))

proc `borderhlcolor=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    # BORDERHLCOLOR: color used for borders when highlighted. Pre-
    # defined to "0 120 220". Can be set to NULL. If NULL BORDERCOLOR
    # will be used instead.
    SetAttribute(cast[PIhandle](ih), cstring("BORDERHLCOLOR"), cstring(value))

proc `borderhlcolor`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERHLCOLOR"), cstring(value))

proc `borderhlcolor=`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERHLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `borderhlcolor`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERHLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `borderhlcolor`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERHLCOLOR"))

proc `borderpscolor=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    # BORDERPSCOLOR: color used for borders when pressed or selected.
    # Default use BORDERCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("BORDERPSCOLOR"), cstring(value))

proc `borderpscolor`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERPSCOLOR"), cstring(value))

proc `borderpscolor=`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERPSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `borderpscolor`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERPSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `borderpscolor`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERPSCOLOR"))

proc `borderwidth=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    # BORDERWIDTH: line width used for borders. Default: "1". Any
    # borders can be hidden by simply setting this value to 0. This is
    # for the IupFlatButton drawn border.
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(value))

proc `borderwidth`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(value))

proc `borderwidth=`*(ih: FlatVal_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(&"{x}"))

proc `borderwidth`*(ih: FlatVal_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"), cstring(&"{x}"))

proc `borderwidth`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERWIDTH"))

proc `canfocus=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    # CANFOCUS (creation only) (non inheritable): enables the focus
    # traversal of the control. In Windows the control will still get
    # the focus when clicked. Default: YES.
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `cursor=`*(ih: FlatVal_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FlatVal_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `dragdrop=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary flatval
proc `dragtypes`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

# TODO unknown: flatval DRAWABLE Unknown Binary
proc `drawable`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWABLE"))

proc `drawbgcolor=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor=`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"))

proc `drawcolor=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor=`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"))

proc `drawdriver`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWDRIVER"))

proc `drawfont=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

proc `drawfont`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

# TODO ??? String Binary flatval
proc `drawfont`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"))

proc `drawlinewidth=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth=`*(ih: FlatVal_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: FlatVal_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"))

proc `drawmakeinactive=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE")) == "YES"

proc `drawsize`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSIZE"))

proc `drawstyle=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"))

proc `drawtextalignment=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"))

proc `drawtextclip=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP")) == "YES"

proc `drawtextellipsis=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS")) == "YES"

proc `drawtextlayoutcenter=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER")) == "YES"

proc `drawtextorientation=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation=`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"))

proc `drawtextwrap=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP")) == "YES"

proc `dropfilestarget=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary flatval
proc `droptypes`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `dx=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx=`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DX"))

proc `dy=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy=`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DY"))

proc `expand=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `fgcolor=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    # FGCOLOR: Controls the handler color. Default: "0 120 220".
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

proc `fittobackimage=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    # FITTOBACKIMAGE (non inheritable): enable the natural size to be
    # computed from the BACKIMAGE. If BACKIMAGE is not defined will be
    # ignored. Can be Yes or No. Default: No.
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring(value))

proc `fittobackimage`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring(value))

proc `fittobackimage=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring((if yes: "YES" else: "NO")))

proc `fittobackimage`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE"), cstring((if yes: "YES" else: "NO")))

proc `fittobackimage`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FITTOBACKIMAGE")) == "YES"

proc `floating=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `focusfeedback=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring(value))

proc `focusfeedback`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring(value))

proc `focusfeedback=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring((if yes: "YES" else: "NO")))

proc `focusfeedback`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK"), cstring((if yes: "YES" else: "NO")))

proc `focusfeedback`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FOCUSFEEDBACK")) == "YES"

proc `font=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary flatval
proc `font`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary flatval
proc `fontface`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: FlatVal_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FlatVal_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary flatval
proc `fontstyle`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary flatval
proc `handlename`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

# TODO unknown: flatval HANDLERSIZE Unknown Binary
proc `handlersize`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLERSIZE"))

proc `hasfocus`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HASFOCUS")) == "YES"

proc `hlcolor=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    # HLCOLOR: color used to indicate a highlight state. Pre-defined
    # to "30 150 250". Can be set to NULL. If NULL FGCOLOR will be
    # used instead.
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(value))

proc `hlcolor`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(value))

proc `hlcolor=`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `hlcolor`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `hlcolor`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HLCOLOR"))

proc `image=`*(ih: FlatVal_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGE (non inheritable): Image name for the handler. Use
    # IupSetHandle or IupSetAttributeHandle to associate an image to a
    # name. See also IupImage. If defined the handler will be replaced
    # by the image.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: FlatVal_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGE"))

proc `imagehighlight=`*(ih: FlatVal_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGEHIGHLIGHT (non inheritable): Image name of the element in
    # highlight state. If it is not defined then the IMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `imagehighlight`*(ih: FlatVal_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEHIGHLIGHT"), cast[PIhandle](handle))

proc `imagehighlight`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEHIGHLIGHT"))

proc `imageinactive=`*(ih: FlatVal_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGEINACTIVE (non inheritable): Image name of the element when
    # inactive. If it is not defined then the IMAGE is used and its
    # colors will be replaced by a modified version creating the
    # disabled effect.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEINACTIVE"), cast[PIhandle](handle))

proc `imageinactive`*(ih: FlatVal_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEINACTIVE"), cast[PIhandle](handle))

proc `imageinactive`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEINACTIVE"))

proc `imagepress=`*(ih: FlatVal_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGEPRESS (non inheritable): Image name of the element in
    # pressed state. If it is not defined then the IMAGE is used.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEPRESS"), cast[PIhandle](handle))

proc `imagepress`*(ih: FlatVal_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEPRESS"), cast[PIhandle](handle))

proc `imagepress`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEPRESS"))

proc `linex=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex=`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEX"))

proc `liney=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney=`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEY"))

proc `max=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    # MAX: Contains the maximum valuator value. Default is "1". When
    # changed the display will not be updated until VALUE is set.
    SetAttribute(cast[PIhandle](ih), cstring("MAX"), cstring(value))

proc `max`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAX"), cstring(value))

proc `max=`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAX"), cstring(&"{x}"))

proc `max`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAX"), cstring(&"{x}"))

proc `max`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAX"))

proc `maxsize=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: FlatVal_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FlatVal_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `min=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    # MIN: Contains the minimum valuator value. Default is "0". When
    # changed the display will not be updated until VALUE is set.
    SetAttribute(cast[PIhandle](ih), cstring("MIN"), cstring(value))

proc `min`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MIN"), cstring(value))

proc `min=`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MIN"), cstring(&"{x}"))

proc `min`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MIN"), cstring(&"{x}"))

proc `min`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MIN"))

proc `minsize=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: FlatVal_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FlatVal_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary flatval
proc `name`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary flatval
proc `normalizergroup`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary flatval
proc `ntheme`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `orientation=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    # ORIENTATION (creation only) (non inheritable): Informs whether
    # the valuator is "VERTICAL" or "HORIZONTAL". Vertical valuators
    # are bottom to up, and horizontal valuators are left to right
    # variations of min to max. Default: "HORIZONTAL".
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"))

# TODO unknown: flatval PAGESTEP Unknown Binary
proc `pagestep`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PAGESTEP"))

# TODO unknown: flatval PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: flatval PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: FlatVal_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FlatVal_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `posx=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx=`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSX"))

proc `posy=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy=`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSY"))

proc `propagatefocus=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    # PROPAGATEFOCUS(non inheritable): enables the focus callback
    # forwarding to the next native parent with FOCUS_CB defined.
    # Default: NO.
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `pscolor=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    # PSCOLOR: color used to indicate a press state. Pre-defined to "0
    # 60 190". Can be set to NULL. If NULL FGCOLOR will be used
    # instead.
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(value))

proc `pscolor`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(value))

proc `pscolor=`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `pscolor`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `pscolor`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PSCOLOR"))

proc `rastersize=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: FlatVal_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FlatVal_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `sb_resize`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_RESIZE"))

proc `screenposition`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `scrollbar=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR")) == "YES"

proc `size=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    # SIZE (non inheritable): The natural size is the height of one
    # character in one direction and the width of 15 characters in the
    # other.
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: FlatVal_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FlatVal_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

# TODO unknown: flatval SLIDERBORDERCOLOR Unknown Binary
proc `sliderbordercolor`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SLIDERBORDERCOLOR"))

# TODO unknown: flatval SLIDERCOLOR Unknown Binary
proc `slidercolor`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SLIDERCOLOR"))

# TODO unknown: flatval SLIDERSIZE Unknown Binary
proc `slidersize`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SLIDERSIZE"))

proc `step=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    # STEP (non inheritable): Controls the increment for keyboard
    # control and the mouse wheel. It is not the size of the
    # increment. The increment size is "step*(max-min)", so it must be
    # 0<step<1. Default is "0.01".
    SetAttribute(cast[PIhandle](ih), cstring("STEP"), cstring(value))

proc `step`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STEP"), cstring(value))

proc `step=`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STEP"), cstring(&"{x}"))

proc `step`*(ih: FlatVal_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STEP"), cstring(&"{x}"))

proc `step`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("STEP"))

proc `theme=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary flatval
proc `theme`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary flatval
proc `tip`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: FlatVal_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FlatVal_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FlatVal_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary flatval
proc `tipicon`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary flatval
proc `tipmarkup`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: FlatVal_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FlatVal_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `touch=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOUCH")) == "YES"

proc `usersize=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: FlatVal_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FlatVal_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    # VALUE (non inheritable): Contains a number between MIN and MAX,
    # indicating the valuator position. Default: "0.0".
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

# TODO ??? String Binary flatval
proc `value`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `visible=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wheeldropfocus=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS")) == "YES"

proc `wid`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

proc `xautohide=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE")) == "YES"

proc `xdisplay`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XDISPLAY"))

# TODO unknown: flatval XFONTID Unknown Binary
proc `xfontid`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `xhidden`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XHIDDEN")) == "YES"

proc `xmax=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax=`*(ih: FlatVal_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: FlatVal_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMAX"))

proc `xmin=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin=`*(ih: FlatVal_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: FlatVal_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMIN"))

# TODO unknown: flatval XWINDOW Unknown Binary
proc `xwindow`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `yautohide=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide=`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: FlatVal_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE")) == "YES"

proc `yhidden`*(ih: FlatVal_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YHIDDEN")) == "YES"

proc `ymax=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax=`*(ih: FlatVal_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: FlatVal_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMAX"))

proc `ymin=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin=`*(ih: FlatVal_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: FlatVal_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: FlatVal_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMIN"))

proc `zorder=`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: FlatVal_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: FlatVal_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `destroy_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: FlatVal_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FlatVal_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `flat_button_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_BUTTON_CB"), cast[Icallback](cb))

proc `flat_button_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_BUTTON_CB"), cast[Icallback](cb))

proc `flat_button_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_BUTTON_CB")))

proc `flat_enterwindow_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_ENTERWINDOW_CB"), cast[Icallback](cb))

proc `flat_enterwindow_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_ENTERWINDOW_CB"), cast[Icallback](cb))

proc `flat_enterwindow_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_ENTERWINDOW_CB")))

proc `flat_focus_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_FOCUS_CB"), cast[Icallback](cb))

proc `flat_focus_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_FOCUS_CB"), cast[Icallback](cb))

proc `flat_focus_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_FOCUS_CB")))

proc `flat_leavewindow_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `flat_leavewindow_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `flat_leavewindow_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_LEAVEWINDOW_CB")))

proc `flat_motion_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_MOTION_CB"), cast[Icallback](cb))

proc `flat_motion_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_MOTION_CB"), cast[Icallback](cb))

proc `flat_motion_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_MOTION_CB")))

proc `flat_wheel_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cint, arg4: cint, arg5: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_WHEEL_CB"), cast[Icallback](cb))

proc `flat_wheel_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cint, arg4: cint, arg5: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FLAT_WHEEL_CB"), cast[Icallback](cb))

proc `flat_wheel_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FLAT_WHEEL_CB")))

proc `focus_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `keypress_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    # KEYPRESS_CB KEYPRESS_CB Action generated when a key is pressed
    # or released. If the key is pressed and held several calls will
    # occur. It is called after the callback K_ANY is processed.
    # Callback int function(Ihandle *ih, int c, int press); [in C]
    # ih:keypress_cb(c, press: number) -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. c:
    # identifier of typed key. Please refer to the Keyboard Codes
    # table for a list of possible values. press: 1 is the user
    # pressed the key or 0 otherwise. Returns: If IUP_IGNORE is
    # returned the key is ignored by the system. IUP_CLOSE will be
    # processed. Affects IupCanvas
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB")))

proc `killfocus_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FlatVal_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `postmessage_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `scroll_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    # SCROLL_CB SCROLL_CB Called when some manipulation is made to the
    # scrollbar. The canvas is automatically redrawn only if this
    # callback is NOT defined. (GTK 2.8) Also the POSX and POSY values
    # will not be correctly updated for older GTK versions. In Ubuntu,
    # when liboverlay-scrollbar is enabled (the new tiny auto-hide
    # scrollbar) only the IUP_SBPOSV and IUP_SBPOSH codes are used.
    # Callback int function(Ihandle *ih, int op, float posx, float
    # posy); [in C] ih:scroll_cb(op, posx, posy: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. op: indicates the operation performed on the
    # scrollbar. If the manipulation was made on the vertical
    # scrollbar, it can have the following values: IUP_SBUP - line up
    # IUP_SBDN - line down IUP_SBPGUP - page up IUP_SBPGDN - page down
    # IUP_SBPOSV - vertical positioning IUP_SBDRAGV - vertical drag If
    # it was on the horizontal scrollbar, the following values are
    # valid: IUP_SBLEFT - column left IUP_SBRIGHT - column right
    # IUP_SBPGLEFT - page left IUP_SBPGRIGHT - page right IUP_SBPOSH -
    # horizontal positioning IUP_SBDRAGH - horizontal drag posx, posy:
    # the same as the ACTION canvas callback (corresponding to the
    # values of attributes POSX and POSY). Notes IUP_SBDRAGH and
    # IUP_SBDRAGV are not supported in GTK. During drag IUP_SBPOSH and
    # IUP_SBPOSV are used. In Windows, after a drag when mouse is
    # released IUP_SBPOSH or IUP_SBPOSV are called. Affects IupCanvas,
    # IupGLCanvas, SCROLLBAR
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SCROLL_CB")))

proc `unmap_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `valuechanged_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # VALUECHANGED_CB: Called after the value was interactively
    # changed by the user. int function(Ihandle *ih); [in
    # C]ih:valuechanged_cb() -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB")))

proc `valuechanging_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # VALUECHANGING_CB: Called when the value starts or ends to be
    # interactively changed by the user. int function(Ihandle *ih, int
    # start); [in C]elem:valuechanging_cb(start: number) -> (ret:
    # number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGING_CB"), cast[Icallback](cb))

proc `valuechanging_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGING_CB"), cast[Icallback](cb))

proc `valuechanging_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("VALUECHANGING_CB")))

proc `wheel_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # WHEEL_CB WHEEL_CB Action generated when the mouse wheel is
    # rotated. If this callback is not defined the wheel will
    # automatically scroll the canvas in the vertical direction by
    # some lines, the SCROLL_CB callback if defined will be called
    # with the IUP_SBDRAGV operation. Callback int function(Ihandle
    # *ih, float delta, int x, int y, char *status); [in C]
    # ih:wheel_cb(delta, x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. delta: the amount the wheel was rotated in notches.
    # x, y: position in the canvas where the event has occurred, in
    # pixels. status: status of mouse buttons and certain keyboard
    # keys at the moment the event was generated. The same macros used
    # for BUTTON_CB can be used for this status. Notes In Motif and
    # GTK delta is always 1 or -1. In Windows is some situations delta
    # can reach the value of two. In the future with more precise
    # wheels this increment can be changed. Affects IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WHEEL_CB")))

proc `wom_cb=`*(ih: FlatVal_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # WOM_CB WOM_CB Action generated when an audio device receives an
    # event. [Windows Only] Callback int function(Ihandle *ih, int
    # state); [in C] ih:wom_cb(state: number) -> (ret: number) [in
    # Lua] ih: identifies the element that activated the event. state:
    # can be opening=1, done=0, or closing=-1. Notes This callback is
    # used to syncronize video playback with audio. It is sent when
    # the audio device: Message Description opening is opened by using
    # the waveOutOpen function. done is finished with a data block
    # sent by using the waveOutWrite function. closing is closed by
    # using the waveOutClose function. You must use the HWND attribute
    # when calling waveOutOpen in the dwCallback parameter and set
    # fdwOpen to CALLBACK_WINDOW. Affects IupDialog, IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: FlatVal_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: FlatVal_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WOM_CB")))

proc FontDlg*(): FontDlg_t {.cdecl.} =
    # Creates the Font Dialog element. It is a predefined dialog for
    # selecting a font. The dialog can be shown with the IupPopup
    # function only.
    return FontDlg_t(niupc.FontDlg())

proc `active=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `activewindow`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVEWINDOW")) == "YES"

proc `background=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(value))

proc `background`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(value))

proc `background=`*(ih: FontDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(&"{red} {green} {blue} {alpha}"))

proc `background`*(ih: FontDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(&"{red} {green} {blue} {alpha}"))

proc `background`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"))

proc `bgcolor=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: FontDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FontDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `bordersize`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERSIZE"))

proc `bringfront=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring(value))

proc `bringfront`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring(value))

proc `bringfront=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring((if yes: "YES" else: "NO")))

proc `bringfront`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring((if yes: "YES" else: "NO")))

proc `bringfront`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT")) == "YES"

proc `canfocus=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `childoffset=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset=`*(ih: FontDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: FontDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"))

proc `clientoffset`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(value))

proc `clientsize`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(value))

proc `clientsize=`*(ih: FontDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(&"{width}x{height}"))

proc `clientsize`*(ih: FontDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(&"{width}x{height}"))

proc `clientsize`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `composited=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring(value))

proc `composited`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring(value))

proc `composited=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring((if yes: "YES" else: "NO")))

proc `composited`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring((if yes: "YES" else: "NO")))

proc `composited`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("COMPOSITED")) == "YES"

proc `control=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring(value))

proc `control`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring(value))

proc `control=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring((if yes: "YES" else: "NO")))

proc `control`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring((if yes: "YES" else: "NO")))

proc `control`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CONTROL")) == "YES"

proc `cursor=`*(ih: FontDlg_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FontDlg_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `customframe=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring(value))

proc `customframe`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring(value))

proc `customframe=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring((if yes: "YES" else: "NO")))

proc `customframe`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring((if yes: "YES" else: "NO")))

proc `customframe`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME")) == "YES"

proc `customframesimulate=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring(value))

proc `customframesimulate`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring(value))

proc `customframesimulate=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring((if yes: "YES" else: "NO")))

proc `customframesimulate`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring((if yes: "YES" else: "NO")))

proc `customframesimulate`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE")) == "YES"

proc `defaultenter=`*(ih: FontDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTENTER"), cast[PIhandle](handle))

proc `defaultenter`*(ih: FontDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTENTER"), cast[PIhandle](handle))

proc `defaultenter`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DEFAULTENTER"))

proc `defaultesc=`*(ih: FontDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTESC"), cast[PIhandle](handle))

proc `defaultesc`*(ih: FontDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTESC"), cast[PIhandle](handle))

proc `defaultesc`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DEFAULTESC"))

proc `dialogframe=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring(value))

proc `dialogframe`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring(value))

proc `dialogframe=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring((if yes: "YES" else: "NO")))

proc `dialogframe`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring((if yes: "YES" else: "NO")))

proc `dialogframe`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME")) == "YES"

proc `dialoghint=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring(value))

proc `dialoghint`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring(value))

proc `dialoghint=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring((if yes: "YES" else: "NO")))

proc `dialoghint`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring((if yes: "YES" else: "NO")))

proc `dialoghint`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT")) == "YES"

proc `dragdrop=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary fontdlg
proc `dragtypes`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

proc `dropfilestarget=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary fontdlg
proc `droptypes`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `expand=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: FontDlg_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FontDlg_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary fontdlg
proc `font`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary fontdlg
proc `fontface`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: FontDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FontDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary fontdlg
proc `fontstyle`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `fullscreen=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring(value))

proc `fullscreen`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring(value))

proc `fullscreen=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring((if yes: "YES" else: "NO")))

proc `fullscreen`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring((if yes: "YES" else: "NO")))

proc `handlename=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary fontdlg
proc `handlename`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `helpbutton=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring(value))

proc `helpbutton`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring(value))

proc `helpbutton=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring((if yes: "YES" else: "NO")))

proc `helpbutton`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring((if yes: "YES" else: "NO")))

proc `helpbutton`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON")) == "YES"

proc `hidetaskbar=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring(value))

proc `hidetaskbar`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring(value))

proc `hidetaskbar=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring((if yes: "YES" else: "NO")))

proc `hidetaskbar`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring((if yes: "YES" else: "NO")))

proc `hidetaskbar`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR")) == "YES"

proc `hidetitlebar=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETITLEBAR"), cstring(value))

proc `hidetitlebar`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETITLEBAR"), cstring(value))

# TODO ??? String Binary fontdlg
proc `hidetitlebar`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIDETITLEBAR"))

proc `icon=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ICON"), cstring(value))

proc `icon`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ICON"), cstring(value))

# TODO ??? String Binary fontdlg
proc `icon`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ICON"))

proc `maxbox=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring(value))

proc `maxbox`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring(value))

proc `maxbox=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring((if yes: "YES" else: "NO")))

proc `maxbox`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring((if yes: "YES" else: "NO")))

proc `maxbox`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXBOX")) == "YES"

proc `maximized`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXIMIZED")) == "YES"

proc `maxsize=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: FontDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FontDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `mdichild=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring(value))

proc `mdichild`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring(value))

proc `mdichild=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring((if yes: "YES" else: "NO")))

proc `mdichild`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring((if yes: "YES" else: "NO")))

proc `mdichild`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDICHILD")) == "YES"

proc `mdiclient=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring(value))

proc `mdiclient`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring(value))

proc `mdiclient=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring((if yes: "YES" else: "NO")))

proc `mdiclient`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring((if yes: "YES" else: "NO")))

proc `mdiclient`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDICLIENT")) == "YES"

proc `mdiframe=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring(value))

proc `mdiframe`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring(value))

proc `mdiframe=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring((if yes: "YES" else: "NO")))

proc `mdiframe`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring((if yes: "YES" else: "NO")))

proc `mdiframe`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDIFRAME")) == "YES"

proc `mdimenu=`*(ih: FontDlg_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MDIMENU"), cast[PIhandle](handle))

proc `mdimenu`*(ih: FontDlg_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MDIMENU"), cast[PIhandle](handle))

proc `mdimenu`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDIMENU"))

proc `menu=`*(ih: FontDlg_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MENU"), cast[PIhandle](handle))

proc `menu`*(ih: FontDlg_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MENU"), cast[PIhandle](handle))

proc `menu`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MENU"))

proc `menubox=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring(value))

proc `menubox`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring(value))

proc `menubox=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring((if yes: "YES" else: "NO")))

proc `menubox`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring((if yes: "YES" else: "NO")))

proc `menubox`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MENUBOX")) == "YES"

proc `minbox=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring(value))

proc `minbox`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring(value))

proc `minbox=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring((if yes: "YES" else: "NO")))

proc `minbox`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring((if yes: "YES" else: "NO")))

proc `minbox`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINBOX")) == "YES"

proc `minsize=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: FontDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FontDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `modal`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MODAL")) == "YES"

proc `nactive=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring(value))

proc `nactive`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring(value))

proc `nactive=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `nactive`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `nactive`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NACTIVE")) == "YES"

proc `name=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary fontdlg
proc `name`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `nativeparent=`*(ih: FontDlg_t, handle: User_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("NATIVEPARENT"), cast[PIhandle](handle))

proc `nativeparent`*(ih: FontDlg_t, handle: User_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("NATIVEPARENT"), cast[PIhandle](handle))

proc `nativeparent`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATIVEPARENT"))

proc `naturalsize`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `noflush=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring(value))

proc `noflush`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring(value))

proc `noflush=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring((if yes: "YES" else: "NO")))

proc `noflush`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring((if yes: "YES" else: "NO")))

proc `noflush`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NOFLUSH")) == "YES"

proc `normalizergroup=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary fontdlg
proc `normalizergroup`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary fontdlg
proc `ntheme`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `opacity=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(value))

proc `opacity`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(value))

proc `opacity=`*(ih: FontDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(&"{x}"))

proc `opacity`*(ih: FontDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(&"{x}"))

proc `opacity`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("OPACITY"))

proc `opacityimage=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITYIMAGE"), cstring(value))

proc `opacityimage`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITYIMAGE"), cstring(value))

# TODO ??? String Binary fontdlg
proc `opacityimage`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("OPACITYIMAGE"))

# TODO unknown: fontdlg PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: fontdlg PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `parentdialog=`*(ih: FontDlg_t, handle: IUPhandle_t) {.cdecl.} =
    # PARENTDIALOG (creation only): Name of a dialog to be used as
    # parent. This dialog will be always in front of the parent
    # dialog.
    SetAttributeHandle(cast[PIhandle](ih), cstring("PARENTDIALOG"), cast[PIhandle](handle))

proc `parentdialog`*(ih: FontDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("PARENTDIALOG"), cast[PIhandle](handle))

proc `parentdialog`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PARENTDIALOG"))

proc `placement=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PLACEMENT"), cstring(value))

proc `placement`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PLACEMENT"), cstring(value))

proc `placement`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PLACEMENT"))

proc `position=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: FontDlg_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FontDlg_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `previewtext=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    # PREVIEWTEXT [GTK and Motif only]: the text shown in the preview
    # area. If not defined, the system will provide a default text.
    SetAttribute(cast[PIhandle](ih), cstring("PREVIEWTEXT"), cstring(value))

proc `previewtext`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PREVIEWTEXT"), cstring(value))

# TODO ??? String Binary fontdlg
proc `previewtext`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PREVIEWTEXT"))

proc `propagatefocus=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: FontDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FontDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `resize=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(value))

proc `resize`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(value))

proc `resize=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring((if yes: "YES" else: "NO")))

proc `resize`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring((if yes: "YES" else: "NO")))

proc `resize`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RESIZE")) == "YES"

proc `saveunder=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring(value))

proc `saveunder`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring(value))

proc `saveunder=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring((if yes: "YES" else: "NO")))

proc `saveunder`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring((if yes: "YES" else: "NO")))

proc `saveunder`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER")) == "YES"

proc `screenposition`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `shapeimage=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHAPEIMAGE"), cstring(value))

proc `shapeimage`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHAPEIMAGE"), cstring(value))

# TODO ??? String Binary fontdlg
proc `shapeimage`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHAPEIMAGE"))

proc `shownofocus=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring(value))

proc `shownofocus`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring(value))

proc `shownofocus=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `shownofocus`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `shownofocus`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS")) == "YES"

proc `shrink=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring(value))

proc `shrink`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring(value))

proc `shrink=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring((if yes: "YES" else: "NO")))

proc `shrink`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring((if yes: "YES" else: "NO")))

proc `shrink`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHRINK")) == "YES"

proc `simulatemodal=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring(value))

proc `simulatemodal`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring(value))

proc `simulatemodal=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring((if yes: "YES" else: "NO")))

proc `simulatemodal`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring((if yes: "YES" else: "NO")))

proc `size=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: FontDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FontDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size=`*(ih: FontDlg_t, width: string, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FontDlg_t, width: string, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size=`*(ih: FontDlg_t, width: int, height:string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FontDlg_t, width: int, height:string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `startfocus=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STARTFOCUS"), cstring(value))

proc `startfocus`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STARTFOCUS"), cstring(value))

# TODO ??? String Binary fontdlg
proc `startfocus`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("STARTFOCUS"))

proc `status`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("STATUS"))

proc `theme=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary fontdlg
proc `theme`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary fontdlg
proc `tip`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: FontDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FontDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: FontDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FontDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: FontDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FontDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary fontdlg
proc `tipicon`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary fontdlg
proc `tipmarkup`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: FontDlg_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FontDlg_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `title=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    # TITLE: Dialog title.
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary fontdlg
proc `title`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

proc `toolbox=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring(value))

proc `toolbox`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring(value))

proc `toolbox=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring((if yes: "YES" else: "NO")))

proc `toolbox`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring((if yes: "YES" else: "NO")))

proc `toolbox`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOOLBOX")) == "YES"

proc `topmost=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring(value))

proc `topmost`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring(value))

proc `topmost=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring((if yes: "YES" else: "NO")))

proc `topmost`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring((if yes: "YES" else: "NO")))

proc `tray=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring(value))

proc `tray`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring(value))

proc `tray=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring((if yes: "YES" else: "NO")))

proc `tray`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring((if yes: "YES" else: "NO")))

proc `tray`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAY")) == "YES"

proc `trayimage=`*(ih: FontDlg_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("TRAYIMAGE"), cast[PIhandle](handle))

proc `trayimage`*(ih: FontDlg_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("TRAYIMAGE"), cast[PIhandle](handle))

proc `trayimage`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAYIMAGE"))

proc `traytip=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIP"), cstring(value))

proc `traytip`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIP"), cstring(value))

# TODO ??? String Binary fontdlg
proc `traytip`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAYTIP"))

proc `traytipmarkup=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIPMARKUP"), cstring(value))

proc `traytipmarkup`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIPMARKUP"), cstring(value))

# TODO ??? String Binary fontdlg
proc `traytipmarkup`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAYTIPMARKUP"))

proc `usersize=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: FontDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FontDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    # VALUE: The initial font value and the selected value returned if
    # the user pressed the Ok button. Has the same format as the FONT
    # attribute.
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

# TODO ??? String Binary fontdlg
proc `value`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `visible=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FontDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: FontDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

# TODO unknown: fontdlg XFONTID Unknown Binary
proc `xfontid`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

# TODO unknown: fontdlg XWINDOW Unknown Binary
proc `xwindow`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: FontDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `zorder=`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: FontDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `close_cb=`*(ih: FontDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # CLOSE_CB CLOSE_CB Called just before a dialog is closed when the
    # user clicks the close button of the title bar or an equivalent
    # action. Callback int function(Ihandle *ih); [in C] ih:close_cb()
    # -> (ret: number) [in Lua] ih: identifies the element that
    # activated the event. Returns: if IUP_IGNORE, it prevents the
    # dialog from being closed. If you destroy the dialog in this
    # callback, you must return IUP_IGNORE. IUP_CLOSE will be
    # processed. Affects IupDialog
    SetCallback(cast[PIhandle](ih), cstring("CLOSE_CB"), cast[Icallback](cb))

proc `close_cb`*(ih: FontDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("CLOSE_CB"), cast[Icallback](cb))

proc `close_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("CLOSE_CB")))

proc `destroy_cb=`*(ih: FontDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FontDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: FontDlg_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FontDlg_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: FontDlg_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FontDlg_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: FontDlg_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FontDlg_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: FontDlg_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FontDlg_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: FontDlg_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FontDlg_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: FontDlg_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FontDlg_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: FontDlg_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FontDlg_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: FontDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FontDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `focus_cb=`*(ih: FontDlg_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FontDlg_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: FontDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FontDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: FontDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FontDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `killfocus_cb=`*(ih: FontDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FontDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: FontDlg_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FontDlg_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: FontDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FontDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: FontDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FontDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: FontDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FontDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: FontDlg_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FontDlg_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: FontDlg_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FontDlg_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `show_cb=`*(ih: FontDlg_t, cb: proc (ih: PIhandle, state: cint): cint {.cdecl.}) {.cdecl.} =
    # SHOW_CB SHOW_CB Called right after the dialog is showed, hidden,
    # maximized, minimized or restored from minimized/maximized. This
    # callback is called when those actions were performed by the user
    # or programmatically by the application. Callback int
    # function(Ihandle *ih, int state); [in C] ih:show_cb(state:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. state: indicates which of the
    # following situations generated the event: IUP_HIDE (since 3.0)
    # IUP_SHOW IUP_RESTORE (was minimized or maximized) IUP_MINIMIZE
    # IUP_MAXIMIZE (since 3.0) (not received in Motif when activated
    # from the maximize button) Returns: IUP_CLOSE will be processed.
    # Affects IupDialog
    SetCallback(cast[PIhandle](ih), cstring("SHOW_CB"), cast[Icallback](cb))

proc `show_cb`*(ih: FontDlg_t, cb: proc (ih: PIhandle, state: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SHOW_CB"), cast[Icallback](cb))

proc `show_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SHOW_CB")))

proc `trayclick_cb=`*(ih: FontDlg_t, cb: proc (ih: PIhandle, but, pressed, dclick: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("TRAYCLICK_CB"), cast[Icallback](cb))

proc `trayclick_cb`*(ih: FontDlg_t, cb: proc (ih: PIhandle, but, pressed, dclick: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("TRAYCLICK_CB"), cast[Icallback](cb))

proc `trayclick_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("TRAYCLICK_CB")))

proc `unmap_cb=`*(ih: FontDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FontDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: FontDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc Frame*(child: IUPhandle_t): Frame_t {.cdecl.} =
    # Creates a native container, which draws a frame with a title
    # around its child.
    return Frame_t(niupc.Frame(cast[PIhandle](child)))

proc `active=`*(ih: Frame_t, value: string) {.cdecl.} =
    # ACTIVE, FONT, SCREENPOSITION, POSITION, CLIENTSIZE,
    # CLIENTOFFSET, MINSIZE, MAXSIZE, WID, SIZE, RASTERSIZE, ZORDER,
    # VISIBLE, THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Frame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Frame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Frame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `backcolor=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(value))

proc `backcolor`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(value))

proc `backcolor=`*(ih: Frame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `backcolor`*(ih: Frame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `backcolor`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"))

proc `bgcolor=`*(ih: Frame_t, value: string) {.cdecl.} =
    # BGCOLOR: ignored, transparent in all systems. Will use the
    # background color of the native parent. Except if TITLE is not
    # defined and BGCOLOR is defined before map (can be changed
    # later), then the frame will have a color background.
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: Frame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Frame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `canfocus=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Frame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Frame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Frame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `childoffset=`*(ih: Frame_t, value: string) {.cdecl.} =
    # CHILDOFFSET: Allow to specify a position offset for the child.
    # Available for native containers only. It will not affect the
    # natural size, and allows to position controls outside the client
    # area. Format "dxxdy", where dx and dy are integer values
    # corresponding to the horizontal and vertical offsets,
    # respectively, in pixels. Default: 0x0. (since 3.14)
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset=`*(ih: Frame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: Frame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"))

proc `clientoffset`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `expand=`*(ih: Frame_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable): The default value is "YES".
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Frame_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Frame_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `fgcolor=`*(ih: Frame_t, value: string) {.cdecl.} =
    # FGCOLOR: Text title color. Not available in Windows when using
    # Windows Visual Styles. Default: the global attribute DLGFGCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: Frame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: Frame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

proc `floating=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary frame
proc `font`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary frame
proc `fontface`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Frame_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Frame_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary frame
proc `fontstyle`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary frame
proc `handlename`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `maxsize=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Frame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Frame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Frame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Frame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary frame
proc `name`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary frame
proc `normalizergroup`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary frame
proc `ntheme`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: frame PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: frame PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Frame_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Frame_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Frame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Frame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Frame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Frame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Frame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `screenposition`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `size=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Frame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Frame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

# TODO unknown: frame SUNKEN Unknown Binary
proc `sunken`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SUNKEN"))

proc `theme=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary frame
proc `theme`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary frame
proc `tip`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: Frame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Frame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: Frame_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Frame_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: Frame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Frame_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary frame
proc `tipicon`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary frame
proc `tipmarkup`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: Frame_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Frame_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: Frame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Frame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Frame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `title=`*(ih: Frame_t, value: string) {.cdecl.} =
    # TITLE (non inheritable): Text the user will see at the top of
    # the frame. If not defined during creation it can not be added
    # lately, to be changed it must be at least "" during creation.
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary frame
proc `title`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

proc `usersize=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Frame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Frame_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Frame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Frame_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Frame_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

# TODO unknown: frame XFONTID Unknown Binary
proc `xfontid`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `y`*(ih: Frame_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `zorder=`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: Frame_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `focus_cb=`*(ih: Frame_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    # FOCUS_CB: Called when a child of the container gets or looses
    # the focus. It is called only if PROPAGATEFOCUS is defined in the
    # child. (since 3.23) int function(Ihandle *ih, int focus); [in
    # C]ih:focus_cb(focus: number) -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: Frame_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: Frame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `map_cb=`*(ih: Frame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Frame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Frame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `unmap_cb=`*(ih: Frame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Frame_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Frame_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc Gauge*(): Gauge_t {.cdecl.} =
    # Creates a Gauge control. Shows a percent value that can be
    # updated to simulate a progression. It inherits from IupCanvas.
    # (Migrated from the IupControls library since IUP 3.24, it does
    # not depend on the CD library anymore.)
    return Gauge_t(niupc.Gauge())

proc `active=`*(ih: Gauge_t, value: string) {.cdecl.} =
    # ACTIVE, BGCOLOR, EXPAND, FONT, SCREENPOSITION, POSITION,
    # MINSIZE, MAXSIZE, WID, TIP, RASTERSIZE, ZORDER, VISIBLE, THEME:
    # also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `backcolor=`*(ih: Gauge_t, value: string) {.cdecl.} =
    # BACKCOLOR (non inheritable): color of the background inside the
    # borders. Predefined to "220 220 220. Can be NULL. When NULL it
    # will use the parent's background color. (since 3.28)
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(value))

proc `backcolor`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(value))

proc `backcolor=`*(ih: Gauge_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `backcolor`*(ih: Gauge_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `backcolor`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKCOLOR"))

proc `backingstore=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE")) == "YES"

proc `bgcolor=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: Gauge_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Gauge_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `canfocus=`*(ih: Gauge_t, value: string) {.cdecl.} =
    # CANFOCUS: enables the focus traversal of the control. Default:
    # NO. (different from IupCanvas)
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `cpadding=`*(ih: Gauge_t, value: string) {.cdecl.} =
    # CPADDING: same as PADDING but using the units of the SIZE
    # attribute. It will actually set the PADDING attribute. (since
    # 3.29)
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding=`*(ih: Gauge_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: Gauge_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CPADDING"))

proc `cursor=`*(ih: Gauge_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: Gauge_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `dashed=`*(ih: Gauge_t, value: string) {.cdecl.} =
    # DASHED: Changes the style of the gauge for a dashed pattern.
    # Default is "NO".
    SetAttribute(cast[PIhandle](ih), cstring("DASHED"), cstring(value))

proc `dashed`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DASHED"), cstring(value))

proc `dashed=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DASHED"), cstring((if yes: "YES" else: "NO")))

proc `dashed`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DASHED"), cstring((if yes: "YES" else: "NO")))

proc `dashed`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DASHED")) == "YES"

proc `dragdrop=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary gauge
proc `dragtypes`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

# TODO unknown: gauge DRAWABLE Unknown Binary
proc `drawable`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWABLE"))

proc `drawbgcolor=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor=`*(ih: Gauge_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: Gauge_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"))

proc `drawcolor=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor=`*(ih: Gauge_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: Gauge_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"))

proc `drawdriver`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWDRIVER"))

proc `drawfont=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

proc `drawfont`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

# TODO ??? String Binary gauge
proc `drawfont`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"))

proc `drawlinewidth=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth=`*(ih: Gauge_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: Gauge_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"))

proc `drawmakeinactive=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE")) == "YES"

proc `drawsize`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSIZE"))

proc `drawstyle=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"))

proc `drawtextalignment=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"))

proc `drawtextclip=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP")) == "YES"

proc `drawtextellipsis=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS")) == "YES"

proc `drawtextlayoutcenter=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER")) == "YES"

proc `drawtextorientation=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation=`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"))

proc `drawtextwrap=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP")) == "YES"

proc `dropfilestarget=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary gauge
proc `droptypes`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `dx=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx=`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DX"))

proc `dy=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy=`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DY"))

proc `expand=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `fgcolor=`*(ih: Gauge_t, value: string) {.cdecl.} =
    # FGCOLOR: Controls the gauge and text color. Default: "0 120 220"
    # (changed in 3.28).
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: Gauge_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: Gauge_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

proc `flat=`*(ih: Gauge_t, value: string) {.cdecl.} =
    # FLAT: use a 1 pixel flat border instead of the default 3 pixels
    # sunken border. Can be Yes or No. Default: No. (since 3.21)
    SetAttribute(cast[PIhandle](ih), cstring("FLAT"), cstring(value))

proc `flat`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLAT"), cstring(value))

proc `flat=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLAT"), cstring((if yes: "YES" else: "NO")))

proc `flat`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLAT"), cstring((if yes: "YES" else: "NO")))

proc `flat`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLAT")) == "YES"

proc `flatcolor=`*(ih: Gauge_t, value: string) {.cdecl.} =
    # FLATCOLOR: color of the border when FLAT=Yes. Default: "160 160
    # 160". (since 3.21)
    SetAttribute(cast[PIhandle](ih), cstring("FLATCOLOR"), cstring(value))

proc `flatcolor`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLATCOLOR"), cstring(value))

proc `flatcolor=`*(ih: Gauge_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLATCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `flatcolor`*(ih: Gauge_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLATCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `flatcolor`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLATCOLOR"))

proc `floating=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary gauge
proc `font`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary gauge
proc `fontface`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Gauge_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Gauge_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary gauge
proc `fontstyle`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary gauge
proc `handlename`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `linex=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex=`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEX"))

proc `liney=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney=`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEY"))

proc `max=`*(ih: Gauge_t, value: string) {.cdecl.} =
    # MAX (non inheritable): Contains the maximum value. Default is
    # "1".
    SetAttribute(cast[PIhandle](ih), cstring("MAX"), cstring(value))

proc `max`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAX"), cstring(value))

proc `max=`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAX"), cstring(&"{x}"))

proc `max`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAX"), cstring(&"{x}"))

proc `max`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAX"))

proc `maxsize=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Gauge_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Gauge_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `min=`*(ih: Gauge_t, value: string) {.cdecl.} =
    # MIN (non inheritable): Contains the minimum value. Default is
    # "0".
    SetAttribute(cast[PIhandle](ih), cstring("MIN"), cstring(value))

proc `min`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MIN"), cstring(value))

proc `min=`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MIN"), cstring(&"{x}"))

proc `min`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MIN"), cstring(&"{x}"))

proc `min`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MIN"))

proc `minsize=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Gauge_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Gauge_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary gauge
proc `name`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary gauge
proc `normalizergroup`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary gauge
proc `ntheme`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `orientation=`*(ih: Gauge_t, value: string) {.cdecl.} =
    # ORIENTATION (creation only): can be "VERTICAL" or "HORIZONTAL".
    # Default: "HORIZONTAL". Horizontal goes from left to right, and
    # vertical from bottom to top. Width and height are swapped when
    # orientation is set. (since 3.27)
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"))

proc `padding=`*(ih: Gauge_t, value: string) {.cdecl.} =
    # PADDING: internal margin. Works just like the MARGIN attribute
    # of the IupHbox and IupVbox containers, but uses a different name
    # to avoid inheritance problems. Default value: "0x0". (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding=`*(ih: Gauge_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: Gauge_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PADDING"))

# TODO unknown: gauge PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: gauge PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Gauge_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Gauge_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `posx=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx=`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSX"))

proc `posy=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy=`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSY"))

proc `propagatefocus=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Gauge_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Gauge_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `sb_resize`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_RESIZE"))

proc `screenposition`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `scrollbar=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR")) == "YES"

proc `showtext=`*(ih: Gauge_t, value: string) {.cdecl.} =
    # SHOWTEXT: Indicates if the text inside the Gauge is to be shown
    # or not. If the gauge is dashed the text is never shown. Possible
    # values: "YES" or "NO". Default: "YES".
    SetAttribute(cast[PIhandle](ih), cstring("SHOWTEXT"), cstring(value))

proc `showtext`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWTEXT"), cstring(value))

proc `showtext=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWTEXT"), cstring((if yes: "YES" else: "NO")))

proc `showtext`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWTEXT"), cstring((if yes: "YES" else: "NO")))

proc `showtext`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWTEXT")) == "YES"

proc `size=`*(ih: Gauge_t, value: string) {.cdecl.} =
    # SIZE (non inheritable): The initial size is "120x14". Set to
    # NULL to allow the automatic layout use smaller values.
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Gauge_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Gauge_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `text=`*(ih: Gauge_t, value: string) {.cdecl.} =
    # TEXT (non inheritable): Contains a text to be shown inside the
    # Gauge when SHOW_TEXT=YES. If it is NULL, the percentage
    # calculated from VALUE will be used. If the gauge is dashed the
    # text is never shown. When ORIENTATION=VERTICAL text is drawn in
    # 90.
    SetAttribute(cast[PIhandle](ih), cstring("TEXT"), cstring(value))

proc `text`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TEXT"), cstring(value))

# TODO ??? String Binary gauge
proc `text`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TEXT"))

proc `theme=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary gauge
proc `theme`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary gauge
proc `tip`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: Gauge_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Gauge_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: Gauge_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Gauge_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: Gauge_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Gauge_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary gauge
proc `tipicon`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary gauge
proc `tipmarkup`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: Gauge_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Gauge_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `touch=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOUCH")) == "YES"

proc `usersize=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Gauge_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Gauge_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: Gauge_t, value: string) {.cdecl.} =
    # VALUE (non inheritable): Contains a number between "MIN" and
    # "MAX", controlling the current position.
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value=`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(&"{x}"))

proc `value`*(ih: Gauge_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(&"{x}"))

proc `value`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `visible=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wheeldropfocus=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS")) == "YES"

proc `wid`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

proc `xautohide=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring(value))

proc `xautohide=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `xautohide`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE")) == "YES"

proc `xdisplay`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XDISPLAY"))

# TODO unknown: gauge XFONTID Unknown Binary
proc `xfontid`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `xhidden`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XHIDDEN")) == "YES"

proc `xmax=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax=`*(ih: Gauge_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: Gauge_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMAX"))

proc `xmin=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin=`*(ih: Gauge_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: Gauge_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMIN"))

# TODO unknown: gauge XWINDOW Unknown Binary
proc `xwindow`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `yautohide=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring(value))

proc `yautohide=`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: Gauge_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `yautohide`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE")) == "YES"

proc `yhidden`*(ih: Gauge_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YHIDDEN")) == "YES"

proc `ymax=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax=`*(ih: Gauge_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: Gauge_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMAX"))

proc `ymin=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin=`*(ih: Gauge_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: Gauge_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: Gauge_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMIN"))

proc `zorder=`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: Gauge_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: Gauge_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: Gauge_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `destroy_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: Gauge_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: Gauge_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `focus_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `keypress_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    # KEYPRESS_CB KEYPRESS_CB Action generated when a key is pressed
    # or released. If the key is pressed and held several calls will
    # occur. It is called after the callback K_ANY is processed.
    # Callback int function(Ihandle *ih, int c, int press); [in C]
    # ih:keypress_cb(c, press: number) -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. c:
    # identifier of typed key. Please refer to the Keyboard Codes
    # table for a list of possible values. press: 1 is the user
    # pressed the key or 0 otherwise. Returns: If IUP_IGNORE is
    # returned the key is ignored by the system. IUP_CLOSE will be
    # processed. Affects IupCanvas
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB")))

proc `killfocus_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: Gauge_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Gauge_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `postmessage_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `scroll_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    # SCROLL_CB SCROLL_CB Called when some manipulation is made to the
    # scrollbar. The canvas is automatically redrawn only if this
    # callback is NOT defined. (GTK 2.8) Also the POSX and POSY values
    # will not be correctly updated for older GTK versions. In Ubuntu,
    # when liboverlay-scrollbar is enabled (the new tiny auto-hide
    # scrollbar) only the IUP_SBPOSV and IUP_SBPOSH codes are used.
    # Callback int function(Ihandle *ih, int op, float posx, float
    # posy); [in C] ih:scroll_cb(op, posx, posy: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. op: indicates the operation performed on the
    # scrollbar. If the manipulation was made on the vertical
    # scrollbar, it can have the following values: IUP_SBUP - line up
    # IUP_SBDN - line down IUP_SBPGUP - page up IUP_SBPGDN - page down
    # IUP_SBPOSV - vertical positioning IUP_SBDRAGV - vertical drag If
    # it was on the horizontal scrollbar, the following values are
    # valid: IUP_SBLEFT - column left IUP_SBRIGHT - column right
    # IUP_SBPGLEFT - page left IUP_SBPGRIGHT - page right IUP_SBPOSH -
    # horizontal positioning IUP_SBDRAGH - horizontal drag posx, posy:
    # the same as the ACTION canvas callback (corresponding to the
    # values of attributes POSX and POSY). Notes IUP_SBDRAGH and
    # IUP_SBDRAGV are not supported in GTK. During drag IUP_SBPOSH and
    # IUP_SBPOSV are used. In Windows, after a drag when mouse is
    # released IUP_SBPOSH or IUP_SBPOSV are called. Affects IupCanvas,
    # IupGLCanvas, SCROLLBAR
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SCROLL_CB")))

proc `unmap_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `wheel_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # WHEEL_CB WHEEL_CB Action generated when the mouse wheel is
    # rotated. If this callback is not defined the wheel will
    # automatically scroll the canvas in the vertical direction by
    # some lines, the SCROLL_CB callback if defined will be called
    # with the IUP_SBDRAGV operation. Callback int function(Ihandle
    # *ih, float delta, int x, int y, char *status); [in C]
    # ih:wheel_cb(delta, x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. delta: the amount the wheel was rotated in notches.
    # x, y: position in the canvas where the event has occurred, in
    # pixels. status: status of mouse buttons and certain keyboard
    # keys at the moment the event was generated. The same macros used
    # for BUTTON_CB can be used for this status. Notes In Motif and
    # GTK delta is always 1 or -1. In Windows is some situations delta
    # can reach the value of two. In the future with more precise
    # wheels this increment can be changed. Affects IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WHEEL_CB")))

proc `wom_cb=`*(ih: Gauge_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # WOM_CB WOM_CB Action generated when an audio device receives an
    # event. [Windows Only] Callback int function(Ihandle *ih, int
    # state); [in C] ih:wom_cb(state: number) -> (ret: number) [in
    # Lua] ih: identifies the element that activated the event. state:
    # can be opening=1, done=0, or closing=-1. Notes This callback is
    # used to syncronize video playback with audio. It is sent when
    # the audio device: Message Description opening is opened by using
    # the waveOutOpen function. done is finished with a data block
    # sent by using the waveOutWrite function. closing is closed by
    # using the waveOutClose function. You must use the HWND attribute
    # when calling waveOutOpen in the dwCallback parameter and set
    # fdwOpen to CALLBACK_WINDOW. Affects IupDialog, IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: Gauge_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: Gauge_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WOM_CB")))

macro GridBox*(args: varargs[untyped]): GridBox_t =
    # Creates a void container for composing elements in a regular
    # grid. It is a box that arranges the elements it contains from
    # top to bottom and from left to right, but can distribute the
    # elements in lines or in columns. The child elements are added to
    # the control just like a vbox and hbox, sequentially. Then they
    # are distributed accordingly the attributes ORIENTATION and
    # NUMDIV. When ORIENTATION=HORIZONTAL children are distributed
    # from left to right on the first line until NUMDIV, then on the
    # second line, and so on. When ORIENTATION=VERTICAL children are
    # distributed from top to bottom on the first column until NUMDIV,
    # then on the second column, and so on. The number of lines and
    # the number of columns can be easily obtained from the
    # combination of these attributes: if
    # (orientation==IGBOX_HORIZONTAL) num_lin = child_count / num_div
    # num_col = num_div else num_lin = num_div num_col = child_count /
    # num_div Notice that the total number of spaces can be larger
    # than the number of actual children, the last line or column can
    # be incomplete. The column sizes will be based only on the width
    # of the children of the reference line, usually line 0. The line
    # sizes will be based only on the height of the children of the
    # reference column, usually column 0. It does not have a native
    # representation.


    result = nnkCall.newTree(
        nnkDotExpr.newTree(
            newIdentNode("niup"),
            newIdentNode("GridBox_t")
          ),
       )
    let inner = nnkCall.newTree(
            newIdentNode("GridBox")
          )

    if args.len > 0:
        for i in 0 ..< args.len:
          inner.add nnkCast.newTree(newIdentNode("PIhandle"), args[i])
    inner.add newNilLit()
    result.add inner


proc `active=`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: GridBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: GridBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: GridBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

# TODO unknown: gridbox ALIGNMENTCOL Unknown Binary
proc `alignmentcol`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ALIGNMENTCOL"))

# TODO unknown: gridbox ALIGNMENTLIN Unknown Binary
proc `alignmentlin`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ALIGNMENTLIN"))

proc `canfocus=`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: GridBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: GridBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: GridBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `cgapcol=`*(ih: GridBox_t, value: string) {.cdecl.} =
    # GAPCOL, CGAPCOL: Defines a horizontal space in pixels between
    # columns, CGAPCOL is in the same units of the SIZE attribute for
    # the height. Default: "0".
    SetAttribute(cast[PIhandle](ih), cstring("CGAPCOL"), cstring(value))

proc `cgapcol`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CGAPCOL"), cstring(value))

proc `cgapcol=`*(ih: GridBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CGAPCOL"), cstring(&"{x}"))

proc `cgapcol`*(ih: GridBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CGAPCOL"), cstring(&"{x}"))

proc `cgapcol`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CGAPCOL"))

proc `cgaplin=`*(ih: GridBox_t, value: string) {.cdecl.} =
    # GAPLIN, CGAPLIN: Defines a vertical space in pixels between
    # lines, CGAPLIN is in the same units of the SIZE attribute for
    # the height. Default: "0".
    SetAttribute(cast[PIhandle](ih), cstring("CGAPLIN"), cstring(value))

proc `cgaplin`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CGAPLIN"), cstring(value))

proc `cgaplin=`*(ih: GridBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CGAPLIN"), cstring(&"{x}"))

proc `cgaplin`*(ih: GridBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CGAPLIN"), cstring(&"{x}"))

proc `cgaplin`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CGAPLIN"))

proc `charsize`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `clientoffset`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `cmargin=`*(ih: GridBox_t, value: string) {.cdecl.} =
    # MARGIN, CMARGIN: Defines a margin in pixels, CMARGIN is in the
    # same units of the SIZE attribute. Its value has the format
    # "widthxheight", where width and height are integer values
    # corresponding to the horizontal and vertical margins,
    # respectively. Default: "0x0" (no margin).
    SetAttribute(cast[PIhandle](ih), cstring("CMARGIN"), cstring(value))

proc `cmargin`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CMARGIN"), cstring(value))

proc `cmargin=`*(ih: GridBox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CMARGIN"), cstring(&"{horiz}x{vert}"))

proc `cmargin`*(ih: GridBox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CMARGIN"), cstring(&"{horiz}x{vert}"))

proc `cmargin`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CMARGIN"))

proc `expand=`*(ih: GridBox_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable*): The default value is "YES". See the
    # documentation of the attribute for EXPAND inheritance.
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandchildren=`*(ih: GridBox_t, value: string) {.cdecl.} =
    # EXPANDCHILDREN (non inheritable): forces all children to expand
    # in the given direction and to fully occupy its space available
    # inside the box. Can be YES (both directions), HORIZONTAL,
    # VERTICAL or NO. Default: "NO". This has the same effect as
    # setting EXPAND on each child.
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDCHILDREN"), cstring(value))

proc `expandchildren`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDCHILDREN"), cstring(value))

proc `expandchildren`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDCHILDREN"))

proc `expandweight=`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: GridBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: GridBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

# TODO unknown: gridbox FITTOCHILDREN Unknown Binary
proc `floating=`*(ih: GridBox_t, value: string) {.cdecl.} =
    # FLOATING (non inheritable) (at children only): If a child has
    # FLOATING=YES then its size and position will be ignored by the
    # layout processing. Default: "NO".
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary gridbox
proc `font`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary gridbox
proc `fontface`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: GridBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: GridBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary gridbox
proc `fontstyle`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `gapcol=`*(ih: GridBox_t, value: string) {.cdecl.} =
    # GAPCOL, CGAPCOL: Defines a horizontal space in pixels between
    # columns, CGAPCOL is in the same units of the SIZE attribute for
    # the height. Default: "0".
    SetAttribute(cast[PIhandle](ih), cstring("GAPCOL"), cstring(value))

proc `gapcol`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("GAPCOL"), cstring(value))

proc `gapcol=`*(ih: GridBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("GAPCOL"), cstring(&"{x}"))

proc `gapcol`*(ih: GridBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("GAPCOL"), cstring(&"{x}"))

proc `gapcol`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("GAPCOL"))

proc `gaplin=`*(ih: GridBox_t, value: string) {.cdecl.} =
    # GAPLIN, CGAPLIN: Defines a vertical space in pixels between
    # lines, CGAPLIN is in the same units of the SIZE attribute for
    # the height. Default: "0".
    SetAttribute(cast[PIhandle](ih), cstring("GAPLIN"), cstring(value))

proc `gaplin`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("GAPLIN"), cstring(value))

proc `gaplin=`*(ih: GridBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("GAPLIN"), cstring(&"{x}"))

proc `gaplin`*(ih: GridBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("GAPLIN"), cstring(&"{x}"))

proc `gaplin`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("GAPLIN"))

proc `handlename=`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary gridbox
proc `handlename`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

# TODO unknown: gridbox HOMOGENEOUSCOL Unknown Binary
proc `homogeneouscol`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HOMOGENEOUSCOL"))

# TODO unknown: gridbox HOMOGENEOUSLIN Unknown Binary
proc `homogeneouslin`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HOMOGENEOUSLIN"))

proc `margin=`*(ih: GridBox_t, value: string) {.cdecl.} =
    # MARGIN, CMARGIN: Defines a margin in pixels, CMARGIN is in the
    # same units of the SIZE attribute. Its value has the format
    # "widthxheight", where width and height are integer values
    # corresponding to the horizontal and vertical margins,
    # respectively. Default: "0x0" (no margin).
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(value))

proc `margin`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(value))

proc `margin=`*(ih: GridBox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(&"{horiz}x{vert}"))

proc `margin`*(ih: GridBox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(&"{horiz}x{vert}"))

proc `margin`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MARGIN"))

proc `maxsize=`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: GridBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: GridBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: GridBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: GridBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary gridbox
proc `name`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `ncgapcol=`*(ih: GridBox_t, value: string) {.cdecl.} =
    # NGAPLIN, NCGAPLIN, NGAPCOL, NCGAPCOL (non inheritable): Same as
    # *GAP* but are non inheritable.
    SetAttribute(cast[PIhandle](ih), cstring("NCGAPCOL"), cstring(value))

proc `ncgapcol`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCGAPCOL"), cstring(value))

proc `ncgapcol=`*(ih: GridBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCGAPCOL"), cstring(&"{x}"))

proc `ncgapcol`*(ih: GridBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCGAPCOL"), cstring(&"{x}"))

proc `ncgapcol`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NCGAPCOL"))

proc `ncgaplin=`*(ih: GridBox_t, value: string) {.cdecl.} =
    # NGAPLIN, NCGAPLIN, NGAPCOL, NCGAPCOL (non inheritable): Same as
    # *GAP* but are non inheritable.
    SetAttribute(cast[PIhandle](ih), cstring("NCGAPLIN"), cstring(value))

proc `ncgaplin`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCGAPLIN"), cstring(value))

proc `ncgaplin=`*(ih: GridBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCGAPLIN"), cstring(&"{x}"))

proc `ncgaplin`*(ih: GridBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCGAPLIN"), cstring(&"{x}"))

proc `ncgaplin`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NCGAPLIN"))

proc `ncmargin=`*(ih: GridBox_t, value: string) {.cdecl.} =
    # NMARGIN, NCMARGIN (non inheritable): Same as MARGIN but are non
    # inheritable.
    SetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"), cstring(value))

proc `ncmargin`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"), cstring(value))

proc `ncmargin=`*(ih: GridBox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"), cstring(&"{horiz}x{vert}"))

proc `ncmargin`*(ih: GridBox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"), cstring(&"{horiz}x{vert}"))

proc `ncmargin`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"))

proc `ngapcol=`*(ih: GridBox_t, value: string) {.cdecl.} =
    # NGAPLIN, NCGAPLIN, NGAPCOL, NCGAPCOL (non inheritable): Same as
    # *GAP* but are non inheritable.
    SetAttribute(cast[PIhandle](ih), cstring("NGAPCOL"), cstring(value))

proc `ngapcol`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NGAPCOL"), cstring(value))

proc `ngapcol=`*(ih: GridBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NGAPCOL"), cstring(&"{x}"))

proc `ngapcol`*(ih: GridBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NGAPCOL"), cstring(&"{x}"))

proc `ngapcol`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NGAPCOL"))

proc `ngaplin=`*(ih: GridBox_t, value: string) {.cdecl.} =
    # NGAPLIN, NCGAPLIN, NGAPCOL, NCGAPCOL (non inheritable): Same as
    # *GAP* but are non inheritable.
    SetAttribute(cast[PIhandle](ih), cstring("NGAPLIN"), cstring(value))

proc `ngaplin`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NGAPLIN"), cstring(value))

proc `ngaplin=`*(ih: GridBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NGAPLIN"), cstring(&"{x}"))

proc `ngaplin`*(ih: GridBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NGAPLIN"), cstring(&"{x}"))

proc `ngaplin`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NGAPLIN"))

proc `nmargin=`*(ih: GridBox_t, value: string) {.cdecl.} =
    # NMARGIN, NCMARGIN (non inheritable): Same as MARGIN but are non
    # inheritable.
    SetAttribute(cast[PIhandle](ih), cstring("NMARGIN"), cstring(value))

proc `nmargin`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NMARGIN"), cstring(value))

proc `nmargin=`*(ih: GridBox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NMARGIN"), cstring(&"{horiz}x{vert}"))

proc `nmargin`*(ih: GridBox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NMARGIN"), cstring(&"{horiz}x{vert}"))

proc `nmargin`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NMARGIN"))

proc `normalizergroup=`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary gridbox
proc `normalizergroup`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `normalizesize=`*(ih: GridBox_t, value: string) {.cdecl.} =
    # NORMALIZESIZE (non inheritable): normalizes all children natural
    # size to be the biggest natural size among the reference line
    # and/or the reference column. All natural width will be set to
    # the biggest width, and all natural height will be set to the
    # biggest height according to is value. Can be NO, HORIZONTAL
    # (width only), VERTICAL (height only) or BOTH. Default: "NO".
    # Same as using IupNormalizer. Notice that this is different from
    # the HOMOGENEOUS* attributes in the sense that the children will
    # have their sizes changed.
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZESIZE"), cstring(value))

proc `normalizesize`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZESIZE"), cstring(value))

proc `normalizesize`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZESIZE"))

proc `ntheme=`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary gridbox
proc `ntheme`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `numcol`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NUMCOL"))

proc `numdiv=`*(ih: GridBox_t, value: string) {.cdecl.} =
    # NUMDIV: controls the number of divisions along the distribution
    # according to ORIENTATION. When ORIENTATION=HORIZONTAL, NUMDIV is
    # the number of columns, when ORIENTATION=VERTICAL, NUMDIV is the
    # number of lines. When value is AUTO, its actual value will be
    # calculated to fit the maximum number of elements in the
    # orientation direction. Default: AUTO.
    SetAttribute(cast[PIhandle](ih), cstring("NUMDIV"), cstring(value))

proc `numdiv`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NUMDIV"), cstring(value))

proc `numdiv=`*(ih: GridBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NUMDIV"), cstring(&"{x}"))

proc `numdiv`*(ih: GridBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NUMDIV"), cstring(&"{x}"))

proc `numdiv`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NUMDIV"))

proc `numlin`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NUMLIN"))

proc `orientation=`*(ih: GridBox_t, value: string) {.cdecl.} =
    # ORIENTATION (non inheritable): controls the distribution of the
    # children in lines or in columns. Can be: HORIZONTAL or VERTICAL.
    # Default: HORIZONTAL.
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"))

# TODO unknown: gridbox PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: gridbox PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: GridBox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: GridBox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: GridBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: GridBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: GridBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: GridBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: GridBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `size=`*(ih: GridBox_t, value: string) {.cdecl.} =
    # SIZE, RASTERSIZE, FONT, CLIENTSIZE, CLIENTOFFSET, POSITION,
    # MINSIZE, MAXSIZE, THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: GridBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: GridBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

# TODO unknown: gridbox SIZECOL Unknown Binary
proc `sizecol`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZECOL"))

# TODO unknown: gridbox SIZELIN Unknown Binary
proc `sizelin`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZELIN"))

proc `theme=`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary gridbox
proc `theme`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `usersize=`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: GridBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: GridBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: GridBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: GridBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: GridBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: GridBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

# TODO unknown: gridbox XFONTID Unknown Binary
proc `xfontid`*(ih: GridBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `destroy_cb=`*(ih: GridBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: GridBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: GridBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `ldestroy_cb=`*(ih: GridBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: GridBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: GridBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: GridBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: GridBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: GridBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: GridBox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: GridBox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: GridBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: GridBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: GridBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: GridBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `updateattribfromfont_cb=`*(ih: GridBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UPDATEATTRIBFROMFONT_CB"), cast[Icallback](cb))

proc `updateattribfromfont_cb`*(ih: GridBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UPDATEATTRIBFROMFONT_CB"), cast[Icallback](cb))

proc `updateattribfromfont_cb`*(ih: GridBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UPDATEATTRIBFROMFONT_CB")))

macro Hbox*(args: varargs[untyped]): Hbox_t =
    # Creates a void container for composing elements horizontally. It
    # is a box that arranges the elements it contains from left to
    # right. It does not have a native representation.


    result = nnkCall.newTree(
        nnkDotExpr.newTree(
            newIdentNode("niup"),
            newIdentNode("Hbox_t")
          ),
       )
    let inner = nnkCall.newTree(
            newIdentNode("Hbox")
          )

    if args.len > 0:
        for i in 0 ..< args.len:
          inner.add nnkCast.newTree(newIdentNode("PIhandle"), args[i])
    inner.add newNilLit()
    result.add inner


proc `active=`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Hbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Hbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Hbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `alignment=`*(ih: Hbox_t, value: string) {.cdecl.} =
    # ALIGNMENT (non inheritable): Vertically aligns the elements.
    # Possible values: "ATOP", "ACENTER", "ABOTTOM". Default: "ATOP".
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"))

proc `canfocus=`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Hbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Hbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Hbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `cgap=`*(ih: Hbox_t, value: string) {.cdecl.} =
    # GAP, CGAP: Defines an horizontal space in pixels between the
    # children, CGAP is in the same units of the SIZE attribute for
    # the width. Default: "0". (CGAP since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("CGAP"), cstring(value))

proc `cgap`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CGAP"), cstring(value))

proc `cgap=`*(ih: Hbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CGAP"), cstring(&"{x}"))

proc `cgap`*(ih: Hbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CGAP"), cstring(&"{x}"))

proc `cgap`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CGAP"))

proc `charsize`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `clientoffset`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `cmargin=`*(ih: Hbox_t, value: string) {.cdecl.} =
    # MARGIN, CMARGIN: Defines a margin in pixels, CMARGIN is in the
    # same units of the SIZE attribute. Its value has the format
    # "widthxheight", where width and height are integer values
    # corresponding to the horizontal and vertical margins,
    # respectively. Default: "0x0" (no margin). (CMARGIN since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("CMARGIN"), cstring(value))

proc `cmargin`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CMARGIN"), cstring(value))

proc `cmargin=`*(ih: Hbox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CMARGIN"), cstring(&"{horiz}x{vert}"))

proc `cmargin`*(ih: Hbox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CMARGIN"), cstring(&"{horiz}x{vert}"))

proc `cmargin`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CMARGIN"))

proc `expand=`*(ih: Hbox_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable*): The default value is "YES". See the
    # documentation of the attribute for EXPAND inheritance.
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandchildren=`*(ih: Hbox_t, value: string) {.cdecl.} =
    # EXPANDCHILDREN (non inheritable): forces all children to expand
    # vertically and to fully occupy its space available inside the
    # box. Default: "NO". This has the same effect as setting
    # EXPAND=VERTICAL on each child. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDCHILDREN"), cstring(value))

proc `expandchildren`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDCHILDREN"), cstring(value))

proc `expandchildren=`*(ih: Hbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDCHILDREN"), cstring((if yes: "YES" else: "NO")))

proc `expandchildren`*(ih: Hbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDCHILDREN"), cstring((if yes: "YES" else: "NO")))

proc `expandchildren`*(ih: Hbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDCHILDREN")) == "YES"

proc `expandweight=`*(ih: Hbox_t, value: string) {.cdecl.} =
    # EXPANDWEIGHT (non inheritable) (at children only): If a child
    # defines the expand weight, then it is used to multiply the free
    # space used for expansion. (since 3.1)
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Hbox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Hbox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: Hbox_t, value: string) {.cdecl.} =
    # FLOATING (non inheritable) (at children only): If a child has
    # FLOATING=YES then its size and position will be ignored by the
    # layout processing. Default: "NO". (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Hbox_t, value: string) {.cdecl.} =
    # FONT, CLIENTSIZE, CLIENTOFFSET, POSITION, MINSIZE, MAXSIZE,
    # THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary hbox
proc `font`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary hbox
proc `fontface`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Hbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Hbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary hbox
proc `fontstyle`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `gap=`*(ih: Hbox_t, value: string) {.cdecl.} =
    # GAP, CGAP: Defines an horizontal space in pixels between the
    # children, CGAP is in the same units of the SIZE attribute for
    # the width. Default: "0". (CGAP since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("GAP"), cstring(value))

proc `gap`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("GAP"), cstring(value))

proc `gap=`*(ih: Hbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("GAP"), cstring(&"{x}"))

proc `gap`*(ih: Hbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("GAP"), cstring(&"{x}"))

proc `gap`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("GAP"))

proc `handlename=`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary hbox
proc `handlename`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `homogeneous=`*(ih: Hbox_t, value: string) {.cdecl.} =
    # HOMOGENEOUS (non inheritable): forces all children to get equal
    # horizontal space. The space width will be based on the largest
    # child. Default: "NO". Notice that this does not changes the
    # children size, only the available space for each one of them to
    # expand. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("HOMOGENEOUS"), cstring(value))

proc `homogeneous`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HOMOGENEOUS"), cstring(value))

proc `homogeneous=`*(ih: Hbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HOMOGENEOUS"), cstring((if yes: "YES" else: "NO")))

proc `homogeneous`*(ih: Hbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HOMOGENEOUS"), cstring((if yes: "YES" else: "NO")))

proc `homogeneous`*(ih: Hbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HOMOGENEOUS")) == "YES"

proc `margin=`*(ih: Hbox_t, value: string) {.cdecl.} =
    # MARGIN, CMARGIN: Defines a margin in pixels, CMARGIN is in the
    # same units of the SIZE attribute. Its value has the format
    # "widthxheight", where width and height are integer values
    # corresponding to the horizontal and vertical margins,
    # respectively. Default: "0x0" (no margin). (CMARGIN since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(value))

proc `margin`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(value))

proc `margin=`*(ih: Hbox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(&"{horiz}x{vert}"))

proc `margin`*(ih: Hbox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(&"{horiz}x{vert}"))

proc `margin`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MARGIN"))

proc `maxsize=`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Hbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Hbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Hbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Hbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary hbox
proc `name`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `ncgap=`*(ih: Hbox_t, value: string) {.cdecl.} =
    # NGAP, NCGAP (non inheritable): Same as GAP but are non
    # inheritable. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("NCGAP"), cstring(value))

proc `ncgap`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCGAP"), cstring(value))

proc `ncgap=`*(ih: Hbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCGAP"), cstring(&"{x}"))

proc `ncgap`*(ih: Hbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCGAP"), cstring(&"{x}"))

proc `ncgap`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NCGAP"))

proc `ncmargin=`*(ih: Hbox_t, value: string) {.cdecl.} =
    # NMARGIN, NCMARGIN (non inheritable): Same as MARGIN but are non
    # inheritable. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"), cstring(value))

proc `ncmargin`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"), cstring(value))

proc `ncmargin=`*(ih: Hbox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"), cstring(&"{horiz}x{vert}"))

proc `ncmargin`*(ih: Hbox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"), cstring(&"{horiz}x{vert}"))

proc `ncmargin`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"))

proc `ngap=`*(ih: Hbox_t, value: string) {.cdecl.} =
    # NGAP, NCGAP (non inheritable): Same as GAP but are non
    # inheritable. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("NGAP"), cstring(value))

proc `ngap`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NGAP"), cstring(value))

proc `ngap=`*(ih: Hbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NGAP"), cstring(&"{x}"))

proc `ngap`*(ih: Hbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NGAP"), cstring(&"{x}"))

proc `ngap`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NGAP"))

proc `nmargin=`*(ih: Hbox_t, value: string) {.cdecl.} =
    # NMARGIN, NCMARGIN (non inheritable): Same as MARGIN but are non
    # inheritable. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("NMARGIN"), cstring(value))

proc `nmargin`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NMARGIN"), cstring(value))

proc `nmargin=`*(ih: Hbox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NMARGIN"), cstring(&"{horiz}x{vert}"))

proc `nmargin`*(ih: Hbox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NMARGIN"), cstring(&"{horiz}x{vert}"))

proc `nmargin`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NMARGIN"))

proc `normalizergroup=`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary hbox
proc `normalizergroup`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `normalizesize=`*(ih: Hbox_t, value: string) {.cdecl.} =
    # NORMALIZESIZE (non inheritable): normalizes all children natural
    # size to be the biggest natural size among them. All natural
    # width will be set to the biggest width, and all natural height
    # will be set to the biggest height according to is value. Can be
    # NO, HORIZONTAL, VERTICAL or BOTH. Default: "NO". Same as using
    # IupNormalizer. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZESIZE"), cstring(value))

proc `normalizesize`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZESIZE"), cstring(value))

proc `normalizesize`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZESIZE"))

proc `ntheme=`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary hbox
proc `ntheme`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `orientation`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"))

# TODO unknown: hbox PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: hbox PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Hbox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Hbox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Hbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Hbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Hbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Hbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Hbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `size=`*(ih: Hbox_t, value: string) {.cdecl.} =
    # SIZE / RASTERSIZE (non inheritable): Defines the width of the
    # box. When consulted behaves as the standard SIZE/RASTERSIZE
    # attributes. The standard format "wxh" can also be used, but
    # height will be ignored (since 3.3).
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Hbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{x}"))

proc `size`*(ih: Hbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{x}"))

proc `size`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary hbox
proc `theme`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `usersize=`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Hbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Hbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Hbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Hbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Hbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Hbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

# TODO unknown: hbox XFONTID Unknown Binary
proc `xfontid`*(ih: Hbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `destroy_cb=`*(ih: Hbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Hbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Hbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `ldestroy_cb=`*(ih: Hbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Hbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Hbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: Hbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Hbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Hbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: Hbox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Hbox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Hbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: Hbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Hbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Hbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `updateattribfromfont_cb=`*(ih: Hbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UPDATEATTRIBFROMFONT_CB"), cast[Icallback](cb))

proc `updateattribfromfont_cb`*(ih: Hbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UPDATEATTRIBFROMFONT_CB"), cast[Icallback](cb))

proc `updateattribfromfont_cb`*(ih: Hbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UPDATEATTRIBFROMFONT_CB")))

proc Image*(width: cint; height: cint; pixels: openArray[uint8]): Image_t {.cdecl.} =
    # Creates an image to be shown on a label, button, toggle, or as a
    # cursor. (IupImageRGB and IupImageRGBA, since 3.0)
    return Image_t(niupc.Image(width, height, cast[ptr uint8](pixels)))

proc `autoscale=`*(ih: Image_t, value: string) {.cdecl.} =
    # AUTOSCALE: automatically scale the image by a given real factor.
    # Can be "DPI" or a scale factor. If not defined the global
    # attribute IMAGEAUTOSCALE will be used. Values are the same of
    # the global attribute. The minimum resulted size when
    # automatically resized is 24 pixels height (since 3.29). (since
    # 3.16)
    SetAttribute(cast[PIhandle](ih), cstring("AUTOSCALE"), cstring(value))

proc `autoscale`*(ih: Image_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOSCALE"), cstring(value))

proc `autoscale=`*(ih: Image_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOSCALE"), cstring((if yes: "YES" else: "NO")))

proc `autoscale`*(ih: Image_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOSCALE"), cstring((if yes: "YES" else: "NO")))

proc `autoscale`*(ih: Image_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("AUTOSCALE")) == "YES"

proc `bgcolor=`*(ih: Image_t, value: string) {.cdecl.} =
    # BGCOLOR: The color used for transparency. If not defined uses
    # the BGCOLOR of the control that contains the image. In Motif,
    # the alpha channel in RGBA images is always composed with the
    # control BGCOLOR by IUP prior to setting the image at the
    # control. In Windows and in GTK, the alpha channel is composed
    # internally by the system. But in Windows for some controls the
    # alpha must be composed a priori also, it includes: IupItem and
    # IupSubmenu always; and IupToggle when NOT using Visual Styles.
    # This implies that if the control background is not uniform then
    # probably there will be a visible difference where it should be
    # transparent.
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: Image_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: Image_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Image_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Image_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `bpp`*(ih: Image_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BPP"))

proc `channels`*(ih: Image_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHANNELS"))

proc `clearcache=`*(ih: Image_t, ) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLEARCACHE"), cstring(""))

proc `clearcache`*(ih: Image_t, ) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLEARCACHE"), cstring(""))

# TODO unknown: image DPI Unknown Binary
proc `dpi`*(ih: Image_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DPI"))

proc `handlename=`*(ih: Image_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Image_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary image
proc `handlename`*(ih: Image_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `height`*(ih: Image_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HEIGHT"))

proc `hotspot=`*(ih: Image_t, value: string) {.cdecl.} =
    # HOTSPOT: Hotspot is the position inside a cursor image
    # indicating the mouse-click spot. Its value is given by the x and
    # y coordinates inside a cursor image. Its value has the format
    # "x:y", where x and y are integers defining the coordinates in
    # pixels. Default: "0:0".
    SetAttribute(cast[PIhandle](ih), cstring("HOTSPOT"), cstring(value))

proc `hotspot`*(ih: Image_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HOTSPOT"), cstring(value))

proc `hotspot=`*(ih: Image_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HOTSPOT"), cstring(&"{x}:{y}"))

proc `hotspot`*(ih: Image_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HOTSPOT"), cstring(&"{x}:{y}"))

proc `hotspot`*(ih: Image_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HOTSPOT"))

# TODO getter image IDVALUE
proc `originalscale`*(ih: Image_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ORIGINALSCALE"))

proc `rastersize`*(ih: Image_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `reshape=`*(ih: Image_t, value: string) {.cdecl.} =
    # RESHAPE (write-only): given a new size if format "widthxheight",
    # allocates enough memory for the new size and changes WIDTH and
    # HEIGHT attributes. Image contents is ignored and it will contain
    # trash after the reshape. (since 3.24)
    SetAttribute(cast[PIhandle](ih), cstring("RESHAPE"), cstring(value))

proc `reshape`*(ih: Image_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESHAPE"), cstring(value))

proc `reshape=`*(ih: Image_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESHAPE"), cstring(&"{width}x{height}"))

proc `reshape`*(ih: Image_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESHAPE"), cstring(&"{width}x{height}"))

proc `resize=`*(ih: Image_t, value: string) {.cdecl.} =
    # RESIZE (write-only): given a new size if format "widthxheight",
    # changes WIDTH and HEIGHT attributes, and resizes the image
    # contents using bilinear interpolation for RGB and RGBA images
    # and nearest neighborhood for 8 bits. (since 3.24)
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(value))

proc `resize`*(ih: Image_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(value))

proc `resize=`*(ih: Image_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(&"{width}x{height}"))

proc `resize`*(ih: Image_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(&"{width}x{height}"))

proc `scaled`*(ih: Image_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCALED")) == "YES"

proc `wid`*(ih: Image_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `width`*(ih: Image_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WIDTH"))

proc ImageRGB*(width: cint; height: cint; pixels: openArray[uint8]): ImageRGB_t {.cdecl.} =
    return ImageRGB_t(niupc.ImageRGB(width, height, cast[ptr uint8](pixels)))

proc `autoscale=`*(ih: ImageRGB_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOSCALE"), cstring(value))

proc `autoscale`*(ih: ImageRGB_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOSCALE"), cstring(value))

proc `autoscale=`*(ih: ImageRGB_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOSCALE"), cstring((if yes: "YES" else: "NO")))

proc `autoscale`*(ih: ImageRGB_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOSCALE"), cstring((if yes: "YES" else: "NO")))

proc `autoscale`*(ih: ImageRGB_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("AUTOSCALE")) == "YES"

proc `bgcolor=`*(ih: ImageRGB_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: ImageRGB_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: ImageRGB_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: ImageRGB_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: ImageRGB_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `bpp`*(ih: ImageRGB_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BPP"))

proc `channels`*(ih: ImageRGB_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHANNELS"))

proc `clearcache=`*(ih: ImageRGB_t, ) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLEARCACHE"), cstring(""))

proc `clearcache`*(ih: ImageRGB_t, ) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLEARCACHE"), cstring(""))

# TODO unknown: imagergb DPI Unknown Binary
proc `dpi`*(ih: ImageRGB_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DPI"))

proc `handlename=`*(ih: ImageRGB_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: ImageRGB_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary imagergb
proc `handlename`*(ih: ImageRGB_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `height`*(ih: ImageRGB_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HEIGHT"))

proc `hotspot=`*(ih: ImageRGB_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HOTSPOT"), cstring(value))

proc `hotspot`*(ih: ImageRGB_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HOTSPOT"), cstring(value))

proc `hotspot=`*(ih: ImageRGB_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HOTSPOT"), cstring(&"{x}:{y}"))

proc `hotspot`*(ih: ImageRGB_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HOTSPOT"), cstring(&"{x}:{y}"))

proc `hotspot`*(ih: ImageRGB_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HOTSPOT"))

proc `originalscale`*(ih: ImageRGB_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ORIGINALSCALE"))

proc `rastersize`*(ih: ImageRGB_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `reshape=`*(ih: ImageRGB_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESHAPE"), cstring(value))

proc `reshape`*(ih: ImageRGB_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESHAPE"), cstring(value))

proc `reshape=`*(ih: ImageRGB_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESHAPE"), cstring(&"{width}x{height}"))

proc `reshape`*(ih: ImageRGB_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESHAPE"), cstring(&"{width}x{height}"))

proc `resize=`*(ih: ImageRGB_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(value))

proc `resize`*(ih: ImageRGB_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(value))

proc `resize=`*(ih: ImageRGB_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(&"{width}x{height}"))

proc `resize`*(ih: ImageRGB_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(&"{width}x{height}"))

proc `scaled`*(ih: ImageRGB_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCALED")) == "YES"

proc `wid`*(ih: ImageRGB_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `width`*(ih: ImageRGB_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WIDTH"))

proc ImageRGBA*(width: cint; height: cint; pixels: openArray[uint8]): ImageRGBA_t {.cdecl.} =
    return ImageRGBA_t(niupc.ImageRGBA(width, height, cast[ptr uint8](pixels)))

proc `autoscale=`*(ih: ImageRGBA_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOSCALE"), cstring(value))

proc `autoscale`*(ih: ImageRGBA_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOSCALE"), cstring(value))

proc `autoscale=`*(ih: ImageRGBA_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOSCALE"), cstring((if yes: "YES" else: "NO")))

proc `autoscale`*(ih: ImageRGBA_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOSCALE"), cstring((if yes: "YES" else: "NO")))

proc `autoscale`*(ih: ImageRGBA_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("AUTOSCALE")) == "YES"

proc `bgcolor=`*(ih: ImageRGBA_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: ImageRGBA_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: ImageRGBA_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: ImageRGBA_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: ImageRGBA_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `bpp`*(ih: ImageRGBA_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BPP"))

proc `channels`*(ih: ImageRGBA_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHANNELS"))

proc `clearcache=`*(ih: ImageRGBA_t, ) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLEARCACHE"), cstring(""))

proc `clearcache`*(ih: ImageRGBA_t, ) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLEARCACHE"), cstring(""))

# TODO unknown: imagergba DPI Unknown Binary
proc `dpi`*(ih: ImageRGBA_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DPI"))

proc `handlename=`*(ih: ImageRGBA_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: ImageRGBA_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary imagergba
proc `handlename`*(ih: ImageRGBA_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `height`*(ih: ImageRGBA_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HEIGHT"))

proc `hotspot=`*(ih: ImageRGBA_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HOTSPOT"), cstring(value))

proc `hotspot`*(ih: ImageRGBA_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HOTSPOT"), cstring(value))

proc `hotspot=`*(ih: ImageRGBA_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HOTSPOT"), cstring(&"{x}:{y}"))

proc `hotspot`*(ih: ImageRGBA_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HOTSPOT"), cstring(&"{x}:{y}"))

proc `hotspot`*(ih: ImageRGBA_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HOTSPOT"))

proc `originalscale`*(ih: ImageRGBA_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ORIGINALSCALE"))

proc `rastersize`*(ih: ImageRGBA_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `reshape=`*(ih: ImageRGBA_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESHAPE"), cstring(value))

proc `reshape`*(ih: ImageRGBA_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESHAPE"), cstring(value))

proc `reshape=`*(ih: ImageRGBA_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESHAPE"), cstring(&"{width}x{height}"))

proc `reshape`*(ih: ImageRGBA_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESHAPE"), cstring(&"{width}x{height}"))

proc `resize=`*(ih: ImageRGBA_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(value))

proc `resize`*(ih: ImageRGBA_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(value))

proc `resize=`*(ih: ImageRGBA_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(&"{width}x{height}"))

proc `resize`*(ih: ImageRGBA_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(&"{width}x{height}"))

proc `scaled`*(ih: ImageRGBA_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCALED")) == "YES"

proc `wid`*(ih: ImageRGBA_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `width`*(ih: ImageRGBA_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WIDTH"))

proc Item*(title: string; action: string): Item_t {.cdecl.} =
    # Creates an item of the menu interface element. When selected, it
    # generates an action.
    return Item_t(niupc.Item(cstring(title), cstring(action)))

proc `active=`*(ih: Item_t, value: string) {.cdecl.} =
    # ACTIVE, THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Item_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Item_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Item_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Item_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `autotoggle=`*(ih: Item_t, value: string) {.cdecl.} =
    # AUTOTOGGLE (non inheritable): enables the automatic toggle of
    # VALUE state when the item is activated. Default: NO. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("AUTOTOGGLE"), cstring(value))

proc `autotoggle`*(ih: Item_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOTOGGLE"), cstring(value))

proc `autotoggle=`*(ih: Item_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOTOGGLE"), cstring((if yes: "YES" else: "NO")))

proc `autotoggle`*(ih: Item_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOTOGGLE"), cstring((if yes: "YES" else: "NO")))

proc `autotoggle`*(ih: Item_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("AUTOTOGGLE")) == "YES"

proc `bgcolor=`*(ih: Item_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: Item_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: Item_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Item_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Item_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `font=`*(ih: Item_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Item_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary item
proc `font`*(ih: Item_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `handlename=`*(ih: Item_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Item_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary item
proc `handlename`*(ih: Item_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `hidemark=`*(ih: Item_t, value: string) {.cdecl.} =
    # HIDEMARK [Motif and GTK Only]: If enabled the item cannot be
    # checked, since the check box will not be shown. If all items in
    # a menu enable it, then no empty space will be shown in front of
    # the items. Normally the unmarked check box will not be shown,
    # but since GTK 2.14 the unmarked check box is always shown. If
    # your item will not be marked you must set HIDEMARK=YES, since
    # this is the most common case we changed the default value to YES
    # for this version of GTK, but if VALUE is defined the default
    # goes back to NO. Default: NO. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("HIDEMARK"), cstring(value))

proc `hidemark`*(ih: Item_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDEMARK"), cstring(value))

# TODO ??? String Binary item
proc `hidemark`*(ih: Item_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIDEMARK"))

proc `image=`*(ih: Item_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGE [Windows and GTK Only] (non inheritable): Image name of
    # the check mark image when VALUE=OFF. In Windows, an item in a
    # menu bar cannot have a check mark. Ignored if item in a menu
    # bar. A recommended size would be 16x16 to fit the image in the
    # menu item. In Windows, if larger than the check mark area it
    # will be cropped.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: Item_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: Item_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGE"))

proc `impress=`*(ih: Item_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMPRESS [Windows and GTK Only] (non inheritable): Image name of
    # the check mark image when VALUE=ON.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMPRESS"), cast[PIhandle](handle))

proc `impress`*(ih: Item_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMPRESS"), cast[PIhandle](handle))

proc `impress`*(ih: Item_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMPRESS"))

proc `key=`*(ih: Item_t, value: string) {.cdecl.} =
    # KEY (non inheritable): Underlines a key character in the submenu
    # title. It is updated only when TITLE is updated. Deprecated
    # (since 3.0), use the mnemonic support directly in the TITLE
    # attribute.
    SetAttribute(cast[PIhandle](ih), cstring("KEY"), cstring(value))

proc `key`*(ih: Item_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("KEY"), cstring(value))

proc `key=`*(ih: Item_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("KEY"), cstring(&"{x}"))

proc `key`*(ih: Item_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("KEY"), cstring(&"{x}"))

proc `key`*(ih: Item_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("KEY"))

proc `name=`*(ih: Item_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Item_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary item
proc `name`*(ih: Item_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `title=`*(ih: Item_t, value: string) {.cdecl.} =
    # TITLE (non inheritable): Item text. The "&" character can be
    # used to define a mnemonic, the next character will be used as
    # key. Use "&&" to show the "&" character instead on defining a
    # mnemonic. When in a menu bar an item that has a mnemonic can be
    # activated from any control in the dialog using the "Alt+key"
    # combination.
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: Item_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary item
proc `title`*(ih: Item_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

proc `titleimage=`*(ih: Item_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # TITLEIMAGE (non inheritable): Image name of the title image. In
    # Windows, it appears before of the title text and after the check
    # mark area (so both title and title image can be visible). In
    # Motif, it must be at least defined during map, it replaces the
    # text, and only images will be possible to set (TITLE will be
    # hidden). In GTK, it will appear on the check mark area. (since
    # 3.0)
    SetAttributeHandle(cast[PIhandle](ih), cstring("TITLEIMAGE"), cast[PIhandle](handle))

proc `titleimage`*(ih: Item_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("TITLEIMAGE"), cast[PIhandle](handle))

proc `titleimage`*(ih: Item_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLEIMAGE"))

proc `value=`*(ih: Item_t, value: string) {.cdecl.} =
    # VALUE (non inheritable): Indicates the item's state. When the
    # value is ON, a mark will be displayed to the left of the item.
    # Default: OFF. An item in a menu bar cannot have a check mark.
    # When IMAGE is used, the checkmark is not shown. See the item
    # AUTOTOGGLE attribute and the menu RADIO attribute. Since GTK
    # 2.14 to have a menu item that can be marked you must set the
    # VALUE attribute to ON or OFF, or set HIDEMARK=NO, before mapping
    # the control.
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: Item_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: Item_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `wid`*(ih: Item_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `action=`*(ih: Item_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: Item_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: Item_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `destroy_cb=`*(ih: Item_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Item_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Item_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `help_cb=`*(ih: Item_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Item_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Item_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `highlight_cb=`*(ih: Item_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HIGHLIGHT_CB HIGHLIGHT_CB Callback triggered every time the user
    # selects an IupItem or IupSubmenu. Callback int function(Ihandle
    # *ih); [in C] elem:highlight_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Affects
    # IupItem, IupSubmenu
    SetCallback(cast[PIhandle](ih), cstring("HIGHLIGHT_CB"), cast[Icallback](cb))

proc `highlight_cb`*(ih: Item_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HIGHLIGHT_CB"), cast[Icallback](cb))

proc `highlight_cb`*(ih: Item_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HIGHLIGHT_CB")))

proc `ldestroy_cb=`*(ih: Item_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Item_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Item_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: Item_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Item_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Item_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: Item_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Item_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Item_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: Item_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Item_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Item_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc Label*(title: string): Label_t {.cdecl.} =
    # Creates a label interface element, which displays a separator, a
    # text or an image.
    return Label_t(niupc.Label(cstring(title)))

proc `active=`*(ih: Label_t, value: string) {.cdecl.} =
    # ACTIVE: The only difference between an active label and an
    # inactive one is its visual feedback. Possible values: "YES,
    # "NO". Default: "YES".
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Label_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `alignment=`*(ih: Label_t, value: string) {.cdecl.} =
    # ALIGNMENT (non inheritable): horizontal and vertical alignment.
    # Possible values: "ALEFT", "ACENTER" and "ARIGHT", combined to
    # "ATOP", "ACENTER" and "ABOTTOM". Default: "ALEFT:ACENTER".
    # Partial values are also accepted, like "ARIGHT" or ":ATOP", the
    # other value will be used obtained from the default value. In
    # Motif, vertical alignment is restricted to "ACENTER". (vertical
    # alignment since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"))

proc `bgcolor=`*(ih: Label_t, value: string) {.cdecl.} =
    # BGCOLOR: ignored, transparent in all systems. Will use the
    # background color of the native parent.
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: Label_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Label_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `canfocus=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Label_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `cpadding=`*(ih: Label_t, value: string) {.cdecl.} =
    # CPADDING: same as PADDING but using the units of the SIZE
    # attribute. It will actually set the PADDING attribute. (since
    # 3.29)
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding=`*(ih: Label_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: Label_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CPADDING"))

proc `dragdrop=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: Label_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: Label_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: Label_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary label
proc `dragtypes`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

proc `dropfilestarget=`*(ih: Label_t, value: string) {.cdecl.} =
    # DROPFILESTARGET [Windows and GTK Only] (non inheritable): Enable
    # or disable the drop of files. Default: NO, but if DROPFILES_CB
    # is defined when the element is mapped then it will be
    # automatically enabled. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: Label_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: Label_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary label
proc `droptypes`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `ellipsis=`*(ih: Label_t, value: string) {.cdecl.} =
    # ELLIPSIS [Windows and GTK only]: add an ellipsis: "..." to the
    # text if there is not enough space to render the entire string.
    # Can be "YES" or "NO". Default: "NO". (since 3.0) (GTK 2.6)
    SetAttribute(cast[PIhandle](ih), cstring("ELLIPSIS"), cstring(value))

proc `ellipsis`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ELLIPSIS"), cstring(value))

proc `ellipsis=`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `ellipsis`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `ellipsis`*(ih: Label_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ELLIPSIS")) == "YES"

proc `expand=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Label_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Label_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `fgcolor=`*(ih: Label_t, value: string) {.cdecl.} =
    # FGCOLOR: Text color. Default: the global attribute DLGFGCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: Label_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: Label_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

proc `floating=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Label_t, value: string) {.cdecl.} =
    # FONT, EXPAND, SCREENPOSITION, POSITION, MINSIZE, MAXSIZE, WID,
    # TIP, SIZE, RASTERSIZE, ZORDER, VISIBLE, THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary label
proc `font`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary label
proc `fontface`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Label_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Label_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary label
proc `fontstyle`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary label
proc `handlename`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `image=`*(ih: Label_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGE (non inheritable): Image name. If set before map defines
    # the behavior of the label to contain an image. The natural size
    # will be size of the image in pixels. Use IupSetHandle or
    # IupSetAttributeHandle to associate an image to a name. See also
    # IupImage.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: Label_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGE"))

proc `iminactive=`*(ih: Label_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMINACTIVE (non inheritable) [GTK and Motif only]: Image name of
    # the element when inactive. If it is not defined then the IMAGE
    # is used and the colors will be replaced by a modified version of
    # the background color creating the disabled effect. GTK will also
    # change the inactive image to look like other inactive objects.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMINACTIVE"), cast[PIhandle](handle))

proc `iminactive`*(ih: Label_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMINACTIVE"), cast[PIhandle](handle))

proc `iminactive`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMINACTIVE"))

proc `markup=`*(ih: Label_t, value: string) {.cdecl.} =
    # MARKUP [GTK only]: allows the title string to contains pango
    # markup commands. Works only if a mnemonic is NOT defined in the
    # title. Can be "YES" or "NO". Default: "NO".
    SetAttribute(cast[PIhandle](ih), cstring("MARKUP"), cstring(value))

proc `markup`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKUP"), cstring(value))

proc `markup=`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKUP"), cstring((if yes: "YES" else: "NO")))

proc `markup`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKUP"), cstring((if yes: "YES" else: "NO")))

proc `markup`*(ih: Label_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MARKUP")) == "YES"

proc `maxsize=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Label_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Label_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Label_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Label_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary label
proc `name`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary label
proc `normalizergroup`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary label
proc `ntheme`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `padding=`*(ih: Label_t, value: string) {.cdecl.} =
    # PADDING: internal margin. Works just like the MARGIN attribute
    # of the IupHbox and IupVbox containers, but uses a different name
    # to avoid inheritance problems. Not used when SEPARATOR is used.
    # Default value: "0x0". (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding=`*(ih: Label_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: Label_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PADDING"))

# TODO unknown: label PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: label PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Label_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Label_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Label_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Label_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Label_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `screenposition`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `separator=`*(ih: Label_t, value: string) {.cdecl.} =
    # SEPARATOR (creation only) (non inheritable): Turns the label
    # into a line separator. Possible values: "HORIZONTAL" or
    # "VERTICAL". When changed before mapping the EXPAND attribute is
    # set to "HORIZONTALFREE" or "VERTICALFREE" accordingly. (Since
    # 3.11 changed to FREE based expand)
    SetAttribute(cast[PIhandle](ih), cstring("SEPARATOR"), cstring(value))

proc `separator`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SEPARATOR"), cstring(value))

proc `separator`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SEPARATOR"))

proc `size=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Label_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Label_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary label
proc `theme`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary label
proc `tip`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: Label_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Label_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: Label_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Label_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: Label_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Label_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary label
proc `tipicon`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary label
proc `tipmarkup`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: Label_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Label_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Label_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `title=`*(ih: Label_t, value: string) {.cdecl.} =
    # TITLE (non inheritable): Label's text. If SEPARATOR or IMAGE are
    # not defined before map, then the default behavior is to contain
    # a text. The label behavior can not be changed after map. The
    # natural size will be larger enough to include all the text in
    # the selected font, even using multiple lines. The '\n' character
    # is accepted for line change. The "&" character can be used to
    # define a mnemonic, the next character will be used as key. Use
    # "&&" to show the "&" character instead of defining a mnemonic.
    # The next control from the label will be activated from any
    # control in the dialog using the "Alt+key" combination. (mnemonic
    # support since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary label
proc `title`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

proc `usersize=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Label_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Label_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Label_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `wordwrap=`*(ih: Label_t, value: string) {.cdecl.} =
    # WORDWRAP [Windows and GTK only]: enables or disable the wrapping
    # of lines that does not fits in the label. Can be "YES" or "NO".
    # Default: "NO". Can only set WORDWRAP=YES if ALIGNMENT=ALEFT.
    # (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("WORDWRAP"), cstring(value))

proc `wordwrap`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WORDWRAP"), cstring(value))

proc `wordwrap=`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WORDWRAP"), cstring((if yes: "YES" else: "NO")))

proc `wordwrap`*(ih: Label_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WORDWRAP"), cstring((if yes: "YES" else: "NO")))

proc `wordwrap`*(ih: Label_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WORDWRAP")) == "YES"

proc `x`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

# TODO unknown: label XFONTID Unknown Binary
proc `xfontid`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `y`*(ih: Label_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `zorder=`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: Label_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `button_cb=`*(ih: Label_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: Label_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: Label_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `dragbegin_cb=`*(ih: Label_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: Label_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: Label_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: Label_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: Label_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: Label_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: Label_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: Label_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: Label_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: Label_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: Label_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: Label_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: Label_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: Label_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: Label_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: Label_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: Label_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: Label_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: Label_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: Label_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: Label_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: Label_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Label_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Label_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `leavewindow_cb=`*(ih: Label_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Label_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Label_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: Label_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Label_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Label_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: Label_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: Label_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: Label_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `unmap_cb=`*(ih: Label_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Label_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Label_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc Link*(url: string; title: string): Link_t {.cdecl.} =
    # Creates a label that displays an underlined clickable text. It
    # inherits from IupLabel.
    return Link_t(niupc.Link(cstring(url), cstring(title)))

proc `active=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Link_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `alignment=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"))

proc `bgcolor=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: Link_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Link_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `canfocus=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Link_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `cpadding=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding=`*(ih: Link_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: Link_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CPADDING"))

proc `cursor=`*(ih: Link_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: Link_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `dragdrop=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: Link_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: Link_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: Link_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary link
proc `dragtypes`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

proc `dropfilestarget=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: Link_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: Link_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary link
proc `droptypes`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `ellipsis=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ELLIPSIS"), cstring(value))

proc `ellipsis`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ELLIPSIS"), cstring(value))

proc `ellipsis=`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `ellipsis`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `ellipsis`*(ih: Link_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ELLIPSIS")) == "YES"

proc `expand=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Link_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Link_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `fgcolor=`*(ih: Link_t, value: string) {.cdecl.} =
    # FGCOLOR: Text color. Default: the global attribute LINKFGCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: Link_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: Link_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

proc `floating=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary link
proc `font`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary link
proc `fontface`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Link_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Link_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary link
proc `fontstyle`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary link
proc `handlename`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `image=`*(ih: Link_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: Link_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGE"))

proc `iminactive=`*(ih: Link_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMINACTIVE"), cast[PIhandle](handle))

proc `iminactive`*(ih: Link_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMINACTIVE"), cast[PIhandle](handle))

proc `iminactive`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMINACTIVE"))

proc `markup=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKUP"), cstring(value))

proc `markup`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKUP"), cstring(value))

proc `markup=`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKUP"), cstring((if yes: "YES" else: "NO")))

proc `markup`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKUP"), cstring((if yes: "YES" else: "NO")))

proc `markup`*(ih: Link_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MARKUP")) == "YES"

proc `maxsize=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Link_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Link_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Link_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Link_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary link
proc `name`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary link
proc `normalizergroup`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary link
proc `ntheme`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `padding=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding=`*(ih: Link_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: Link_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PADDING"))

# TODO unknown: link PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: link PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Link_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Link_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Link_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Link_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Link_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `screenposition`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `separator=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SEPARATOR"), cstring(value))

proc `separator`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SEPARATOR"), cstring(value))

# TODO ??? String Binary link
proc `separator`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SEPARATOR"))

proc `size=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Link_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Link_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary link
proc `theme`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary link
proc `tip`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: Link_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Link_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: Link_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Link_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: Link_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Link_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary link
proc `tipicon`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary link
proc `tipmarkup`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: Link_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Link_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Link_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `title=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary link
proc `title`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

proc `url=`*(ih: Link_t, value: string) {.cdecl.} =
    # URL: the default value is "YES".
    SetAttribute(cast[PIhandle](ih), cstring("URL"), cstring(value))

proc `url`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("URL"), cstring(value))

# TODO ??? String Binary link
proc `url`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("URL"))

proc `usersize=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Link_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Link_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Link_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `wordwrap=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WORDWRAP"), cstring(value))

proc `wordwrap`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WORDWRAP"), cstring(value))

proc `wordwrap=`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WORDWRAP"), cstring((if yes: "YES" else: "NO")))

proc `wordwrap`*(ih: Link_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WORDWRAP"), cstring((if yes: "YES" else: "NO")))

proc `wordwrap`*(ih: Link_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WORDWRAP")) == "YES"

proc `x`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

# TODO unknown: link XFONTID Unknown Binary
proc `xfontid`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `y`*(ih: Link_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `zorder=`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: Link_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: Link_t, cb: proc (ih: PIhandle, arg2: cstring): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: Link_t, cb: proc (ih: PIhandle, arg2: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: Link_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: Link_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: Link_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: Link_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `dragbegin_cb=`*(ih: Link_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: Link_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: Link_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: Link_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: Link_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: Link_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: Link_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: Link_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: Link_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: Link_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: Link_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: Link_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: Link_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: Link_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: Link_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: Link_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: Link_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: Link_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: Link_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: Link_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: Link_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: Link_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Link_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Link_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `leavewindow_cb=`*(ih: Link_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Link_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Link_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: Link_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Link_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Link_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: Link_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: Link_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: Link_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `unmap_cb=`*(ih: Link_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Link_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Link_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc List*(action: string): List_t {.cdecl.} =
    # Creates an interface element that displays a list of items. The
    # list can be visible or can be dropped down. It also can have an
    # edit box for text input. So it is a 4 in 1 element. In native
    # systems the dropped down case is called Combo Box.
    return List_t(niupc.List(cstring(action)))

proc List*(): List_t {.cdecl.} =
    # Creates an interface element that displays a list of items. The
    # list can be visible or can be dropped down. It also can have an
    # edit box for text input. So it is a 4 in 1 element. In native
    # systems the dropped down case is called Combo Box.
    return List_t(niupc.List(nil))

proc `active=`*(ih: List_t, value: string) {.cdecl.} =
    # ACTIVE, FONT, EXPAND, SCREENPOSITION, POSITION, MINSIZE,
    # MAXSIZE, WID, TIP, RASTERSIZE, ZORDER, VISIBLE, THEME: also
    # accepted.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `append=`*(ih: List_t, value: string) {.cdecl.} =
    # APPEND, CARET, CARETPOS, CLIPBOARD, CUEBANNER, FILTER, INSERT,
    # PADDING, MASK, NC, READONLY, SELECTEDTEXT, SELECTION,
    # SELECTIONPOS, SCROLLTO, SCROLLTOPOS : Same as the IupText
    # attributes, but are valid only when EDITBOX=YES and effective
    # only for the edit box inside the list.
    SetAttribute(cast[PIhandle](ih), cstring("APPEND"), cstring(value))

proc `append`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("APPEND"), cstring(value))

# TODO ??? String Binary list
proc `appenditem=`*(ih: List_t, value: string) {.cdecl.} =
    # APPENDITEM (write-only): inserts an item after the last item.
    # Ignored if set before map. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("APPENDITEM"), cstring(value))

proc `appenditem`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("APPENDITEM"), cstring(value))

# TODO ??? String Binary list
proc `autohide=`*(ih: List_t, value: string) {.cdecl.} =
    # AUTOHIDE: scrollbars are shown only if they are necessary.
    # Default: "YES". When DROPDOWN=YES the scrollbars are system
    # dependent, and do NOT depend on the SCROLLBAR or AUTOHIDE
    # attributes. Usually the scrollbars are shown if necessary. In
    # GTK, scrollbars are never shown and all items are always
    # visible. In Motif, the horizontal scrollbar is never shown. In
    # Windows, if DROPEXPAND=YES then the horizontal scrollbar is
    # never shown.
    SetAttribute(cast[PIhandle](ih), cstring("AUTOHIDE"), cstring(value))

proc `autohide`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOHIDE"), cstring(value))

proc `autohide=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `autohide`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `autohide`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("AUTOHIDE")) == "YES"

proc `autoredraw=`*(ih: List_t, value: string) {.cdecl.} =
    # AUTOREDRAW [Windows] (non inheritable): automatically redraws
    # the list when something has change. Set to NO to add many items
    # to the list without updating the display. Default: "YES". (since
    # 3.3)
    SetAttribute(cast[PIhandle](ih), cstring("AUTOREDRAW"), cstring(value))

proc `autoredraw`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOREDRAW"), cstring(value))

proc `autoredraw=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOREDRAW"), cstring((if yes: "YES" else: "NO")))

proc `autoredraw`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOREDRAW"), cstring((if yes: "YES" else: "NO")))

proc `autoredraw`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("AUTOREDRAW")) == "YES"

proc `bgcolor=`*(ih: List_t, value: string) {.cdecl.} =
    # BGCOLOR: Background color of the text. Default: the global
    # attribute TXTBGCOLOR. In GTK does nothing when DROPDOWN=Yes. In
    # GTK older than 2.12, the editbox of a dropdown will not follow
    # the list attributes: FONT, BGCOLOR, FGCOLOR and SPACING.
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: List_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: List_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `canfocus=`*(ih: List_t, value: string) {.cdecl.} =
    # CANFOCUS (creation only) (non inheritable): enables the focus
    # traversal of the control. In Windows the control will still get
    # the focus when clicked. Default: YES. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `caret=`*(ih: List_t, value: string) {.cdecl.} =
    # APPEND, CARET, CARETPOS, CLIPBOARD, CUEBANNER, FILTER, INSERT,
    # PADDING, MASK, NC, READONLY, SELECTEDTEXT, SELECTION,
    # SELECTIONPOS, SCROLLTO, SCROLLTOPOS : Same as the IupText
    # attributes, but are valid only when EDITBOX=YES and effective
    # only for the edit box inside the list.
    SetAttribute(cast[PIhandle](ih), cstring("CARET"), cstring(value))

proc `caret`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CARET"), cstring(value))

proc `caret=`*(ih: List_t, lin, col:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CARET"), cstring(&"{lin},{col}"))

proc `caret`*(ih: List_t, lin, col:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CARET"), cstring(&"{lin},{col}"))

proc `caret`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CARET"))

proc `caretpos=`*(ih: List_t, value: string) {.cdecl.} =
    # APPEND, CARET, CARETPOS, CLIPBOARD, CUEBANNER, FILTER, INSERT,
    # PADDING, MASK, NC, READONLY, SELECTEDTEXT, SELECTION,
    # SELECTIONPOS, SCROLLTO, SCROLLTOPOS : Same as the IupText
    # attributes, but are valid only when EDITBOX=YES and effective
    # only for the edit box inside the list.
    SetAttribute(cast[PIhandle](ih), cstring("CARETPOS"), cstring(value))

proc `caretpos`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CARETPOS"), cstring(value))

proc `caretpos=`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CARETPOS"), cstring(&"{x}"))

proc `caretpos`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CARETPOS"), cstring(&"{x}"))

proc `caretpos`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CARETPOS"))

proc `charsize`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `clipboard=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIPBOARD"), cstring(value))

proc `clipboard`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIPBOARD"), cstring(value))

proc `clipboard`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIPBOARD"))

proc `count`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("COUNT"))

proc `cpadding=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding=`*(ih: List_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: List_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CPADDING"))

proc `cspacing=`*(ih: List_t, value: string) {.cdecl.} =
    # CSPACING: same as SPACING but using the units of the vertical
    # part of the SIZE attribute. It will actually set the SPACING
    # attribute. (since 3.29)
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(value))

proc `cspacing`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(value))

proc `cspacing=`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(&"{x}"))

proc `cspacing`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(&"{x}"))

proc `cspacing`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CSPACING"))

proc `dragdrop=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragdroplist=`*(ih: List_t, value: string) {.cdecl.} =
    # DRAGDROPLIST (non inheritable): prepare the Drag & Drop
    # callbacks to support drag and drop of items between lists
    # (IupList or IupFlatList), in the same IUP application. Drag &
    # Drop attributes still need to be set in order to activate the
    # drag & drop support, so the application can control if this list
    # will be source and/or target. Default: NO. (since 3.10)
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROPLIST"), cstring(value))

proc `dragdroplist`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROPLIST"), cstring(value))

proc `dragdroplist=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROPLIST"), cstring((if yes: "YES" else: "NO")))

proc `dragdroplist`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROPLIST"), cstring((if yes: "YES" else: "NO")))

proc `dragdroplist`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROPLIST")) == "YES"

proc `dragsource=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary list
proc `dragtypes`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

proc `dropdown=`*(ih: List_t, value: string) {.cdecl.} =
    # DROPDOWN (creation only): Changes the appearance of the list for
    # the user: only the selected item is shown beside a button with
    # the image of an arrow pointing down. To select another option,
    # the user must press this button, which displays all items in the
    # list. Can be "YES" or "NO". Default "NO".
    SetAttribute(cast[PIhandle](ih), cstring("DROPDOWN"), cstring(value))

proc `dropdown`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPDOWN"), cstring(value))

proc `dropdown=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPDOWN"), cstring((if yes: "YES" else: "NO")))

proc `dropdown`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPDOWN"), cstring((if yes: "YES" else: "NO")))

proc `dropdown`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPDOWN")) == "YES"

proc `dropexpand=`*(ih: List_t, value: string) {.cdecl.} =
    # DROPEXPAND [Windows Only]: When DROPDOWN=Yes the size of the
    # dropped list will expand to include the largest text. Can be
    # "YES" or "NO". Default: "YES".
    SetAttribute(cast[PIhandle](ih), cstring("DROPEXPAND"), cstring(value))

proc `dropexpand`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPEXPAND"), cstring(value))

proc `dropexpand=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPEXPAND"), cstring((if yes: "YES" else: "NO")))

proc `dropexpand`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPEXPAND"), cstring((if yes: "YES" else: "NO")))

proc `dropexpand`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPEXPAND")) == "YES"

proc `dropfilestarget=`*(ih: List_t, value: string) {.cdecl.} =
    # DROPFILESTARGET [Windows and GTK Only] (non inheritable): Enable
    # or disable the drop of files. Default: NO, but if DROPFILES_CB
    # is defined when the element is mapped then it will be
    # automatically enabled. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary list
proc `droptypes`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `editbox=`*(ih: List_t, value: string) {.cdecl.} =
    # EDITBOX (creation only): Adds an edit box to the list. Can be
    # "YES" or "NO". Default "NO".
    SetAttribute(cast[PIhandle](ih), cstring("EDITBOX"), cstring(value))

proc `editbox`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EDITBOX"), cstring(value))

proc `editbox=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EDITBOX"), cstring((if yes: "YES" else: "NO")))

proc `editbox`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EDITBOX"), cstring((if yes: "YES" else: "NO")))

proc `editbox`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EDITBOX")) == "YES"

proc `expand=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: List_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: List_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `fgcolor=`*(ih: List_t, value: string) {.cdecl.} =
    # FGCOLOR: Text color. Default: the global attribute TXTFGCOLOR.
    # In GTK older than 2.12, the editbox of a dropdown will not
    # follow the list attributes: FONT, BGCOLOR, FGCOLOR and SPACING.
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: List_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: List_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

proc `floating=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: List_t, value: string) {.cdecl.} =
    # In GTK older than 2.12, the editbox of a dropdown will not
    # follow the list attributes: FONT, BGCOLOR, FGCOLOR and SPACING.
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary list
proc `font`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary list
proc `fontface`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary list
proc `fontstyle`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary list
proc `handlename`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

# TODO getter list IDVALUE
# TODO getter list IMAGE
# TODO getter list IMAGENATIVEHANDLE
# TODO unknown: list INSERT Unknown Binary
# TODO getter list INSERTITEM
proc `mask=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASK"), cstring(value))

proc `mask`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASK"), cstring(value))

# TODO ??? String Binary list
proc `mask`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASK"))

proc `maskcasei=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKCASEI"), cstring(value))

proc `maskcasei`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKCASEI"), cstring(value))

proc `maskcasei=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKCASEI"), cstring((if yes: "YES" else: "NO")))

proc `maskcasei`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKCASEI"), cstring((if yes: "YES" else: "NO")))

proc `maskcasei`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASKCASEI")) == "YES"

proc `maskdecimalsymbol=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKDECIMALSYMBOL"), cstring(value))

proc `maskdecimalsymbol`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKDECIMALSYMBOL"), cstring(value))

# TODO ??? String Binary list
proc `maskdecimalsymbol`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASKDECIMALSYMBOL"))

proc `maskfloat=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKFLOAT"), cstring(value))

proc `maskfloat`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKFLOAT"), cstring(value))

proc `maskfloat=`*(ih: List_t, min, max:float) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKFLOAT"), cstring(&"{min},{max}"))

proc `maskfloat`*(ih: List_t, min, max:float) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKFLOAT"), cstring(&"{min},{max}"))

proc `maskfloat`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASKFLOAT"))

proc `maskint=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKINT"), cstring(value))

proc `maskint`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKINT"), cstring(value))

proc `maskint=`*(ih: List_t, min, max:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKINT"), cstring(&"{min},{max}"))

proc `maskint`*(ih: List_t, min, max:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKINT"), cstring(&"{min},{max}"))

proc `maskint`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASKINT"))

proc `masknoempty=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKNOEMPTY"), cstring(value))

proc `masknoempty`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKNOEMPTY"), cstring(value))

proc `masknoempty=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKNOEMPTY"), cstring((if yes: "YES" else: "NO")))

proc `masknoempty`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKNOEMPTY"), cstring((if yes: "YES" else: "NO")))

proc `masknoempty`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASKNOEMPTY")) == "YES"

proc `maskreal=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKREAL"), cstring(value))

proc `maskreal`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKREAL"), cstring(value))

proc `maskreal`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASKREAL"))

proc `maxsize=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: List_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: List_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: List_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: List_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `multiple=`*(ih: List_t, value: string) {.cdecl.} =
    # MULTIPLE (creation only): Allows selecting several items
    # simultaneously (multiple list). Default: "NO". Only valid when
    # EDITBOX=NO and DROPDOWN=NO.
    SetAttribute(cast[PIhandle](ih), cstring("MULTIPLE"), cstring(value))

proc `multiple`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MULTIPLE"), cstring(value))

proc `multiple=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MULTIPLE"), cstring((if yes: "YES" else: "NO")))

proc `multiple`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MULTIPLE"), cstring((if yes: "YES" else: "NO")))

proc `multiple`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MULTIPLE")) == "YES"

proc `name=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary list
proc `name`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `nc=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NC"), cstring(value))

proc `nc`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NC"), cstring(value))

proc `nc=`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NC"), cstring(&"{x}"))

proc `nc`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NC"), cstring(&"{x}"))

proc `nc`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NC"))

proc `normalizergroup=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary list
proc `normalizergroup`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary list
proc `ntheme`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `padding=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding=`*(ih: List_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: List_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PADDING"))

# TODO unknown: list PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: list PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: List_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: List_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: List_t, value: string) {.cdecl.} =
    # PROPAGATEFOCUS(non inheritable): enables the focus callback
    # forwarding to the next native parent with FOCUS_CB defined.
    # Default: NO. (since 3.23)
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: List_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: List_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `readonly=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("READONLY"), cstring(value))

proc `readonly`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("READONLY"), cstring(value))

proc `readonly=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("READONLY"), cstring((if yes: "YES" else: "NO")))

proc `readonly`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("READONLY"), cstring((if yes: "YES" else: "NO")))

proc `readonly`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("READONLY")) == "YES"

proc `removeitem=`*(ih: List_t, value: string) {.cdecl.} =
    # REMOVEITEM (write-only): removes the given value. value starts
    # at 1. If value is NULL or "ALL" removes all the items. Ignored
    # if set before map. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("REMOVEITEM"), cstring(value))

proc `removeitem`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("REMOVEITEM"), cstring(value))

proc `removeitem=`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("REMOVEITEM"), cstring(&"{x}"))

proc `removeitem`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("REMOVEITEM"), cstring(&"{x}"))

proc `screenposition`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `scrollbar=`*(ih: List_t, value: string) {.cdecl.} =
    # SCROLLBAR (creation only): Associates automatic scrollbars to
    # the list when DROPDOWN=NO. Can be: "YES" or "NO" (none).
    # Default: "YES". For all systems, when SCROLLBAR=YES the natural
    # size will always include its size even if the native system
    # hides the scrollbars. If AUTOHIDE=YES scrollbars are shown only
    # if they are necessary, by default AUTOHIDE=YES. In Motif,
    # SCROLLBAR=NO is not supported and if EDITBOX=YES the horizontal
    # scrollbar is never shown. When DROPDOWN=YES the scrollbars are
    # system dependent, and do NOT depend on the SCROLLBAR or AUTOHIDE
    # attributes. Usually the scrollbars are shown if necessary. In
    # GTK, scrollbars are never shown and all items are always
    # visible. In Motif, the horizontal scrollbar is never shown. In
    # Windows, if DROPEXPAND=YES then the horizontal scrollbar is
    # never shown.
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR")) == "YES"

proc `scrollto=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTO"), cstring(value))

proc `scrollto`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTO"), cstring(value))

proc `scrollto=`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTO"), cstring(&"{x}"))

proc `scrollto`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTO"), cstring(&"{x}"))

proc `scrolltopos=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTOPOS"), cstring(value))

proc `scrolltopos`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTOPOS"), cstring(value))

proc `scrolltopos=`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTOPOS"), cstring(&"{x}"))

proc `scrolltopos`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTOPOS"), cstring(&"{x}"))

proc `selectedtext=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTEDTEXT"), cstring(value))

proc `selectedtext`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTEDTEXT"), cstring(value))

# TODO ??? String Binary list
proc `selectedtext`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SELECTEDTEXT"))

proc `selection=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTION"), cstring(value))

proc `selection`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTION"), cstring(value))

proc `selection=`*(ih: List_t, lin1,col1,lin2,col2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTION"), cstring(&"{lin1},{col1}:{lin2},{col2}"))

proc `selection`*(ih: List_t, lin1,col1,lin2,col2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTION"), cstring(&"{lin1},{col1}:{lin2},{col2}"))

proc `selection=`*(ih: List_t, col1,col2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTION"), cstring(&"{col1}:{col2}"))

proc `selection`*(ih: List_t, col1,col2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTION"), cstring(&"{col1}:{col2}"))

proc `selection`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SELECTION"))

proc `selectionpos=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTIONPOS"), cstring(value))

proc `selectionpos`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTIONPOS"), cstring(value))

proc `selectionpos=`*(ih: List_t, min, max:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTIONPOS"), cstring(&"{min},{max}"))

proc `selectionpos`*(ih: List_t, min, max:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTIONPOS"), cstring(&"{min},{max}"))

proc `selectionpos`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SELECTIONPOS"))

proc `showdragdrop=`*(ih: List_t, value: string) {.cdecl.} =
    # SHOWDRAGDROP (creation only) (non inheritable): enables the
    # internal drag and drop of items in the same list, and enables
    # the DRAGDROP_CB callback. Default: "NO". Works only if
    # DROPDOWN=NO and MULTIPLE=NO. Drag & Drop attributes are NOT
    # used. (since 3.7)
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDRAGDROP"), cstring(value))

proc `showdragdrop`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDRAGDROP"), cstring(value))

proc `showdragdrop=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `showdragdrop`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `showdragdrop`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWDRAGDROP")) == "YES"

proc `showdropdown=`*(ih: List_t, value: string) {.cdecl.} =
    # SHOWDROPDOWN (write-only): opens or closes the dropdown list.
    # Can be "YES" or "NO". Valid only when DROPDOWN=YES. Ignored if
    # set before map.
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDROPDOWN"), cstring(value))

proc `showdropdown`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDROPDOWN"), cstring(value))

proc `showdropdown=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDROPDOWN"), cstring((if yes: "YES" else: "NO")))

proc `showdropdown`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDROPDOWN"), cstring((if yes: "YES" else: "NO")))

proc `showimage=`*(ih: List_t, value: string) {.cdecl.} =
    # SHOWIMAGE (creation only) [Windows and GTK Only]: enables the
    # use of an image for each item. Can be "YES" or "NO". Ignored if
    # set after map. (since 3.6)
    SetAttribute(cast[PIhandle](ih), cstring("SHOWIMAGE"), cstring(value))

proc `showimage`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWIMAGE"), cstring(value))

proc `showimage=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWIMAGE"), cstring((if yes: "YES" else: "NO")))

proc `showimage`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWIMAGE"), cstring((if yes: "YES" else: "NO")))

proc `showimage`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWIMAGE")) == "YES"

proc `size=`*(ih: List_t, value: string) {.cdecl.} =
    # SIZE: Size of the list. The Natural Size is defined by the
    # number of elements in the list and the with of the largest item,
    # the default has room for 5 characters in 1 item. In IUP 3, the
    # Natural Size ignores the list contents if VISIBLECOLUMNS or
    # VISIBLELINES attributes are defined. The text in the edit box is
    # ignored when considering the list contents.
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: List_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: List_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `spacing=`*(ih: List_t, value: string) {.cdecl.} =
    # SPACING: internal padding for each item. Notice that vertically
    # the distance between each item will be actually 2x the spacing.
    # It also affects the horizontal margin of the item. In Windows,
    # the text is aligned at the top left of the item always. Valid
    # only when DROPDOWN=NO. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(value))

proc `spacing`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(value))

proc `spacing=`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(&"{x}"))

proc `spacing`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(&"{x}"))

proc `spacing`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPACING"))

proc `theme=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary list
proc `theme`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary list
proc `tip`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: List_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: List_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: List_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: List_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary list
proc `tipicon`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary list
proc `tipmarkup`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: List_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: List_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `topitem=`*(ih: List_t, value: string) {.cdecl.} =
    # TOPITEM (write-only): position the given item at the top of the
    # list or near to make it visible. Valid only when DROPDOWN=NO.
    # (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("TOPITEM"), cstring(value))

proc `topitem`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPITEM"), cstring(value))

proc `topitem=`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPITEM"), cstring(&"{x}"))

proc `topitem`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPITEM"), cstring(&"{x}"))

proc `topitem`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOPITEM"))

proc `usersize=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: List_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: List_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: List_t, value: string) {.cdecl.} =
    # VALUE (non inheritable): Depends on the DROPDOWN+EDITBOX
    # combination: EDITBOX=YES: Text entered by the user.
    # MULTIPLE=YES: Sequence of '+' and '-' symbols indicating the
    # state of each item. When setting this value, the user must
    # provide the same amount of '+' and '-' symbols as the amount of
    # items in the list, otherwise the specified items will be
    # deselected. Others: Integer number representing the selected
    # item in the list (begins at 1). It can be zero if there is no
    # selected item. (In Motif when DROPDOWN=YES there is always an
    # item selected, except when the list is empty). Should return a
    # non NULL value, even when the list is empty or the text box is
    # empty. It can be NULL when no item selected (since 3.0). The
    # state=0 is simulated internally by IUP in all systems. If you
    # add or remove items to/from the list and you count on the
    # state=0 value, then after adding/removing items set the VALUE
    # attribute to ensure proper state=0 value. The non changed items
    # marked with 'x' are simulated internally by IUP in all systems.
    # If you add or remove items to/from the list and you count on the
    # 'x' values, then after adding/removing items set the VALUE
    # attribute to ensure proper 'x' values.
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

# TODO ??? String Binary list
proc `value`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `valuemasked=`*(ih: List_t, value: string) {.cdecl.} =
    # VALUEMASKED (non inheritable) (write-only): sets VALUE but first
    # checks if it is validated by MASK. If not does nothing. Works
    # only when EDITBOX=YES. (since 3.13)
    SetAttribute(cast[PIhandle](ih), cstring("VALUEMASKED"), cstring(value))

proc `valuemasked`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUEMASKED"), cstring(value))

# TODO ??? String Binary list
proc `valuestring=`*(ih: List_t, value: string) {.cdecl.} =
    # VALUESTRING (non inheritable): changes or retrieves the value
    # attribute using a string of an item. Works only when EDITBOX=NO
    # and DROPDOWN=YES, or DROPDOWN=NO and MULTIPLE=NO. When set it
    # will search for the first item with the same string. (since
    # 3.12)
    SetAttribute(cast[PIhandle](ih), cstring("VALUESTRING"), cstring(value))

proc `valuestring`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUESTRING"), cstring(value))

# TODO ??? String Binary list
proc `valuestring`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUESTRING"))

proc `visible=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: List_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: List_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `visiblecolumns=`*(ih: List_t, value: string) {.cdecl.} =
    # VISIBLECOLUMNS: Defines the number of visible columns for the
    # Natural Size, this means that will act also as minimum number of
    # visible columns. It uses a wider character size then the one
    # used for the SIZE attribute so strings will fit better without
    # the need of extra columns. Set this attribute to speed Natural
    # Size computation for very large lists. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"), cstring(value))

proc `visiblecolumns`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"), cstring(value))

proc `visiblecolumns=`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"), cstring(&"{x}"))

proc `visiblecolumns`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"), cstring(&"{x}"))

proc `visiblecolumns`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"))

proc `visibleitems=`*(ih: List_t, value: string) {.cdecl.} =
    # VISIBLEITEMS [Windows and Motif Only]: Number of items that are
    # visible when DROPDOWN=YES is used for the dropdown list.
    # Default: 5.
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLEITEMS"), cstring(value))

proc `visibleitems`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLEITEMS"), cstring(value))

proc `visibleitems=`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLEITEMS"), cstring(&"{x}"))

proc `visibleitems`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLEITEMS"), cstring(&"{x}"))

proc `visibleitems`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLEITEMS"))

proc `visiblelines=`*(ih: List_t, value: string) {.cdecl.} =
    # VISIBLELINES: When DROPDOWN=NO defines the number of visible
    # lines for the Natural Size, this means that will act also as
    # minimum number of visible lines. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLELINES"), cstring(value))

proc `visiblelines`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLELINES"), cstring(value))

proc `visiblelines=`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLELINES"), cstring(&"{x}"))

proc `visiblelines`*(ih: List_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLELINES"), cstring(&"{x}"))

proc `visiblelines`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLELINES"))

proc `wid`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

# TODO unknown: list XFONTID Unknown Binary
proc `xfontid`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `y`*(ih: List_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `zorder=`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: List_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: List_t, cb: proc (ih: PIhandle, text: cstring, item, state: cint): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: List_t, cb: proc (ih: PIhandle, text: cstring, item, state: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: List_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: List_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `caret_cb=`*(ih: List_t, cb: proc (ih: PIhandle, lin, col,  pos: cint): cint {.cdecl.}) {.cdecl.} =
    # This is the same CARET_CB callback definition as for the
    # IupText.
    SetCallback(cast[PIhandle](ih), cstring("CARET_CB"), cast[Icallback](cb))

proc `caret_cb`*(ih: List_t, cb: proc (ih: PIhandle, lin, col,  pos: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("CARET_CB"), cast[Icallback](cb))

proc `caret_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("CARET_CB")))

proc `dblclick_cb=`*(ih: List_t, cb: proc (ih: PIhandle, item: cint, text: cstring): cint {.cdecl.}) {.cdecl.} =
    # DBLCLICK_CB: Action generated when the user double click an
    # item. Called only when DROPDOWN=NO. (since 3.0) int function
    # (Ihandle *ih, int item, char *text); [in C]ih:dblclick_cb(item:
    # number, text: string) -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("DBLCLICK_CB"), cast[Icallback](cb))

proc `dblclick_cb`*(ih: List_t, cb: proc (ih: PIhandle, item: cint, text: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DBLCLICK_CB"), cast[Icallback](cb))

proc `dblclick_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DBLCLICK_CB")))

proc `destroy_cb=`*(ih: List_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: List_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: List_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: List_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: List_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: List_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: List_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: List_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragdrop_cb=`*(ih: List_t, cb: proc (ih: PIhandle, drag_id, drop_id, isshift, iscontrol: cint): cint {.cdecl.}) {.cdecl.} =
    # DRAGDROP_CB: Action generated when an internal drag and drop is
    # executed. Only active if SHOWDRAGDROP=YES. (since 3.7) int
    # function(Ihandle *ih, int drag_id, int drop_id, int isshift, int
    # iscontrol); [in C] ih:dragdrop_cb(drag_id, drop_id, isshift,
    # iscontrol: number) -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("DRAGDROP_CB"), cast[Icallback](cb))

proc `dragdrop_cb`*(ih: List_t, cb: proc (ih: PIhandle, drag_id, drop_id, isshift, iscontrol: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDROP_CB"), cast[Icallback](cb))

proc `dragdrop_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDROP_CB")))

proc `dragend_cb=`*(ih: List_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: List_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: List_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: List_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropdown_cb=`*(ih: List_t, cb: proc (ih: PIhandle, state: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPDOWN_CB: Action generated when the list of a dropdown is
    # shown or hidden. Called only when DROPDOWN=YES. (since 3.0) int
    # function (Ihandle *ih, int state); [in C]ih:dropdown_cb(state:
    # boolean) -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("DROPDOWN_CB"), cast[Icallback](cb))

proc `dropdown_cb`*(ih: List_t, cb: proc (ih: PIhandle, state: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDOWN_CB"), cast[Icallback](cb))

proc `dropdown_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDOWN_CB")))

proc `dropfiles_cb=`*(ih: List_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: List_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: List_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: List_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `edit_cb=`*(ih: List_t, cb: proc (ih: PIhandle, c: cint, new_value: cstring): cint {.cdecl.}) {.cdecl.} =
    # EDIT_CB: Action generated when the text in the text box is
    # manually changed by the user, but before its value is actually
    # updated. Valid only when EDITBOX=YES. int function(Ihandle *ih,
    # int c, char *new_value); [in C]ih:edit_cb(c: number, new_value:
    # string) -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("EDIT_CB"), cast[Icallback](cb))

proc `edit_cb`*(ih: List_t, cb: proc (ih: PIhandle, c: cint, new_value: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("EDIT_CB"), cast[Icallback](cb))

proc `edit_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("EDIT_CB")))

proc `enterwindow_cb=`*(ih: List_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: List_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `getfocus_cb=`*(ih: List_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: List_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: List_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: List_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `killfocus_cb=`*(ih: List_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: List_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: List_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: List_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: List_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: List_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: List_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: List_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: List_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: List_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: List_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: List_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `multiselect_cb=`*(ih: List_t, cb: proc (ih: PIhandle, value: cstring): cint {.cdecl.}) {.cdecl.} =
    # MULTISELECT_CB: Action generated when the state of an item in
    # the multiple selection list is changed. But it is called only
    # when the interaction is over. int function (Ihandle *ih, char
    # *value); [in C]ih:multiselect_cb(value: string) -> (ret: number)
    # [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("MULTISELECT_CB"), cast[Icallback](cb))

proc `multiselect_cb`*(ih: List_t, cb: proc (ih: PIhandle, value: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MULTISELECT_CB"), cast[Icallback](cb))

proc `multiselect_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MULTISELECT_CB")))

proc `postmessage_cb=`*(ih: List_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: List_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: List_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: List_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `valuechanged_cb=`*(ih: List_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # VALUECHANGED_CB: Called after the value was interactively
    # changed by the user. Called when the selection is changed or
    # when the text is edited. (since 3.0) int function(Ihandle *ih);
    # [in C]ih:valuechanged_cb() -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: List_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: List_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB")))

macro Menu*(args: varargs[untyped]): Menu_t =
    # Creates a menu element, which groups 3 types of interface
    # elements: item, submenu and separator. Any other interface
    # element defined inside a menu will be an error.


    result = nnkCall.newTree(
        nnkDotExpr.newTree(
            newIdentNode("niup"),
            newIdentNode("Menu_t")
          ),
       )
    let inner = nnkCall.newTree(
            newIdentNode("Menu")
          )

    if args.len > 0:
        for i in 0 ..< args.len:
          inner.add nnkCast.newTree(newIdentNode("PIhandle"), args[i])
    inner.add newNilLit()
    result.add inner


proc `bgcolor=`*(ih: Menu_t, value: string) {.cdecl.} =
    # BGCOLOR: the background color of the menu, affects all items in
    # the menu. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: Menu_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: Menu_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Menu_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Menu_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `font=`*(ih: Menu_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Menu_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary menu
proc `font`*(ih: Menu_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `name=`*(ih: Menu_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Menu_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary menu
proc `name`*(ih: Menu_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `radio=`*(ih: Menu_t, value: string) {.cdecl.} =
    # RADIO (non inheritable): enables the automatic toggle of one
    # child item. When a child item is selected the other item is
    # automatically deselected. The menu acts like a IupRadio for its
    # children. Submenus and their children are not affected.
    SetAttribute(cast[PIhandle](ih), cstring("RADIO"), cstring(value))

proc `radio`*(ih: Menu_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RADIO"), cstring(value))

proc `radio=`*(ih: Menu_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RADIO"), cstring((if yes: "YES" else: "NO")))

proc `radio`*(ih: Menu_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RADIO"), cstring((if yes: "YES" else: "NO")))

proc `radio`*(ih: Menu_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RADIO")) == "YES"

proc `wid`*(ih: Menu_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `destroy_cb=`*(ih: Menu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Menu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Menu_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `ldestroy_cb=`*(ih: Menu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Menu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Menu_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: Menu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Menu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Menu_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `menuclose_cb=`*(ih: Menu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MENUCLOSE_CB MENUCLOSE_CB Called just after the menu is closed.
    # Callback int function(Ihandle *ih); [in C] ih:menuclose_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects IupMenu
    SetCallback(cast[PIhandle](ih), cstring("MENUCLOSE_CB"), cast[Icallback](cb))

proc `menuclose_cb`*(ih: Menu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MENUCLOSE_CB"), cast[Icallback](cb))

proc `menuclose_cb`*(ih: Menu_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MENUCLOSE_CB")))

proc `open_cb=`*(ih: Menu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # OPEN_CB OPEN_CB Called just before the menu is opened. Callback
    # int function(Ihandle *ih); [in C] ih:open_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects IupMenu
    SetCallback(cast[PIhandle](ih), cstring("OPEN_CB"), cast[Icallback](cb))

proc `open_cb`*(ih: Menu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("OPEN_CB"), cast[Icallback](cb))

proc `open_cb`*(ih: Menu_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("OPEN_CB")))

proc `postmessage_cb=`*(ih: Menu_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Menu_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Menu_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: Menu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Menu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Menu_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc MessageDlg*(): MessageDlg_t {.cdecl.} =
    # Creates the Message Dialog element. It is a predefined dialog
    # for displaying a message. The dialog can be shown with the
    # IupPopup function only.
    return MessageDlg_t(niupc.MessageDlg())

proc `active=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `activewindow`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVEWINDOW")) == "YES"

proc `background=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(value))

proc `background`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(value))

proc `background=`*(ih: MessageDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(&"{red} {green} {blue} {alpha}"))

proc `background`*(ih: MessageDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(&"{red} {green} {blue} {alpha}"))

proc `background`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"))

proc `bgcolor=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: MessageDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: MessageDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `bordersize`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERSIZE"))

proc `bringfront=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring(value))

proc `bringfront`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring(value))

proc `bringfront=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring((if yes: "YES" else: "NO")))

proc `bringfront`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring((if yes: "YES" else: "NO")))

proc `bringfront`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT")) == "YES"

proc `buttondefault=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    # BUTTONDEFAULT: Number of the default button. Can be "1", "2" or
    # "3". "2" is valid only for "RETRYCANCEL", "OKCANCEL" and "YESNO"
    # button configurations. "3" is valid only for "YESNOCANCEL".
    # Default: "1".
    SetAttribute(cast[PIhandle](ih), cstring("BUTTONDEFAULT"), cstring(value))

proc `buttondefault`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BUTTONDEFAULT"), cstring(value))

proc `buttondefault`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BUTTONDEFAULT"))

proc `buttonresponse=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    # BUTTONRESPONSE: Number of the pressed button. Can be "1", "2" or
    # "3". Default: "1".
    SetAttribute(cast[PIhandle](ih), cstring("BUTTONRESPONSE"), cstring(value))

proc `buttonresponse`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BUTTONRESPONSE"), cstring(value))

proc `buttonresponse`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BUTTONRESPONSE"))

proc `buttons=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    # BUTTONS: Buttons configuration. Can have values: "OK",
    # "OKCANCEL", "RETRYCANCEL", "YESNO", or "YESNOCANCEL". Default:
    # "OK". Additionally the "Help" button is displayed if the HELP_CB
    # callback is defined. (RETRYCANCEL and YESNOCANCEL since 3.16)
    SetAttribute(cast[PIhandle](ih), cstring("BUTTONS"), cstring(value))

proc `buttons`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BUTTONS"), cstring(value))

proc `buttons`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BUTTONS"))

proc `canfocus=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `childoffset=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset=`*(ih: MessageDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: MessageDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"))

proc `clientoffset`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(value))

proc `clientsize`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(value))

proc `clientsize=`*(ih: MessageDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(&"{width}x{height}"))

proc `clientsize`*(ih: MessageDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(&"{width}x{height}"))

proc `clientsize`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `composited=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring(value))

proc `composited`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring(value))

proc `composited=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring((if yes: "YES" else: "NO")))

proc `composited`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring((if yes: "YES" else: "NO")))

proc `composited`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("COMPOSITED")) == "YES"

proc `control=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring(value))

proc `control`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring(value))

proc `control=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring((if yes: "YES" else: "NO")))

proc `control`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring((if yes: "YES" else: "NO")))

proc `control`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CONTROL")) == "YES"

proc `cursor=`*(ih: MessageDlg_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: MessageDlg_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `customframe=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring(value))

proc `customframe`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring(value))

proc `customframe=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring((if yes: "YES" else: "NO")))

proc `customframe`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring((if yes: "YES" else: "NO")))

proc `customframe`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME")) == "YES"

proc `customframesimulate=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring(value))

proc `customframesimulate`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring(value))

proc `customframesimulate=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring((if yes: "YES" else: "NO")))

proc `customframesimulate`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring((if yes: "YES" else: "NO")))

proc `customframesimulate`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE")) == "YES"

proc `defaultenter=`*(ih: MessageDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTENTER"), cast[PIhandle](handle))

proc `defaultenter`*(ih: MessageDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTENTER"), cast[PIhandle](handle))

proc `defaultenter`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DEFAULTENTER"))

proc `defaultesc=`*(ih: MessageDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTESC"), cast[PIhandle](handle))

proc `defaultesc`*(ih: MessageDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTESC"), cast[PIhandle](handle))

proc `defaultesc`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DEFAULTESC"))

proc `dialogframe=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring(value))

proc `dialogframe`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring(value))

proc `dialogframe=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring((if yes: "YES" else: "NO")))

proc `dialogframe`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring((if yes: "YES" else: "NO")))

proc `dialogframe`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME")) == "YES"

proc `dialoghint=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring(value))

proc `dialoghint`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring(value))

proc `dialoghint=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring((if yes: "YES" else: "NO")))

proc `dialoghint`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring((if yes: "YES" else: "NO")))

proc `dialoghint`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT")) == "YES"

proc `dialogtype=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    # DIALOGTYPE: Type of dialog defines which icon will be displayed
    # besides the message text. Can have values: "MESSAGE" (No Icon),
    # "ERROR" (Stop-sign), "WARNING" (Exclamation-point), "QUESTION"
    # (Question-mark) or "INFORMATION" (Letter "i"). Default:
    # "MESSAGE".
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGTYPE"), cstring(value))

proc `dialogtype`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGTYPE"), cstring(value))

proc `dialogtype`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DIALOGTYPE"))

proc `dragdrop=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary messagedlg
proc `dragtypes`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

proc `dropfilestarget=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary messagedlg
proc `droptypes`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `expand=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: MessageDlg_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: MessageDlg_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary messagedlg
proc `font`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary messagedlg
proc `fontface`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: MessageDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: MessageDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary messagedlg
proc `fontstyle`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `fullscreen=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring(value))

proc `fullscreen`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring(value))

proc `fullscreen=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring((if yes: "YES" else: "NO")))

proc `fullscreen`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring((if yes: "YES" else: "NO")))

proc `handlename=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary messagedlg
proc `handlename`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `helpbutton=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring(value))

proc `helpbutton`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring(value))

proc `helpbutton=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring((if yes: "YES" else: "NO")))

proc `helpbutton`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring((if yes: "YES" else: "NO")))

proc `helpbutton`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON")) == "YES"

proc `hidetaskbar=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring(value))

proc `hidetaskbar`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring(value))

proc `hidetaskbar=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring((if yes: "YES" else: "NO")))

proc `hidetaskbar`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring((if yes: "YES" else: "NO")))

proc `hidetaskbar`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR")) == "YES"

proc `hidetitlebar=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETITLEBAR"), cstring(value))

proc `hidetitlebar`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETITLEBAR"), cstring(value))

# TODO ??? String Binary messagedlg
proc `hidetitlebar`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIDETITLEBAR"))

proc `icon=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ICON"), cstring(value))

proc `icon`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ICON"), cstring(value))

# TODO ??? String Binary messagedlg
proc `icon`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ICON"))

proc `maxbox=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring(value))

proc `maxbox`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring(value))

proc `maxbox=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring((if yes: "YES" else: "NO")))

proc `maxbox`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring((if yes: "YES" else: "NO")))

proc `maxbox`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXBOX")) == "YES"

proc `maximized`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXIMIZED")) == "YES"

proc `maxsize=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: MessageDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: MessageDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `mdichild=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring(value))

proc `mdichild`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring(value))

proc `mdichild=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring((if yes: "YES" else: "NO")))

proc `mdichild`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring((if yes: "YES" else: "NO")))

proc `mdichild`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDICHILD")) == "YES"

proc `mdiclient=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring(value))

proc `mdiclient`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring(value))

proc `mdiclient=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring((if yes: "YES" else: "NO")))

proc `mdiclient`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring((if yes: "YES" else: "NO")))

proc `mdiclient`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDICLIENT")) == "YES"

proc `mdiframe=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring(value))

proc `mdiframe`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring(value))

proc `mdiframe=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring((if yes: "YES" else: "NO")))

proc `mdiframe`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring((if yes: "YES" else: "NO")))

proc `mdiframe`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDIFRAME")) == "YES"

proc `mdimenu=`*(ih: MessageDlg_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MDIMENU"), cast[PIhandle](handle))

proc `mdimenu`*(ih: MessageDlg_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MDIMENU"), cast[PIhandle](handle))

proc `mdimenu`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDIMENU"))

proc `menu=`*(ih: MessageDlg_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MENU"), cast[PIhandle](handle))

proc `menu`*(ih: MessageDlg_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MENU"), cast[PIhandle](handle))

proc `menu`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MENU"))

proc `menubox=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring(value))

proc `menubox`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring(value))

proc `menubox=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring((if yes: "YES" else: "NO")))

proc `menubox`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring((if yes: "YES" else: "NO")))

proc `menubox`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MENUBOX")) == "YES"

proc `minbox=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring(value))

proc `minbox`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring(value))

proc `minbox=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring((if yes: "YES" else: "NO")))

proc `minbox`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring((if yes: "YES" else: "NO")))

proc `minbox`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINBOX")) == "YES"

proc `minsize=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: MessageDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: MessageDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `modal`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MODAL")) == "YES"

proc `nactive=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring(value))

proc `nactive`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring(value))

proc `nactive=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `nactive`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `nactive`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NACTIVE")) == "YES"

proc `name=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary messagedlg
proc `name`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `nativeparent=`*(ih: MessageDlg_t, handle: User_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("NATIVEPARENT"), cast[PIhandle](handle))

proc `nativeparent`*(ih: MessageDlg_t, handle: User_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("NATIVEPARENT"), cast[PIhandle](handle))

proc `nativeparent`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATIVEPARENT"))

proc `naturalsize`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `noflush=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring(value))

proc `noflush`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring(value))

proc `noflush=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring((if yes: "YES" else: "NO")))

proc `noflush`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring((if yes: "YES" else: "NO")))

proc `noflush`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NOFLUSH")) == "YES"

proc `normalizergroup=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary messagedlg
proc `normalizergroup`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary messagedlg
proc `ntheme`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `opacity=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(value))

proc `opacity`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(value))

proc `opacity=`*(ih: MessageDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(&"{x}"))

proc `opacity`*(ih: MessageDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(&"{x}"))

proc `opacity`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("OPACITY"))

proc `opacityimage=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITYIMAGE"), cstring(value))

proc `opacityimage`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITYIMAGE"), cstring(value))

# TODO ??? String Binary messagedlg
proc `opacityimage`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("OPACITYIMAGE"))

# TODO unknown: messagedlg PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: messagedlg PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `parentdialog=`*(ih: MessageDlg_t, handle: IUPhandle_t) {.cdecl.} =
    # PARENTDIALOG (creation only): Name of a dialog to be used as
    # parent. This dialog will be always in front of the parent
    # dialog. If not defined in Motif the dialog could not be modal.
    # In Windows, if PARENTDIALOG is specified then it will be modal
    # relative only to its parent.
    SetAttributeHandle(cast[PIhandle](ih), cstring("PARENTDIALOG"), cast[PIhandle](handle))

proc `parentdialog`*(ih: MessageDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("PARENTDIALOG"), cast[PIhandle](handle))

proc `parentdialog`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PARENTDIALOG"))

proc `placement=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PLACEMENT"), cstring(value))

proc `placement`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PLACEMENT"), cstring(value))

proc `placement`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PLACEMENT"))

proc `position=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: MessageDlg_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: MessageDlg_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: MessageDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: MessageDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `resize=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(value))

proc `resize`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(value))

proc `resize=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring((if yes: "YES" else: "NO")))

proc `resize`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring((if yes: "YES" else: "NO")))

proc `resize`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RESIZE")) == "YES"

proc `saveunder=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring(value))

proc `saveunder`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring(value))

proc `saveunder=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring((if yes: "YES" else: "NO")))

proc `saveunder`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring((if yes: "YES" else: "NO")))

proc `saveunder`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER")) == "YES"

proc `screenposition`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `shapeimage=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHAPEIMAGE"), cstring(value))

proc `shapeimage`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHAPEIMAGE"), cstring(value))

# TODO ??? String Binary messagedlg
proc `shapeimage`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHAPEIMAGE"))

proc `shownofocus=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring(value))

proc `shownofocus`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring(value))

proc `shownofocus=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `shownofocus`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `shownofocus`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS")) == "YES"

proc `shrink=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring(value))

proc `shrink`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring(value))

proc `shrink=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring((if yes: "YES" else: "NO")))

proc `shrink`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring((if yes: "YES" else: "NO")))

proc `shrink`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHRINK")) == "YES"

proc `simulatemodal=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring(value))

proc `simulatemodal`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring(value))

proc `simulatemodal=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring((if yes: "YES" else: "NO")))

proc `simulatemodal`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring((if yes: "YES" else: "NO")))

proc `size=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: MessageDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: MessageDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size=`*(ih: MessageDlg_t, width: string, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: MessageDlg_t, width: string, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size=`*(ih: MessageDlg_t, width: int, height:string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: MessageDlg_t, width: int, height:string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `startfocus=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STARTFOCUS"), cstring(value))

proc `startfocus`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STARTFOCUS"), cstring(value))

# TODO ??? String Binary messagedlg
proc `startfocus`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("STARTFOCUS"))

proc `theme=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary messagedlg
proc `theme`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary messagedlg
proc `tip`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: MessageDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: MessageDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: MessageDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: MessageDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: MessageDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: MessageDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary messagedlg
proc `tipicon`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary messagedlg
proc `tipmarkup`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: MessageDlg_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: MessageDlg_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `title=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    # TITLE: Dialog title.
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary messagedlg
proc `title`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

proc `toolbox=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring(value))

proc `toolbox`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring(value))

proc `toolbox=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring((if yes: "YES" else: "NO")))

proc `toolbox`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring((if yes: "YES" else: "NO")))

proc `toolbox`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOOLBOX")) == "YES"

proc `topmost=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring(value))

proc `topmost`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring(value))

proc `topmost=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring((if yes: "YES" else: "NO")))

proc `topmost`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring((if yes: "YES" else: "NO")))

proc `tray=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring(value))

proc `tray`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring(value))

proc `tray=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring((if yes: "YES" else: "NO")))

proc `tray`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring((if yes: "YES" else: "NO")))

proc `tray`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAY")) == "YES"

proc `trayimage=`*(ih: MessageDlg_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("TRAYIMAGE"), cast[PIhandle](handle))

proc `trayimage`*(ih: MessageDlg_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("TRAYIMAGE"), cast[PIhandle](handle))

proc `trayimage`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAYIMAGE"))

proc `traytip=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIP"), cstring(value))

proc `traytip`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIP"), cstring(value))

# TODO ??? String Binary messagedlg
proc `traytip`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAYTIP"))

proc `traytipmarkup=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIPMARKUP"), cstring(value))

proc `traytipmarkup`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIPMARKUP"), cstring(value))

# TODO ??? String Binary messagedlg
proc `traytipmarkup`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAYTIPMARKUP"))

proc `usersize=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: MessageDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: MessageDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    # VALUE: Message text.
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

# TODO ??? String Binary messagedlg
proc `value`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `visible=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: MessageDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: MessageDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

# TODO unknown: messagedlg XFONTID Unknown Binary
proc `xfontid`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

# TODO unknown: messagedlg XWINDOW Unknown Binary
proc `xwindow`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: MessageDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `zorder=`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: MessageDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `close_cb=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # CLOSE_CB CLOSE_CB Called just before a dialog is closed when the
    # user clicks the close button of the title bar or an equivalent
    # action. Callback int function(Ihandle *ih); [in C] ih:close_cb()
    # -> (ret: number) [in Lua] ih: identifies the element that
    # activated the event. Returns: if IUP_IGNORE, it prevents the
    # dialog from being closed. If you destroy the dialog in this
    # callback, you must return IUP_IGNORE. IUP_CLOSE will be
    # processed. Affects IupDialog
    SetCallback(cast[PIhandle](ih), cstring("CLOSE_CB"), cast[Icallback](cb))

proc `close_cb`*(ih: MessageDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("CLOSE_CB"), cast[Icallback](cb))

proc `close_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("CLOSE_CB")))

proc `destroy_cb=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: MessageDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: MessageDlg_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: MessageDlg_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: MessageDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `focus_cb=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: MessageDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: MessageDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `killfocus_cb=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: MessageDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: MessageDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: MessageDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: MessageDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `show_cb=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, state: cint): cint {.cdecl.}) {.cdecl.} =
    # SHOW_CB SHOW_CB Called right after the dialog is showed, hidden,
    # maximized, minimized or restored from minimized/maximized. This
    # callback is called when those actions were performed by the user
    # or programmatically by the application. Callback int
    # function(Ihandle *ih, int state); [in C] ih:show_cb(state:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. state: indicates which of the
    # following situations generated the event: IUP_HIDE (since 3.0)
    # IUP_SHOW IUP_RESTORE (was minimized or maximized) IUP_MINIMIZE
    # IUP_MAXIMIZE (since 3.0) (not received in Motif when activated
    # from the maximize button) Returns: IUP_CLOSE will be processed.
    # Affects IupDialog
    SetCallback(cast[PIhandle](ih), cstring("SHOW_CB"), cast[Icallback](cb))

proc `show_cb`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, state: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SHOW_CB"), cast[Icallback](cb))

proc `show_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SHOW_CB")))

proc `trayclick_cb=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, but, pressed, dclick: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("TRAYCLICK_CB"), cast[Icallback](cb))

proc `trayclick_cb`*(ih: MessageDlg_t, cb: proc (ih: PIhandle, but, pressed, dclick: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("TRAYCLICK_CB"), cast[Icallback](cb))

proc `trayclick_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("TRAYCLICK_CB")))

proc `unmap_cb=`*(ih: MessageDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: MessageDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: MessageDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

macro MultiBox*(args: varargs[untyped]): MultiBox_t =
    # Creates a void container for composing elements in a irregular
    # grid. It is a box that arranges the elements it contains from
    # top to bottom and from left to right, by distributing the
    # elements in lines or in columns. But its EXPAND attribute does
    # not behave as a regular container, instead it behaves as a
    # regular element expanding into the available space. The child
    # elements are added to the control just like a vbox and hbox,
    # sequentially. Then they are distributed accordingly the
    # ORIENTATION attribute. When ORIENTATION=HORIZONTAL children are
    # distributed from left to right on the first line until the line
    # does not fits more elements according to the multibox current
    # width, then on the second line, and so on. When
    # ORIENTATION=VERTICAL children are distributed from top to bottom
    # on the first column until columns does not fits more elements
    # according to the multibox current height, then on the second
    # column, and so on. Because of that its elements can overlap
    # other elements in the dialog, so the ideal combination is to put
    # the IupMultiBox inside an IupScrollBox. IMPORTANT: the actual
    # element distribution in the container is done only after the
    # natural size of the dialog is computed because it needs the
    # current with or height to determine which elements will fit in
    # the current space according to the orientation. The first time
    # the multibox natural size is computed it returns simply the
    # largest width and the highest height among the children. The
    # next time it will use the size previously calculated with the
    # line/column breaks, to avoid obtaining an outdated layout call
    # IupRefresh or IupMap before showing the dialog (when the layout
    # will be updated again). It does not have a native
    # representation.


    result = nnkCall.newTree(
        nnkDotExpr.newTree(
            newIdentNode("niup"),
            newIdentNode("MultiBox_t")
          ),
       )
    let inner = nnkCall.newTree(
            newIdentNode("MultiBox")
          )

    if args.len > 0:
        for i in 0 ..< args.len:
          inner.add nnkCast.newTree(newIdentNode("PIhandle"), args[i])
    inner.add newNilLit()
    result.add inner


proc `active=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: MultiBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: MultiBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: MultiBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `canfocus=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: MultiBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: MultiBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: MultiBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

# TODO unknown: multibox CGAPHORIZ Unknown Binary
proc `cgaphoriz`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CGAPHORIZ"))

# TODO unknown: multibox CGAPVERT Unknown Binary
proc `cgapvert`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CGAPVERT"))

proc `charsize`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

# TODO unknown: multibox CHILDMAXSIZE Unknown Binary
proc `childmaxsize`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHILDMAXSIZE"))

# TODO unknown: multibox CHILDMINSPACE Unknown Binary
proc `childminspace`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHILDMINSPACE"))

proc `clientoffset`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `cmargin=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    # MARGIN, CMARGIN: Defines a margin in pixels, CMARGIN is in the
    # same units of the SIZE attribute. Its value has the format
    # "widthxheight", where width and height are integer values
    # corresponding to the horizontal and vertical margins,
    # respectively. Default: "0x0" (no margin).
    SetAttribute(cast[PIhandle](ih), cstring("CMARGIN"), cstring(value))

proc `cmargin`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CMARGIN"), cstring(value))

proc `cmargin=`*(ih: MultiBox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CMARGIN"), cstring(&"{horiz}x{vert}"))

proc `cmargin`*(ih: MultiBox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CMARGIN"), cstring(&"{horiz}x{vert}"))

proc `cmargin`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CMARGIN"))

proc `expand=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable*): The default value is "YES". See the
    # documentation of the attribute for EXPAND inheritance.
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: MultiBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: MultiBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary multibox
proc `font`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary multibox
proc `fontface`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: MultiBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: MultiBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary multibox
proc `fontstyle`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

# TODO unknown: multibox GAPHORIZ Unknown Binary
proc `gaphoriz`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("GAPHORIZ"))

# TODO unknown: multibox GAPVERT Unknown Binary
proc `gapvert`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("GAPVERT"))

proc `handlename=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary multibox
proc `handlename`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `margin=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    # MARGIN, CMARGIN: Defines a margin in pixels, CMARGIN is in the
    # same units of the SIZE attribute. Its value has the format
    # "widthxheight", where width and height are integer values
    # corresponding to the horizontal and vertical margins,
    # respectively. Default: "0x0" (no margin).
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(value))

proc `margin`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(value))

proc `margin=`*(ih: MultiBox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(&"{horiz}x{vert}"))

proc `margin`*(ih: MultiBox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(&"{horiz}x{vert}"))

proc `margin`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MARGIN"))

proc `maxsize=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: MultiBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: MultiBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: MultiBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: MultiBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary multibox
proc `name`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

# TODO unknown: multibox NCGAPHORIZ Unknown Binary
proc `ncgaphoriz`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NCGAPHORIZ"))

# TODO unknown: multibox NCGAPVERT Unknown Binary
proc `ncgapvert`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NCGAPVERT"))

proc `ncmargin=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    # NMARGIN, NCMARGIN (non inheritable): Same as MARGIN but are non
    # inheritable.
    SetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"), cstring(value))

proc `ncmargin`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"), cstring(value))

proc `ncmargin=`*(ih: MultiBox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"), cstring(&"{horiz}x{vert}"))

proc `ncmargin`*(ih: MultiBox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"), cstring(&"{horiz}x{vert}"))

proc `ncmargin`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"))

# TODO unknown: multibox NGAPHORIZ Unknown Binary
proc `ngaphoriz`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NGAPHORIZ"))

# TODO unknown: multibox NGAPVERT Unknown Binary
proc `ngapvert`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NGAPVERT"))

proc `nmargin=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    # NMARGIN, NCMARGIN (non inheritable): Same as MARGIN but are non
    # inheritable.
    SetAttribute(cast[PIhandle](ih), cstring("NMARGIN"), cstring(value))

proc `nmargin`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NMARGIN"), cstring(value))

proc `nmargin=`*(ih: MultiBox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NMARGIN"), cstring(&"{horiz}x{vert}"))

proc `nmargin`*(ih: MultiBox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NMARGIN"), cstring(&"{horiz}x{vert}"))

proc `nmargin`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NMARGIN"))

proc `normalizergroup=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary multibox
proc `normalizergroup`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary multibox
proc `ntheme`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `numcol`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NUMCOL"))

proc `numlin`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NUMLIN"))

proc `orientation=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    # ORIENTATION (non inheritable): controls the distribution of the
    # children in lines or in columns. Can be: HORIZONTAL or VERTICAL.
    # Default: HORIZONTAL.
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"))

# TODO unknown: multibox PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: multibox PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: MultiBox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: MultiBox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: MultiBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: MultiBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: MultiBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: MultiBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: MultiBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `size=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    # SIZE, RASTERSIZE, FONT, CLIENTSIZE, CLIENTOFFSET, POSITION,
    # MINSIZE, MAXSIZE, THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: MultiBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: MultiBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary multibox
proc `theme`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `usersize=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: MultiBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: MultiBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: MultiBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: MultiBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: MultiBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: MultiBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

# TODO unknown: multibox XFONTID Unknown Binary
proc `xfontid`*(ih: MultiBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `destroy_cb=`*(ih: MultiBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: MultiBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: MultiBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `ldestroy_cb=`*(ih: MultiBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: MultiBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: MultiBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: MultiBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: MultiBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: MultiBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: MultiBox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: MultiBox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: MultiBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: MultiBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: MultiBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: MultiBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `updateattribfromfont_cb=`*(ih: MultiBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UPDATEATTRIBFROMFONT_CB"), cast[Icallback](cb))

proc `updateattribfromfont_cb`*(ih: MultiBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UPDATEATTRIBFROMFONT_CB"), cast[Icallback](cb))

proc `updateattribfromfont_cb`*(ih: MultiBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UPDATEATTRIBFROMFONT_CB")))

proc MultiLine*(action: string): MultiLine_t {.cdecl.} =
    # Creates an editable field with one or more lines. Since IUP 3.0,
    # IupText has support for multiple lines when the MULTILINE
    # attribute is set to YES. Now when a IupMultiline element is
    # created in fact a IupText element with MULTILINE=YES is created.
    # See IupText
    return MultiLine_t(niupc.MultiLine(cstring(action)))

proc MultiLine*(): MultiLine_t {.cdecl.} =
    # Creates an editable field with one or more lines. Since IUP 3.0,
    # IupText has support for multiple lines when the MULTILINE
    # attribute is set to YES. Now when a IupMultiline element is
    # created in fact a IupText element with MULTILINE=YES is created.
    # See IupText
    return MultiLine_t(niupc.MultiLine(nil))

proc `active=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `addformattag=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ADDFORMATTAG"), cstring(value))

proc `addformattag`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ADDFORMATTAG"), cstring(value))

# TODO ??? String Binary multiline
proc `addformattag`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ADDFORMATTAG"))

proc `addformattag_handle=`*(ih: MultiLine_t, handle: User_t) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ADDFORMATTAG_HANDLE"), cstring(cast[cstring](handle)))

proc `addformattag_handle`*(ih: MultiLine_t, handle: User_t) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ADDFORMATTAG_HANDLE"), cstring(cast[cstring](handle)))

proc `addformattag_handle`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ADDFORMATTAG_HANDLE"))

proc `alignment=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"))

proc `append=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("APPEND"), cstring(value))

proc `append`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("APPEND"), cstring(value))

# TODO ??? String Binary multiline
proc `appendnewline=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("APPENDNEWLINE"), cstring(value))

proc `appendnewline`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("APPENDNEWLINE"), cstring(value))

proc `appendnewline=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("APPENDNEWLINE"), cstring((if yes: "YES" else: "NO")))

proc `appendnewline`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("APPENDNEWLINE"), cstring((if yes: "YES" else: "NO")))

proc `appendnewline`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("APPENDNEWLINE")) == "YES"

proc `autohide=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOHIDE"), cstring(value))

proc `autohide`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOHIDE"), cstring(value))

proc `autohide=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `autohide`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `autohide`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("AUTOHIDE")) == "YES"

proc `bgcolor=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: MultiLine_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: MultiLine_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `canfocus=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `caret=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CARET"), cstring(value))

proc `caret`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CARET"), cstring(value))

proc `caret=`*(ih: MultiLine_t, lin, col:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CARET"), cstring(&"{lin},{col}"))

proc `caret`*(ih: MultiLine_t, lin, col:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CARET"), cstring(&"{lin},{col}"))

proc `caret`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CARET"))

proc `caretpos=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CARETPOS"), cstring(value))

proc `caretpos`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CARETPOS"), cstring(value))

proc `caretpos=`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CARETPOS"), cstring(&"{x}"))

proc `caretpos`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CARETPOS"), cstring(&"{x}"))

proc `caretpos`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CARETPOS"))

proc `changecase=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHANGECASE"), cstring(value))

proc `changecase`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHANGECASE"), cstring(value))

proc `charsize`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `clipboard=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIPBOARD"), cstring(value))

proc `clipboard`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIPBOARD"), cstring(value))

proc `clipboard`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIPBOARD"))

proc `count`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("COUNT"))

proc `cpadding=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding=`*(ih: MultiLine_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: MultiLine_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CPADDING"))

proc `cuebanner=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUEBANNER"), cstring(value))

proc `cuebanner`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUEBANNER"), cstring(value))

# TODO ??? String Binary multiline
proc `cuebanner`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CUEBANNER"))

proc `dragdrop=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary multiline
proc `dragtypes`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

proc `dropfilestarget=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary multiline
proc `droptypes`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `expand=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: MultiLine_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: MultiLine_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `fgcolor=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: MultiLine_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: MultiLine_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

proc `filter=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FILTER"), cstring(value))

proc `filter`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FILTER"), cstring(value))

proc `filter`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FILTER"))

proc `floating=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary multiline
proc `font`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary multiline
proc `fontface`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary multiline
proc `fontstyle`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `formatting=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FORMATTING"), cstring(value))

proc `formatting`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FORMATTING"), cstring(value))

proc `formatting=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FORMATTING"), cstring((if yes: "YES" else: "NO")))

proc `formatting`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FORMATTING"), cstring((if yes: "YES" else: "NO")))

proc `formatting`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FORMATTING")) == "YES"

proc `handlename=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary multiline
proc `handlename`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

# TODO unknown: multiline INSERT Unknown Binary
proc `linecount`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINECOUNT"))

proc `linevalue`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEVALUE"))

proc `mask=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASK"), cstring(value))

proc `mask`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASK"), cstring(value))

# TODO ??? String Binary multiline
proc `mask`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASK"))

proc `maskcasei=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKCASEI"), cstring(value))

proc `maskcasei`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKCASEI"), cstring(value))

proc `maskcasei=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKCASEI"), cstring((if yes: "YES" else: "NO")))

proc `maskcasei`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKCASEI"), cstring((if yes: "YES" else: "NO")))

proc `maskcasei`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASKCASEI")) == "YES"

proc `maskdecimalsymbol=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKDECIMALSYMBOL"), cstring(value))

proc `maskdecimalsymbol`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKDECIMALSYMBOL"), cstring(value))

# TODO ??? String Binary multiline
proc `maskdecimalsymbol`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASKDECIMALSYMBOL"))

proc `maskfloat=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKFLOAT"), cstring(value))

proc `maskfloat`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKFLOAT"), cstring(value))

proc `maskfloat=`*(ih: MultiLine_t, min, max:float) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKFLOAT"), cstring(&"{min},{max}"))

proc `maskfloat`*(ih: MultiLine_t, min, max:float) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKFLOAT"), cstring(&"{min},{max}"))

proc `maskfloat`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASKFLOAT"))

proc `maskint=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKINT"), cstring(value))

proc `maskint`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKINT"), cstring(value))

proc `maskint=`*(ih: MultiLine_t, min, max:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKINT"), cstring(&"{min},{max}"))

proc `maskint`*(ih: MultiLine_t, min, max:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKINT"), cstring(&"{min},{max}"))

proc `maskint`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASKINT"))

proc `masknoempty=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKNOEMPTY"), cstring(value))

proc `masknoempty`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKNOEMPTY"), cstring(value))

proc `masknoempty=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKNOEMPTY"), cstring((if yes: "YES" else: "NO")))

proc `masknoempty`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKNOEMPTY"), cstring((if yes: "YES" else: "NO")))

proc `masknoempty`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASKNOEMPTY")) == "YES"

proc `maskreal=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKREAL"), cstring(value))

proc `maskreal`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKREAL"), cstring(value))

proc `maskreal`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASKREAL"))

proc `maxsize=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: MultiLine_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: MultiLine_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: MultiLine_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: MultiLine_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `multiline=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MULTILINE"), cstring(value))

proc `multiline`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MULTILINE"), cstring(value))

proc `multiline=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MULTILINE"), cstring((if yes: "YES" else: "NO")))

proc `multiline`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MULTILINE"), cstring((if yes: "YES" else: "NO")))

proc `multiline`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MULTILINE")) == "YES"

proc `name=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary multiline
proc `name`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `nc=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NC"), cstring(value))

proc `nc`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NC"), cstring(value))

proc `nc=`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NC"), cstring(&"{x}"))

proc `nc`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NC"), cstring(&"{x}"))

proc `nc`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NC"))

proc `normalizergroup=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary multiline
proc `normalizergroup`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary multiline
proc `ntheme`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `overwrite=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OVERWRITE"), cstring(value))

proc `overwrite`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OVERWRITE"), cstring(value))

proc `overwrite=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OVERWRITE"), cstring((if yes: "YES" else: "NO")))

proc `overwrite`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OVERWRITE"), cstring((if yes: "YES" else: "NO")))

proc `overwrite`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("OVERWRITE")) == "YES"

proc `padding=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding=`*(ih: MultiLine_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: MultiLine_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PADDING"))

# TODO unknown: multiline PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: multiline PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `password=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PASSWORD"), cstring(value))

proc `password`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PASSWORD"), cstring(value))

proc `password=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PASSWORD"), cstring((if yes: "YES" else: "NO")))

proc `password`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PASSWORD"), cstring((if yes: "YES" else: "NO")))

proc `password`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PASSWORD")) == "YES"

proc `position=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: MultiLine_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: MultiLine_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: MultiLine_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: MultiLine_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `readonly=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("READONLY"), cstring(value))

proc `readonly`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("READONLY"), cstring(value))

proc `readonly=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("READONLY"), cstring((if yes: "YES" else: "NO")))

proc `readonly`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("READONLY"), cstring((if yes: "YES" else: "NO")))

proc `readonly`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("READONLY")) == "YES"

proc `removeformatting=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("REMOVEFORMATTING"), cstring(value))

proc `removeformatting`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("REMOVEFORMATTING"), cstring(value))

proc `screenposition`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `scrollbar=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR")) == "YES"

proc `scrollto=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTO"), cstring(value))

proc `scrollto`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTO"), cstring(value))

proc `scrollto=`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTO"), cstring(&"{x}"))

proc `scrollto`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTO"), cstring(&"{x}"))

proc `scrolltopos=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTOPOS"), cstring(value))

proc `scrolltopos`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTOPOS"), cstring(value))

proc `scrolltopos=`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTOPOS"), cstring(&"{x}"))

proc `scrolltopos`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTOPOS"), cstring(&"{x}"))

proc `selectedtext=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTEDTEXT"), cstring(value))

proc `selectedtext`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTEDTEXT"), cstring(value))

# TODO ??? String Binary multiline
proc `selectedtext`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SELECTEDTEXT"))

proc `selection=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTION"), cstring(value))

proc `selection`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTION"), cstring(value))

proc `selection=`*(ih: MultiLine_t, lin1,col1,lin2,col2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTION"), cstring(&"{lin1},{col1}:{lin2},{col2}"))

proc `selection`*(ih: MultiLine_t, lin1,col1,lin2,col2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTION"), cstring(&"{lin1},{col1}:{lin2},{col2}"))

proc `selection=`*(ih: MultiLine_t, col1,col2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTION"), cstring(&"{col1}:{col2}"))

proc `selection`*(ih: MultiLine_t, col1,col2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTION"), cstring(&"{col1}:{col2}"))

proc `selection`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SELECTION"))

proc `selectionpos=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTIONPOS"), cstring(value))

proc `selectionpos`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTIONPOS"), cstring(value))

proc `selectionpos=`*(ih: MultiLine_t, min, max:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTIONPOS"), cstring(&"{min},{max}"))

proc `selectionpos`*(ih: MultiLine_t, min, max:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTIONPOS"), cstring(&"{min},{max}"))

proc `selectionpos`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SELECTIONPOS"))

proc `size=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: MultiLine_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: MultiLine_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `spin=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPIN"), cstring(value))

proc `spin`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPIN"), cstring(value))

proc `spin=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPIN"), cstring((if yes: "YES" else: "NO")))

proc `spin`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPIN"), cstring((if yes: "YES" else: "NO")))

proc `spin`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPIN")) == "YES"

proc `spinalign=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINALIGN"), cstring(value))

proc `spinalign`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINALIGN"), cstring(value))

proc `spinalign`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPINALIGN"))

proc `spinauto=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINAUTO"), cstring(value))

proc `spinauto`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINAUTO"), cstring(value))

proc `spinauto=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINAUTO"), cstring((if yes: "YES" else: "NO")))

proc `spinauto`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINAUTO"), cstring((if yes: "YES" else: "NO")))

proc `spinauto`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPINAUTO")) == "YES"

proc `spininc=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPININC"), cstring(value))

proc `spininc`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPININC"), cstring(value))

proc `spininc=`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPININC"), cstring(&"{x}"))

proc `spininc`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPININC"), cstring(&"{x}"))

proc `spininc`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPININC"))

proc `spinmax=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINMAX"), cstring(value))

proc `spinmax`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINMAX"), cstring(value))

proc `spinmax=`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINMAX"), cstring(&"{x}"))

proc `spinmax`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINMAX"), cstring(&"{x}"))

proc `spinmax`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPINMAX"))

proc `spinmin=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINMIN"), cstring(value))

proc `spinmin`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINMIN"), cstring(value))

proc `spinmin=`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINMIN"), cstring(&"{x}"))

proc `spinmin`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINMIN"), cstring(&"{x}"))

proc `spinmin`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPINMIN"))

proc `spinvalue=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINVALUE"), cstring(value))

proc `spinvalue`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINVALUE"), cstring(value))

proc `spinvalue=`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINVALUE"), cstring(&"{x}"))

proc `spinvalue`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINVALUE"), cstring(&"{x}"))

proc `spinvalue`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPINVALUE"))

proc `spinwrap=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINWRAP"), cstring(value))

proc `spinwrap`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINWRAP"), cstring(value))

proc `spinwrap=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINWRAP"), cstring((if yes: "YES" else: "NO")))

proc `spinwrap`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINWRAP"), cstring((if yes: "YES" else: "NO")))

proc `spinwrap`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPINWRAP")) == "YES"

proc `tabsize=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TABSIZE"), cstring(value))

proc `tabsize`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TABSIZE"), cstring(value))

proc `tabsize=`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TABSIZE"), cstring(&"{x}"))

proc `tabsize`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TABSIZE"), cstring(&"{x}"))

proc `tabsize`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABSIZE"))

proc `theme=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary multiline
proc `theme`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary multiline
proc `tip`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: MultiLine_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: MultiLine_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: MultiLine_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: MultiLine_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary multiline
proc `tipicon`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary multiline
proc `tipmarkup`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: MultiLine_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: MultiLine_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `usersize=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: MultiLine_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: MultiLine_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

# TODO ??? String Binary multiline
proc `value`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `valuemasked=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUEMASKED"), cstring(value))

proc `valuemasked`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUEMASKED"), cstring(value))

# TODO ??? String Binary multiline
proc `visible=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `visiblecolumns=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"), cstring(value))

proc `visiblecolumns`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"), cstring(value))

proc `visiblecolumns=`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"), cstring(&"{x}"))

proc `visiblecolumns`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"), cstring(&"{x}"))

proc `visiblecolumns`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"))

proc `visiblelines=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLELINES"), cstring(value))

proc `visiblelines`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLELINES"), cstring(value))

proc `visiblelines=`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLELINES"), cstring(&"{x}"))

proc `visiblelines`*(ih: MultiLine_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLELINES"), cstring(&"{x}"))

proc `visiblelines`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLELINES"))

proc `wid`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `wordwrap=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WORDWRAP"), cstring(value))

proc `wordwrap`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WORDWRAP"), cstring(value))

proc `wordwrap=`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WORDWRAP"), cstring((if yes: "YES" else: "NO")))

proc `wordwrap`*(ih: MultiLine_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WORDWRAP"), cstring((if yes: "YES" else: "NO")))

proc `wordwrap`*(ih: MultiLine_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WORDWRAP")) == "YES"

proc `x`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

# TODO unknown: multiline XFONTID Unknown Binary
proc `xfontid`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `y`*(ih: MultiLine_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `zorder=`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: MultiLine_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: MultiLine_t, cb: proc (ih: PIhandle, c: cint, new_value: cstring): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: MultiLine_t, cb: proc (ih: PIhandle, c: cint, new_value: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: MultiLine_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: MultiLine_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `caret_cb=`*(ih: MultiLine_t, cb: proc (ih: PIhandle, lin, col,  pos: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("CARET_CB"), cast[Icallback](cb))

proc `caret_cb`*(ih: MultiLine_t, cb: proc (ih: PIhandle, lin, col,  pos: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("CARET_CB"), cast[Icallback](cb))

proc `caret_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("CARET_CB")))

proc `destroy_cb=`*(ih: MultiLine_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: MultiLine_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: MultiLine_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: MultiLine_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: MultiLine_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: MultiLine_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: MultiLine_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: MultiLine_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: MultiLine_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: MultiLine_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: MultiLine_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: MultiLine_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: MultiLine_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: MultiLine_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: MultiLine_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: MultiLine_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: MultiLine_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: MultiLine_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `getfocus_cb=`*(ih: MultiLine_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: MultiLine_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: MultiLine_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: MultiLine_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `killfocus_cb=`*(ih: MultiLine_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: MultiLine_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: MultiLine_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: MultiLine_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: MultiLine_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: MultiLine_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: MultiLine_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: MultiLine_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: MultiLine_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: MultiLine_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: MultiLine_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: MultiLine_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `postmessage_cb=`*(ih: MultiLine_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: MultiLine_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `spin_cb=`*(ih: MultiLine_t, cb: proc (ih: PIhandle, pos: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SPIN_CB"), cast[Icallback](cb))

proc `spin_cb`*(ih: MultiLine_t, cb: proc (ih: PIhandle, pos: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SPIN_CB"), cast[Icallback](cb))

proc `spin_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SPIN_CB")))

proc `unmap_cb=`*(ih: MultiLine_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: MultiLine_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `valuechanged_cb=`*(ih: MultiLine_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: MultiLine_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: MultiLine_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB")))

macro Normalizer*(args: varargs[untyped]): Normalizer_t =
    # Creates a void container that does not affect the dialog layout.
    # It acts by normalizing all the controls in a list so their
    # natural size becomes the biggest natural size amongst them. All
    # natural widths will be set to the biggest width, and all natural
    # heights will be set to the biggest height. The controls of the
    # list must be inside a valid container in the dialog.


    result = nnkCall.newTree(
        nnkDotExpr.newTree(
            newIdentNode("niup"),
            newIdentNode("Normalizer_t")
          ),
       )
    let inner = nnkCall.newTree(
            newIdentNode("Normalizer")
          )

    if args.len > 0:
        for i in 0 ..< args.len:
          inner.add nnkCast.newTree(newIdentNode("PIhandle"), args[i])
    inner.add newNilLit()
    result.add inner


# TODO unknown: normalizer ADDCONTROL Unknown Binary
proc `addcontrol_handle=`*(ih: Normalizer_t, handle: User_t) {.cdecl.} =
    # ADDCONTROL_HANDLE (non inheritable, write-only): Adds a control
    # to the normalizer. The value passed must be a handle of an
    # element.
    SetAttributeHandle(cast[PIhandle](ih), cstring("ADDCONTROL_HANDLE"), cast[PIhandle](handle))

proc `addcontrol_handle`*(ih: Normalizer_t, handle: User_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("ADDCONTROL_HANDLE"), cast[PIhandle](handle))

# TODO unknown: normalizer DELCONTROL Unknown Binary
proc `delcontrol_handle=`*(ih: Normalizer_t, handle: User_t) {.cdecl.} =
    # DELCONTROL_HANDLE (non inheritable, write-only): Removes a
    # control from the normalizer. The value passed must be a handle
    # of an element. (since 3.17)
    SetAttributeHandle(cast[PIhandle](ih), cstring("DELCONTROL_HANDLE"), cast[PIhandle](handle))

proc `delcontrol_handle`*(ih: Normalizer_t, handle: User_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DELCONTROL_HANDLE"), cast[PIhandle](handle))

proc `first_control_handle`*(ih: Normalizer_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FIRST_CONTROL_HANDLE"))

proc `next_control_handle`*(ih: Normalizer_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NEXT_CONTROL_HANDLE"))

# TODO unknown: normalizer NORMALIZE Unknown Binary
proc `normalize`*(ih: Normalizer_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZE"))

proc `destroy_cb=`*(ih: Normalizer_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Normalizer_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Normalizer_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `ldestroy_cb=`*(ih: Normalizer_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Normalizer_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Normalizer_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: Normalizer_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Normalizer_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Normalizer_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: Normalizer_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Normalizer_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Normalizer_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: Normalizer_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Normalizer_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Normalizer_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc Param*(format: string): Param_t {.cdecl.} =
    # Construction element used only in IupParamBox. It is not mapped
    # in the native system, but it will exist while its IupParamBox
    # container exists.
    return Param_t(niupc.Param(cstring(format)))

# TODO unknown: param ANGLE Unknown Binary
proc `angle`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ANGLE"))

# TODO unknown: param AUXCONTROL Unknown Binary
proc `auxcontrol`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("AUXCONTROL"))

proc `button1=`*(ih: Param_t, value: string) {.cdecl.} =
    # BUTTON1, BUTTON2, BUTTON3: button titles. Default is
    # "OK/Cancel/Help" for regular IupGetParam, and "Apply/Reset/Help"
    # when IupParamBox is directly used. For 'u' parameter.
    SetAttribute(cast[PIhandle](ih), cstring("BUTTON1"), cstring(value))

proc `button1`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BUTTON1"), cstring(value))

# TODO ??? String Binary param
proc `button1`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BUTTON1"))

proc `button2=`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BUTTON2"), cstring(value))

proc `button2`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BUTTON2"), cstring(value))

# TODO ??? String Binary param
proc `button2`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BUTTON2"))

proc `button3=`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BUTTON3"), cstring(value))

proc `button3`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BUTTON3"), cstring(value))

# TODO ??? String Binary param
proc `button3`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BUTTON3"))

# TODO unknown: param CONTROL Unknown Binary
proc `control`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CONTROL"))

# TODO unknown: param DATATYPE Unknown Binary
proc `datatype`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DATATYPE"))

proc `dialogtype=`*(ih: Param_t, value: string) {.cdecl.} =
    # DIALOGTYPE, FILTER, DIRECTORY, NOCHANGEDIR, NOOVERWRITEPROMPT:
    # used for the FILE parameter dialog. See IupFileDlg. For 'f'
    # parameter.
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGTYPE"), cstring(value))

proc `dialogtype`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGTYPE"), cstring(value))

proc `dialogtype`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DIALOGTYPE"))

proc `directory=`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIRECTORY"), cstring(value))

proc `directory`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIRECTORY"), cstring(value))

# TODO ??? String Binary param
proc `directory`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DIRECTORY"))

proc `filter=`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FILTER"), cstring(value))

proc `filter`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FILTER"), cstring(value))

# TODO ??? String Binary param
proc `filter`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FILTER"))

# TODO unknown: param INDENT Unknown Binary
proc `indent`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("INDENT"))

# TODO unknown: param INDEX Unknown Binary
proc `index`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("INDEX"))

# TODO unknown: param INTERVAL Unknown Binary
proc `interval`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("INTERVAL"))

# TODO unknown: param LABEL Unknown Binary
proc `label`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LABEL"))

proc `mask=`*(ih: Param_t, value: string) {.cdecl.} =
    # MASK: mask for the edit box input. For 's' and 'm' parameters.
    SetAttribute(cast[PIhandle](ih), cstring("MASK"), cstring(value))

proc `mask`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASK"), cstring(value))

# TODO ??? String Binary param
proc `mask`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASK"))

proc `max=`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAX"), cstring(value))

proc `max`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAX"), cstring(value))

proc `max=`*(ih: Param_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAX"), cstring(&"{x}"))

proc `max`*(ih: Param_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAX"), cstring(&"{x}"))

proc `max`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAX"))

proc `min=`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MIN"), cstring(value))

proc `min`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MIN"), cstring(value))

proc `min=`*(ih: Param_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MIN"), cstring(&"{x}"))

proc `min`*(ih: Param_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MIN"), cstring(&"{x}"))

proc `min`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MIN"))

proc `multiline=`*(ih: Param_t, value: string) {.cdecl.} =
    # MULTILINE: can be Yes or No. Defines if the edit box can have
    # more than one line. For 'm' parameter.
    SetAttribute(cast[PIhandle](ih), cstring("MULTILINE"), cstring(value))

proc `multiline`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MULTILINE"), cstring(value))

proc `multiline=`*(ih: Param_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MULTILINE"), cstring((if yes: "YES" else: "NO")))

proc `multiline`*(ih: Param_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MULTILINE"), cstring((if yes: "YES" else: "NO")))

proc `multiline`*(ih: Param_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MULTILINE")) == "YES"

proc `nochangedir=`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOCHANGEDIR"), cstring(value))

proc `nochangedir`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOCHANGEDIR"), cstring(value))

proc `nochangedir=`*(ih: Param_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOCHANGEDIR"), cstring((if yes: "YES" else: "NO")))

proc `nochangedir`*(ih: Param_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOCHANGEDIR"), cstring((if yes: "YES" else: "NO")))

proc `nochangedir`*(ih: Param_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NOCHANGEDIR")) == "YES"

# TODO unknown: param NOFRAME Unknown Binary
proc `noframe`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NOFRAME"))

proc `nooverwriteprompt=`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOOVERWRITEPROMPT"), cstring(value))

proc `nooverwriteprompt`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOOVERWRITEPROMPT"), cstring(value))

proc `nooverwriteprompt=`*(ih: Param_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOOVERWRITEPROMPT"), cstring((if yes: "YES" else: "NO")))

proc `nooverwriteprompt`*(ih: Param_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOOVERWRITEPROMPT"), cstring((if yes: "YES" else: "NO")))

proc `nooverwriteprompt`*(ih: Param_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NOOVERWRITEPROMPT")) == "YES"

# TODO unknown: param PARTIAL Unknown Binary
proc `partial`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PARTIAL"))

# TODO unknown: param PRECISION Unknown Binary
proc `precision`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PRECISION"))

proc `step=`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STEP"), cstring(value))

proc `step`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STEP"), cstring(value))

proc `step=`*(ih: Param_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STEP"), cstring(&"{x}"))

proc `step`*(ih: Param_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STEP"), cstring(&"{x}"))

proc `step`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("STEP"))

proc `tip=`*(ih: Param_t, value: string) {.cdecl.} =
    # TIP: text of the tip. For all parameters.
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary param
proc `tip`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `title=`*(ih: Param_t, value: string) {.cdecl.} =
    # TITLE: text of the parameter, used as label. For all parameters.
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary param
proc `title`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

proc `type=`*(ih: Param_t, value: string) {.cdecl.} =
    # TYPE: can be BOOLEAN ('b'), LIST ('l'), OPTIONS ('o'), REAL
    # ('A', 'a', 'R', 'r'), STRING ('m', 's'), INTEGER ('i'), DATE
    # ('d'), FILE ('f'), COLOR ('c'), SEPARATOR ('t'), BUTTONNAMES
    # ('u'), PARAMBOX ('x') and HANDLE ('h'). And describe the type of
    # the parameter. For all parameters.
    SetAttribute(cast[PIhandle](ih), cstring("TYPE"), cstring(value))

proc `type`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TYPE"), cstring(value))

# TODO ??? String Binary param
proc `type`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TYPE"))

proc `value=`*(ih: Param_t, value: string) {.cdecl.} =
    # VALUE - the value of the parameter. IupGetFloat and IupGetInt
    # can also be used. For the current parameter inside the callback
    # contains the new value that will be applied to the control, to
    # get the old value use the VALUE attribute for the CONTROL
    # returned Ihandle*.
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: Param_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

# TODO ??? String Binary param
proc `value`*(ih: Param_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `destroy_cb=`*(ih: Param_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Param_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Param_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `ldestroy_cb=`*(ih: Param_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Param_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Param_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: Param_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Param_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Param_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: Param_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Param_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Param_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: Param_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Param_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Param_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

macro ParamBox*(args: varargs[untyped]): ParamBox_t =
    # Creates a void container for composing elements created using a
    # list of IupParam elements. Each param is used to create several
    # lines of controls internally arranged in a vertical composition.
    # It does not have a native representation.


    result = nnkCall.newTree(
        nnkDotExpr.newTree(
            newIdentNode("niup"),
            newIdentNode("ParamBox_t")
          ),
       )
    let inner = nnkCall.newTree(
            newIdentNode("ParamBox")
          )

    if args.len > 0:
        for i in 0 ..< args.len:
          inner.add nnkCast.newTree(newIdentNode("PIhandle"), args[i])
    inner.add newNilLit()
    result.add inner


proc `active=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: ParamBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: ParamBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: ParamBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `button1=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    # BUTTON1, BUTTON2, BUTTON3 [read-only]: returns an IUP Ihandle*
    # of the respective button in the button box.
    SetAttribute(cast[PIhandle](ih), cstring("BUTTON1"), cstring(value))

proc `button1`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BUTTON1"), cstring(value))

# TODO ??? String Binary parambox
proc `button1`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BUTTON1"))

proc `button2=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BUTTON2"), cstring(value))

proc `button2`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BUTTON2"), cstring(value))

# TODO ??? String Binary parambox
proc `button2`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BUTTON2"))

proc `button3=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BUTTON3"), cstring(value))

proc `button3`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BUTTON3"), cstring(value))

# TODO ??? String Binary parambox
proc `button3`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BUTTON3"))

proc `canfocus=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: ParamBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: ParamBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: ParamBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `clientoffset`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `expand=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable*): The default value is "YES". See the
    # documentation of the attribute for EXPAND inheritance.
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: ParamBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: ParamBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    # FONT, CLIENTSIZE, CLIENTOFFSET, POSITION, MINSIZE, MAXSIZE,
    # THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary parambox
proc `font`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary parambox
proc `fontface`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: ParamBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: ParamBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary parambox
proc `fontstyle`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary parambox
proc `handlename`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

# TODO unknown: parambox LABELALIGN Unknown Binary
proc `labelalign`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LABELALIGN"))

proc `maxsize=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: ParamBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: ParamBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: ParamBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: ParamBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

# TODO unknown: parambox MODIFIABLE Unknown Binary
proc `modifiable`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MODIFIABLE"))

proc `name=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary parambox
proc `name`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary parambox
proc `normalizergroup`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary parambox
proc `ntheme`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: parambox PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: parambox PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

# TODO unknown: parambox PARAMCOUNT Unknown Binary
proc `paramcount`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PARAMCOUNT"))

proc `position=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: ParamBox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: ParamBox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: ParamBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: ParamBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: ParamBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: ParamBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: ParamBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `size=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: ParamBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: ParamBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `status`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("STATUS"))

proc `theme=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary parambox
proc `theme`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `userdata`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERDATA"))

proc `usersize=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: ParamBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: ParamBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: ParamBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: ParamBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: ParamBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: ParamBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

# TODO unknown: parambox XFONTID Unknown Binary
proc `xfontid`*(ih: ParamBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `destroy_cb=`*(ih: ParamBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: ParamBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: ParamBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `ldestroy_cb=`*(ih: ParamBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: ParamBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: ParamBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: ParamBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: ParamBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: ParamBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `param_cb=`*(ih: ParamBox_t, cb: proc (ih: PIhandle, arg2: cint, arg3: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("PARAM_CB"), cast[Icallback](cb))

proc `param_cb`*(ih: ParamBox_t, cb: proc (ih: PIhandle, arg2: cint, arg3: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("PARAM_CB"), cast[Icallback](cb))

proc `param_cb`*(ih: ParamBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("PARAM_CB")))

proc `postmessage_cb=`*(ih: ParamBox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: ParamBox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: ParamBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: ParamBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: ParamBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: ParamBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc ProgressBar*(): ProgressBar_t {.cdecl.} =
    # Creates a progress bar control. Shows a percent value that can
    # be updated to simulate a progression. It is similar of IupGauge,
    # but uses native controls internally. Also does not have support
    # for text inside the bar.
    return ProgressBar_t(niupc.ProgressBar())

proc `active=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    # ACTIVE, EXPAND, FONT, SCREENPOSITION, POSITION, MINSIZE,
    # MAXSIZE, WID, TIP, SIZE, ZORDER, VISIBLE, THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: ProgressBar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: ProgressBar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: ProgressBar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `bgcolor=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    # BGCOLOR [Windows Classic and Motif only]: controls the
    # background color. Default: the global attribute DLGBGCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: ProgressBar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: ProgressBar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `canfocus=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: ProgressBar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: ProgressBar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: ProgressBar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `dashed=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    # DASHED (creation only in Windows) [Windows and GTK only]:
    # Changes the style of the progress bar for a dashed pattern.
    # Default is "NO". In Windows it is not supported since Windows
    # Vista when using Visual Styles.
    SetAttribute(cast[PIhandle](ih), cstring("DASHED"), cstring(value))

proc `dashed`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DASHED"), cstring(value))

proc `dashed=`*(ih: ProgressBar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DASHED"), cstring((if yes: "YES" else: "NO")))

proc `dashed`*(ih: ProgressBar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DASHED"), cstring((if yes: "YES" else: "NO")))

proc `dashed`*(ih: ProgressBar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DASHED")) == "YES"

proc `expand=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: ProgressBar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: ProgressBar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `fgcolor=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    # FGCOLOR [Windows Classic and Motif only]: Controls the bar
    # color. Default: the global attribute DLGFGCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: ProgressBar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: ProgressBar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

proc `floating=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary progressbar
proc `font`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary progressbar
proc `fontface`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: ProgressBar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: ProgressBar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary progressbar
proc `fontstyle`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary progressbar
proc `handlename`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

# TODO unknown: progressbar MARQUEE Unknown Binary
proc `marquee`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MARQUEE"))

proc `max=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    # MAX (non inheritable): Contains the maximum value. Default is
    # "1". The control display is not updated, must set VALUE
    # attribute to update.
    SetAttribute(cast[PIhandle](ih), cstring("MAX"), cstring(value))

proc `max`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAX"), cstring(value))

proc `max=`*(ih: ProgressBar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAX"), cstring(&"{x}"))

proc `max`*(ih: ProgressBar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAX"), cstring(&"{x}"))

proc `max`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAX"))

proc `maxsize=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: ProgressBar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: ProgressBar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `min=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    # MIN (non inheritable): Contains the minimum value. Default is
    # "0". The control display is not updated, must set VALUE
    # attribute to update.
    SetAttribute(cast[PIhandle](ih), cstring("MIN"), cstring(value))

proc `min`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MIN"), cstring(value))

proc `min=`*(ih: ProgressBar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MIN"), cstring(&"{x}"))

proc `min`*(ih: ProgressBar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MIN"), cstring(&"{x}"))

proc `min`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MIN"))

proc `minsize=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: ProgressBar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: ProgressBar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary progressbar
proc `name`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary progressbar
proc `normalizergroup`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary progressbar
proc `ntheme`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `orientation=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    # ORIENTATION (creation only): can be "VERTICAL" or "HORIZONTAL".
    # Default: "HORIZONTAL". Horizontal goes from left to right, and
    # vertical from bottom to top.
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"))

# TODO unknown: progressbar PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: progressbar PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: ProgressBar_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: ProgressBar_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: ProgressBar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: ProgressBar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: ProgressBar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    # RASTERSIZE: The initial size is defined as "200x30". Set to NULL
    # to allow the use of smaller values in the layout computation.
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: ProgressBar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: ProgressBar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `screenposition`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `size=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: ProgressBar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: ProgressBar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary progressbar
proc `theme`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary progressbar
proc `tip`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: ProgressBar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: ProgressBar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: ProgressBar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: ProgressBar_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: ProgressBar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: ProgressBar_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary progressbar
proc `tipicon`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary progressbar
proc `tipmarkup`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: ProgressBar_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: ProgressBar_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: ProgressBar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: ProgressBar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: ProgressBar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `usersize=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: ProgressBar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: ProgressBar_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    # VALUE (non inheritable): Contains a number between "MIN" and
    # "MAX", controlling the current position.
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value=`*(ih: ProgressBar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(&"{x}"))

proc `value`*(ih: ProgressBar_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(&"{x}"))

proc `value`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `visible=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: ProgressBar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: ProgressBar_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: ProgressBar_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

# TODO unknown: progressbar XFONTID Unknown Binary
proc `xfontid`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `y`*(ih: ProgressBar_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `zorder=`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: ProgressBar_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `map_cb=`*(ih: ProgressBar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: ProgressBar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: ProgressBar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `unmap_cb=`*(ih: ProgressBar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: ProgressBar_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: ProgressBar_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc ProgressDlg*(): ProgressDlg_t {.cdecl.} =
    # Creates a progress dialog element. It is a predefined dialog for
    # displaying the progress of an operation. The dialog is meant to
    # be shown with the show functions IupShow or IupShowXY.
    return ProgressDlg_t(niupc.ProgressDlg())

proc `active=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `activewindow`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVEWINDOW")) == "YES"

proc `background=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(value))

proc `background`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(value))

proc `background=`*(ih: ProgressDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(&"{red} {green} {blue} {alpha}"))

proc `background`*(ih: ProgressDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"), cstring(&"{red} {green} {blue} {alpha}"))

proc `background`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKGROUND"))

proc `bgcolor=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: ProgressDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: ProgressDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `bordersize`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDERSIZE"))

proc `bringfront=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring(value))

proc `bringfront`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring(value))

proc `bringfront=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring((if yes: "YES" else: "NO")))

proc `bringfront`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT"), cstring((if yes: "YES" else: "NO")))

proc `bringfront`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BRINGFRONT")) == "YES"

proc `canfocus=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `childoffset=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset=`*(ih: ProgressDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: ProgressDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"))

proc `clientoffset`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(value))

proc `clientsize`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(value))

proc `clientsize=`*(ih: ProgressDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(&"{width}x{height}"))

proc `clientsize`*(ih: ProgressDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"), cstring(&"{width}x{height}"))

proc `clientsize`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `composited=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring(value))

proc `composited`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring(value))

proc `composited=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring((if yes: "YES" else: "NO")))

proc `composited`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COMPOSITED"), cstring((if yes: "YES" else: "NO")))

proc `composited`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("COMPOSITED")) == "YES"

proc `control=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring(value))

proc `control`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring(value))

proc `control=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring((if yes: "YES" else: "NO")))

proc `control`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CONTROL"), cstring((if yes: "YES" else: "NO")))

proc `control`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CONTROL")) == "YES"

proc `count=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    # COUNT: current count of iterations.
    SetAttribute(cast[PIhandle](ih), cstring("COUNT"), cstring(value))

proc `count`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COUNT"), cstring(value))

proc `count=`*(ih: ProgressDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COUNT"), cstring(&"{x}"))

proc `count`*(ih: ProgressDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COUNT"), cstring(&"{x}"))

proc `count`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("COUNT"))

proc `cursor=`*(ih: ProgressDlg_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: ProgressDlg_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `customframe=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring(value))

proc `customframe`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring(value))

proc `customframe=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring((if yes: "YES" else: "NO")))

proc `customframe`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME"), cstring((if yes: "YES" else: "NO")))

proc `customframe`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAME")) == "YES"

proc `customframesimulate=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring(value))

proc `customframesimulate`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring(value))

proc `customframesimulate=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring((if yes: "YES" else: "NO")))

proc `customframesimulate`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE"), cstring((if yes: "YES" else: "NO")))

proc `customframesimulate`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CUSTOMFRAMESIMULATE")) == "YES"

proc `defaultenter=`*(ih: ProgressDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTENTER"), cast[PIhandle](handle))

proc `defaultenter`*(ih: ProgressDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTENTER"), cast[PIhandle](handle))

proc `defaultenter`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DEFAULTENTER"))

proc `defaultesc=`*(ih: ProgressDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTESC"), cast[PIhandle](handle))

proc `defaultesc`*(ih: ProgressDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("DEFAULTESC"), cast[PIhandle](handle))

proc `defaultesc`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DEFAULTESC"))

# TODO unknown: progressdlg DESCRIPTION Unknown Binary
proc `description`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DESCRIPTION"))

proc `dialogframe=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring(value))

proc `dialogframe`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring(value))

proc `dialogframe=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring((if yes: "YES" else: "NO")))

proc `dialogframe`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME"), cstring((if yes: "YES" else: "NO")))

proc `dialogframe`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DIALOGFRAME")) == "YES"

proc `dialoghint=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring(value))

proc `dialoghint`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring(value))

proc `dialoghint=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring((if yes: "YES" else: "NO")))

proc `dialoghint`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT"), cstring((if yes: "YES" else: "NO")))

proc `dialoghint`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DIALOGHINT")) == "YES"

proc `dragdrop=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary progressdlg
proc `dragtypes`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

proc `dropfilestarget=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary progressdlg
proc `droptypes`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `expand=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: ProgressDlg_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: ProgressDlg_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary progressdlg
proc `font`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary progressdlg
proc `fontface`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: ProgressDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: ProgressDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary progressdlg
proc `fontstyle`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `fullscreen=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring(value))

proc `fullscreen`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring(value))

proc `fullscreen=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring((if yes: "YES" else: "NO")))

proc `fullscreen`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FULLSCREEN"), cstring((if yes: "YES" else: "NO")))

proc `handlename=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary progressdlg
proc `handlename`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `helpbutton=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring(value))

proc `helpbutton`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring(value))

proc `helpbutton=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring((if yes: "YES" else: "NO")))

proc `helpbutton`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON"), cstring((if yes: "YES" else: "NO")))

proc `helpbutton`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HELPBUTTON")) == "YES"

proc `hidetaskbar=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring(value))

proc `hidetaskbar`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring(value))

proc `hidetaskbar=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring((if yes: "YES" else: "NO")))

proc `hidetaskbar`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR"), cstring((if yes: "YES" else: "NO")))

proc `hidetaskbar`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIDETASKBAR")) == "YES"

proc `hidetitlebar=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETITLEBAR"), cstring(value))

proc `hidetitlebar`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDETITLEBAR"), cstring(value))

# TODO ??? String Binary progressdlg
proc `hidetitlebar`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIDETITLEBAR"))

proc `icon=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    # ICON: Dialogs icon.
    SetAttribute(cast[PIhandle](ih), cstring("ICON"), cstring(value))

proc `icon`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ICON"), cstring(value))

# TODO ??? String Binary progressdlg
proc `icon`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ICON"))

# TODO unknown: progressdlg INC Unknown Binary
proc `maxbox=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring(value))

proc `maxbox`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring(value))

proc `maxbox=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring((if yes: "YES" else: "NO")))

proc `maxbox`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXBOX"), cstring((if yes: "YES" else: "NO")))

proc `maxbox`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXBOX")) == "YES"

proc `maximized`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXIMIZED")) == "YES"

proc `maxsize=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: ProgressDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: ProgressDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `mdichild=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring(value))

proc `mdichild`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring(value))

proc `mdichild=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring((if yes: "YES" else: "NO")))

proc `mdichild`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICHILD"), cstring((if yes: "YES" else: "NO")))

proc `mdichild`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDICHILD")) == "YES"

proc `mdiclient=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring(value))

proc `mdiclient`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring(value))

proc `mdiclient=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring((if yes: "YES" else: "NO")))

proc `mdiclient`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDICLIENT"), cstring((if yes: "YES" else: "NO")))

proc `mdiclient`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDICLIENT")) == "YES"

proc `mdiframe=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring(value))

proc `mdiframe`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring(value))

proc `mdiframe=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring((if yes: "YES" else: "NO")))

proc `mdiframe`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MDIFRAME"), cstring((if yes: "YES" else: "NO")))

proc `mdiframe`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDIFRAME")) == "YES"

proc `mdimenu=`*(ih: ProgressDlg_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MDIMENU"), cast[PIhandle](handle))

proc `mdimenu`*(ih: ProgressDlg_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MDIMENU"), cast[PIhandle](handle))

proc `mdimenu`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MDIMENU"))

proc `menu=`*(ih: ProgressDlg_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MENU"), cast[PIhandle](handle))

proc `menu`*(ih: ProgressDlg_t, handle: Menu_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("MENU"), cast[PIhandle](handle))

proc `menu`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MENU"))

proc `menubox=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring(value))

proc `menubox`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring(value))

proc `menubox=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring((if yes: "YES" else: "NO")))

proc `menubox`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MENUBOX"), cstring((if yes: "YES" else: "NO")))

proc `menubox`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MENUBOX")) == "YES"

proc `minbox=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring(value))

proc `minbox`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring(value))

proc `minbox=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring((if yes: "YES" else: "NO")))

proc `minbox`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINBOX"), cstring((if yes: "YES" else: "NO")))

proc `minbox`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINBOX")) == "YES"

# TODO unknown: progressdlg MINCLOCK Unknown Binary
proc `minclock`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINCLOCK"))

# TODO unknown: progressdlg MINPERCENT Unknown Binary
proc `minpercent`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINPERCENT"))

proc `minsize=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: ProgressDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: ProgressDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `modal`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MODAL")) == "YES"

proc `nactive=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring(value))

proc `nactive`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring(value))

proc `nactive=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `nactive`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `nactive`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NACTIVE")) == "YES"

proc `name=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary progressdlg
proc `name`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `nativeparent=`*(ih: ProgressDlg_t, handle: User_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("NATIVEPARENT"), cast[PIhandle](handle))

proc `nativeparent`*(ih: ProgressDlg_t, handle: User_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("NATIVEPARENT"), cast[PIhandle](handle))

proc `nativeparent`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATIVEPARENT"))

proc `naturalsize`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `noflush=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring(value))

proc `noflush`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring(value))

proc `noflush=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring((if yes: "YES" else: "NO")))

proc `noflush`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NOFLUSH"), cstring((if yes: "YES" else: "NO")))

proc `noflush`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NOFLUSH")) == "YES"

proc `normalizergroup=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary progressdlg
proc `normalizergroup`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary progressdlg
proc `ntheme`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `opacity=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(value))

proc `opacity`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(value))

proc `opacity=`*(ih: ProgressDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(&"{x}"))

proc `opacity`*(ih: ProgressDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITY"), cstring(&"{x}"))

proc `opacity`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("OPACITY"))

proc `opacityimage=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITYIMAGE"), cstring(value))

proc `opacityimage`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OPACITYIMAGE"), cstring(value))

# TODO ??? String Binary progressdlg
proc `opacityimage`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("OPACITYIMAGE"))

# TODO unknown: progressdlg PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: progressdlg PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `parentdialog=`*(ih: ProgressDlg_t, handle: IUPhandle_t) {.cdecl.} =
    # PARENTDIALOG (creation only): Name of a dialog to be used as
    # parent. This dialog will be always in front of the parent
    # dialog.
    SetAttributeHandle(cast[PIhandle](ih), cstring("PARENTDIALOG"), cast[PIhandle](handle))

proc `parentdialog`*(ih: ProgressDlg_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("PARENTDIALOG"), cast[PIhandle](handle))

proc `parentdialog`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PARENTDIALOG"))

# TODO unknown: progressdlg PERCENT Unknown Binary
proc `percent`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PERCENT"))

proc `placement=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PLACEMENT"), cstring(value))

proc `placement`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PLACEMENT"), cstring(value))

proc `placement`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PLACEMENT"))

proc `position=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: ProgressDlg_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: ProgressDlg_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

# TODO unknown: progressdlg PROGRESSHEIGHT Unknown Binary
proc `progressheight`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROGRESSHEIGHT"))

proc `propagatefocus=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: ProgressDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: ProgressDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `resize=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    # RESIZE=NO, MAXBOX=NO, MINBOX=NO, MENUBOX=NO
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(value))

proc `resize`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring(value))

proc `resize=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring((if yes: "YES" else: "NO")))

proc `resize`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RESIZE"), cstring((if yes: "YES" else: "NO")))

proc `resize`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RESIZE")) == "YES"

proc `saveunder=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring(value))

proc `saveunder`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring(value))

proc `saveunder=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring((if yes: "YES" else: "NO")))

proc `saveunder`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER"), cstring((if yes: "YES" else: "NO")))

proc `saveunder`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SAVEUNDER")) == "YES"

proc `screenposition`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `shapeimage=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHAPEIMAGE"), cstring(value))

proc `shapeimage`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHAPEIMAGE"), cstring(value))

# TODO ??? String Binary progressdlg
proc `shapeimage`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHAPEIMAGE"))

proc `shownofocus=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring(value))

proc `shownofocus`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring(value))

proc `shownofocus=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `shownofocus`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `shownofocus`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWNOFOCUS")) == "YES"

proc `shrink=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring(value))

proc `shrink`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring(value))

proc `shrink=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring((if yes: "YES" else: "NO")))

proc `shrink`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHRINK"), cstring((if yes: "YES" else: "NO")))

proc `shrink`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHRINK")) == "YES"

proc `simulatemodal=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring(value))

proc `simulatemodal`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring(value))

proc `simulatemodal=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring((if yes: "YES" else: "NO")))

proc `simulatemodal`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIMULATEMODAL"), cstring((if yes: "YES" else: "NO")))

proc `size=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: ProgressDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: ProgressDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size=`*(ih: ProgressDlg_t, width: string, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: ProgressDlg_t, width: string, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size=`*(ih: ProgressDlg_t, width: int, height:string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: ProgressDlg_t, width: int, height:string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `startfocus=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STARTFOCUS"), cstring(value))

proc `startfocus`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STARTFOCUS"), cstring(value))

# TODO ??? String Binary progressdlg
proc `startfocus`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("STARTFOCUS"))

proc `state=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    # STATE: describe the state of the iteration. Can be: IDLE,
    # PROCESSING, UNDEFINED or ABORTED. Default is IDLE. When INC,
    # COUNT or PERCENT are set the state is changed to PROCESSING. If
    # the user pressed the Cancel button the state is changed to
    # ABORTED, but check the CANCEL_CB callback for other options. If
    # the state is set to UNDEFINED by the application the progress
    # bar will display an undefined state animation (same as setting
    # MARQUEE=Yes in IupProgressBar), to resume processing set the
    # state attribute to PROCESSING.
    SetAttribute(cast[PIhandle](ih), cstring("STATE"), cstring(value))

proc `state`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STATE"), cstring(value))

proc `state`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("STATE"))

proc `theme=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary progressdlg
proc `theme`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary progressdlg
proc `tip`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: ProgressDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: ProgressDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: ProgressDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: ProgressDlg_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: ProgressDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: ProgressDlg_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary progressdlg
proc `tipicon`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary progressdlg
proc `tipmarkup`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: ProgressDlg_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: ProgressDlg_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `title=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    # TITLE (non inheritable): Dialogs title. Default: NULL. If not
    # set the title bar will not be displayed and the dialog will
    # occupy less space on screen. TITLE: Dialog title.
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary progressdlg
proc `title`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

proc `toolbox=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring(value))

proc `toolbox`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring(value))

proc `toolbox=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring((if yes: "YES" else: "NO")))

proc `toolbox`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOOLBOX"), cstring((if yes: "YES" else: "NO")))

proc `toolbox`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOOLBOX")) == "YES"

proc `topmost=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring(value))

proc `topmost`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring(value))

proc `topmost=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring((if yes: "YES" else: "NO")))

proc `topmost`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPMOST"), cstring((if yes: "YES" else: "NO")))

# TODO unknown: progressdlg TOTALCOUNT Unknown Binary
proc `totalcount`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOTALCOUNT"))

proc `tray=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring(value))

proc `tray`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring(value))

proc `tray=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring((if yes: "YES" else: "NO")))

proc `tray`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAY"), cstring((if yes: "YES" else: "NO")))

proc `tray`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAY")) == "YES"

proc `trayimage=`*(ih: ProgressDlg_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("TRAYIMAGE"), cast[PIhandle](handle))

proc `trayimage`*(ih: ProgressDlg_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("TRAYIMAGE"), cast[PIhandle](handle))

proc `trayimage`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAYIMAGE"))

proc `traytip=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIP"), cstring(value))

proc `traytip`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIP"), cstring(value))

# TODO ??? String Binary progressdlg
proc `traytip`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAYTIP"))

proc `traytipmarkup=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIPMARKUP"), cstring(value))

proc `traytipmarkup`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TRAYTIPMARKUP"), cstring(value))

# TODO ??? String Binary progressdlg
proc `traytipmarkup`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TRAYTIPMARKUP"))

proc `usersize=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: ProgressDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: ProgressDlg_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    # VISIBLE: Simply call IupShow or IupHide for the dialog.
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: ProgressDlg_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: ProgressDlg_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

# TODO unknown: progressdlg XFONTID Unknown Binary
proc `xfontid`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

# TODO unknown: progressdlg XWINDOW Unknown Binary
proc `xwindow`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: ProgressDlg_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `zorder=`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: ProgressDlg_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `cancel_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # CANCEL_CB: Action generated when the user clicked on the Cancel
    # button. int function(Ihandle* ih); [in C]elem:cancel_cb() ->
    # (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("CANCEL_CB"), cast[Icallback](cb))

proc `cancel_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("CANCEL_CB"), cast[Icallback](cb))

proc `cancel_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("CANCEL_CB")))

proc `close_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # CLOSE_CB CLOSE_CB Called just before a dialog is closed when the
    # user clicks the close button of the title bar or an equivalent
    # action. Callback int function(Ihandle *ih); [in C] ih:close_cb()
    # -> (ret: number) [in Lua] ih: identifies the element that
    # activated the event. Returns: if IUP_IGNORE, it prevents the
    # dialog from being closed. If you destroy the dialog in this
    # callback, you must return IUP_IGNORE. IUP_CLOSE will be
    # processed. Affects IupDialog
    SetCallback(cast[PIhandle](ih), cstring("CLOSE_CB"), cast[Icallback](cb))

proc `close_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("CLOSE_CB"), cast[Icallback](cb))

proc `close_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("CLOSE_CB")))

proc `destroy_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: ProgressDlg_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: ProgressDlg_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `focus_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `killfocus_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `show_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, state: cint): cint {.cdecl.}) {.cdecl.} =
    # SHOW_CB SHOW_CB Called right after the dialog is showed, hidden,
    # maximized, minimized or restored from minimized/maximized. This
    # callback is called when those actions were performed by the user
    # or programmatically by the application. Callback int
    # function(Ihandle *ih, int state); [in C] ih:show_cb(state:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. state: indicates which of the
    # following situations generated the event: IUP_HIDE (since 3.0)
    # IUP_SHOW IUP_RESTORE (was minimized or maximized) IUP_MINIMIZE
    # IUP_MAXIMIZE (since 3.0) (not received in Motif when activated
    # from the maximize button) Returns: IUP_CLOSE will be processed.
    # Affects IupDialog
    SetCallback(cast[PIhandle](ih), cstring("SHOW_CB"), cast[Icallback](cb))

proc `show_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, state: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SHOW_CB"), cast[Icallback](cb))

proc `show_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SHOW_CB")))

proc `trayclick_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, but, pressed, dclick: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("TRAYCLICK_CB"), cast[Icallback](cb))

proc `trayclick_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle, but, pressed, dclick: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("TRAYCLICK_CB"), cast[Icallback](cb))

proc `trayclick_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("TRAYCLICK_CB")))

proc `unmap_cb=`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: ProgressDlg_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: ProgressDlg_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc Radio*(child: IUPhandle_t): Radio_t {.cdecl.} =
    # Creates a void container for grouping mutual exclusive toggles.
    # Only one of its descendent toggles will be active at a time. The
    # toggles can be at any composition. It does not have a native
    # representation.
    return Radio_t(niupc.Radio(cast[PIhandle](child)))

proc `active=`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Radio_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Radio_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Radio_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `canfocus=`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Radio_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Radio_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Radio_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `clientoffset`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `expand=`*(ih: Radio_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable): The default value is "YES".
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Radio_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Radio_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Radio_t, value: string) {.cdecl.} =
    # FONT, CLIENTSIZE, CLIENTOFFSET, POSITION, MINSIZE, MAXSIZE,
    # VISIBLE, THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary radio
proc `font`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary radio
proc `fontface`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Radio_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Radio_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary radio
proc `fontstyle`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary radio
proc `handlename`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `maxsize=`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Radio_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Radio_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Radio_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Radio_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary radio
proc `name`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary radio
proc `normalizergroup`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary radio
proc `ntheme`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: radio PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: radio PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Radio_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Radio_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Radio_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Radio_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Radio_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Radio_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Radio_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `size=`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Radio_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Radio_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary radio
proc `theme`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `usersize=`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Radio_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Radio_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: Radio_t, handle: IUPhandle_t) {.cdecl.} =
    # VALUE (non inheritable): name identifier of the active toggle.
    # The name is set by means of IupSetHandle. In Lua you can also
    # use the element reference directly. When consulted if the
    # toggles are not mapped into the native system the return value
    # may be NULL or invalid.
    SetAttributeHandle(cast[PIhandle](ih), cstring("VALUE"), cast[PIhandle](handle))

proc `value`*(ih: Radio_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("VALUE"), cast[PIhandle](handle))

proc `value`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `value_handle=`*(ih: Radio_t, handle: IUPhandle_t) {.cdecl.} =
    # VALUE_HANDLE (non inheritable): Changes the active toggle. The
    # value passed must be the handle of a child contained in the
    # radio. When consulted if the toggles are not mapped into the
    # native system the return value may be NULL or invalid. (since
    # 3.0)
    SetAttributeHandle(cast[PIhandle](ih), cstring("VALUE_HANDLE"), cast[PIhandle](handle))

proc `value_handle`*(ih: Radio_t, handle: IUPhandle_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("VALUE_HANDLE"), cast[PIhandle](handle))

proc `value_handle`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE_HANDLE"))

proc `visible=`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Radio_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Radio_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Radio_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Radio_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

# TODO unknown: radio XFONTID Unknown Binary
proc `xfontid`*(ih: Radio_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `destroy_cb=`*(ih: Radio_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Radio_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Radio_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `ldestroy_cb=`*(ih: Radio_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Radio_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Radio_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: Radio_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Radio_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Radio_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: Radio_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Radio_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Radio_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: Radio_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Radio_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Radio_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc Sbox*(child: IUPhandle_t): Sbox_t {.cdecl.} =
    # Creates a void container that allows its child to be resized.
    # Allows expanding and contracting the child size in one
    # direction. It does not have a native representation but it
    # contains also a IupFlatSeparator to implement the bar handler.
    return Sbox_t(niupc.Sbox(cast[PIhandle](child)))

proc `active=`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Sbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Sbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Sbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `barsize=`*(ih: Sbox_t, value: string) {.cdecl.} =
    # BARSIZE (non inheritable): controls the size of the bar handler.
    # Default: 5. (since 3.27)
    SetAttribute(cast[PIhandle](ih), cstring("BARSIZE"), cstring(value))

proc `barsize`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BARSIZE"), cstring(value))

proc `barsize=`*(ih: Sbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BARSIZE"), cstring(&"{x}"))

proc `barsize`*(ih: Sbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BARSIZE"), cstring(&"{x}"))

proc `barsize`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BARSIZE"))

proc `canfocus=`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Sbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Sbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Sbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `clientoffset`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `color=`*(ih: Sbox_t, value: string) {.cdecl.} =
    # COLOR: Changes the color of the bar handler. Default: "160 160
    # 160". (changed in 3.28 to match IupSplit default color)
    SetAttribute(cast[PIhandle](ih), cstring("COLOR"), cstring(value))

proc `color`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COLOR"), cstring(value))

proc `color=`*(ih: Sbox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `color`*(ih: Sbox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `color`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("COLOR"))

proc `direction=`*(ih: Sbox_t, value: string) {.cdecl.} =
    # DIRECTION (creation only): Indicates the direction of the resize
    # and the position of the bar handler. Possible values are
    # "NORTH", "SOUTH" (vertical direction), "EAST" or "WEST"
    # (horizontal direction). Default: "EAST".
    SetAttribute(cast[PIhandle](ih), cstring("DIRECTION"), cstring(value))

proc `direction`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIRECTION"), cstring(value))

proc `direction`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DIRECTION"))

proc `expand=`*(ih: Sbox_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable): It will expand automatically only in
    # the direction opposite to the handler.
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Sbox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Sbox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Sbox_t, value: string) {.cdecl.} =
    # FONT, SIZE, RASTERSIZE, CLIENTSIZE, CLIENTOFFSET, POSITION,
    # MINSIZE, MAXSIZE, THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary sbox
proc `font`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary sbox
proc `fontface`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Sbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Sbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary sbox
proc `fontstyle`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary sbox
proc `handlename`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `layoutdrag=`*(ih: Sbox_t, value: string) {.cdecl.} =
    # LAYOUTDRAG (non inheritable): When the bar is moved
    # automatically update the children layout. Default: YES. If set
    # to NO then the layout will be updated only when the mouse drag
    # is released. (since 3.27)
    SetAttribute(cast[PIhandle](ih), cstring("LAYOUTDRAG"), cstring(value))

proc `layoutdrag`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LAYOUTDRAG"), cstring(value))

proc `layoutdrag=`*(ih: Sbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LAYOUTDRAG"), cstring((if yes: "YES" else: "NO")))

proc `layoutdrag`*(ih: Sbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LAYOUTDRAG"), cstring((if yes: "YES" else: "NO")))

proc `layoutdrag`*(ih: Sbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LAYOUTDRAG")) == "YES"

proc `maxsize=`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Sbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Sbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Sbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Sbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary sbox
proc `name`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary sbox
proc `normalizergroup`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary sbox
proc `ntheme`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: sbox PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: sbox PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Sbox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Sbox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Sbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Sbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Sbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Sbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Sbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `showgrip=`*(ih: Sbox_t, value: string) {.cdecl.} =
    # SHOWGRIP (non inheritable): Shows the bar grip affordance.
    # Default: NO. When set to NO, COLOR is used to fill the grip
    # area. If set to "LINES" then instead of the traditional grip
    # appearance, it will be two parallel lines. (since 3.27)
    SetAttribute(cast[PIhandle](ih), cstring("SHOWGRIP"), cstring(value))

proc `showgrip`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWGRIP"), cstring(value))

proc `showgrip=`*(ih: Sbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWGRIP"), cstring((if yes: "YES" else: "NO")))

proc `showgrip`*(ih: Sbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWGRIP"), cstring((if yes: "YES" else: "NO")))

proc `showgrip`*(ih: Sbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWGRIP")) == "YES"

proc `size=`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Sbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Sbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary sbox
proc `theme`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `usersize=`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Sbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Sbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Sbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Sbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Sbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Sbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

# TODO unknown: sbox XFONTID Unknown Binary
proc `xfontid`*(ih: Sbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `destroy_cb=`*(ih: Sbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Sbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Sbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `ldestroy_cb=`*(ih: Sbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Sbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Sbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: Sbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Sbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Sbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: Sbox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Sbox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Sbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: Sbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Sbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Sbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc ScrollBox*(child: IUPhandle_t): ScrollBox_t {.cdecl.} =
    # Creates a native container that allows its child to be scrolled.
    # It inherits from IupCanvas.
    return ScrollBox_t(niupc.ScrollBox(cast[PIhandle](child)))

proc `active=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `backingstore=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring(value))

proc `backingstore=`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE"), cstring((if yes: "YES" else: "NO")))

proc `backingstore`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BACKINGSTORE")) == "YES"

proc `bgcolor=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    # BGCOLOR: will always use the background color of the native
    # parent.
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: ScrollBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: ScrollBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `canfocus=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    # CANFOCUS: is set to NO.
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `canvasbox=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    # CANVASBOX (non inheritable): enable the behavior of a canvas box
    # instead of a regular container. This will affect the EXPAND
    # attribute, the Natural size computation, and child layout
    # distribution. Can be Yes or No. Default: No. (since 3.20)
    SetAttribute(cast[PIhandle](ih), cstring("CANVASBOX"), cstring(value))

proc `canvasbox`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANVASBOX"), cstring(value))

proc `canvasbox=`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANVASBOX"), cstring((if yes: "YES" else: "NO")))

proc `canvasbox`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANVASBOX"), cstring((if yes: "YES" else: "NO")))

proc `canvasbox`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANVASBOX")) == "YES"

proc `charsize`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `childoffset=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    # CHILDOFFSET: Allow to specify a position offset for the child.
    # Available for native containers only. It will not affect the
    # natural size, and allows to position controls outside the client
    # area. Format "dxxdy", where dx and dy are integer values
    # corresponding to the horizontal and vertical offsets,
    # respectively, in pixels. Default: 0x0. (since 3.14)
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset=`*(ih: ScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: ScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"))

proc `clientoffset`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `cursor=`*(ih: ScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: ScrollBox_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("CURSOR"), cast[PIhandle](handle))

proc `cursor`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CURSOR"))

proc `dragdrop=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary scrollbox
proc `dragtypes`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

# TODO unknown: scrollbox DRAWABLE Unknown Binary
proc `drawable`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWABLE"))

proc `drawbgcolor=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(value))

proc `drawbgcolor=`*(ih: ScrollBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: ScrollBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawbgcolor`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWBGCOLOR"))

proc `drawcolor=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(value))

proc `drawcolor=`*(ih: ScrollBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: ScrollBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `drawcolor`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWCOLOR"))

proc `drawdriver`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWDRIVER"))

proc `drawfont=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

proc `drawfont`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"), cstring(value))

# TODO ??? String Binary scrollbox
proc `drawfont`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWFONT"))

proc `drawlinewidth=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(value))

proc `drawlinewidth=`*(ih: ScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: ScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"), cstring(&"{x}"))

proc `drawlinewidth`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWLINEWIDTH"))

proc `drawmakeinactive=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring(value))

proc `drawmakeinactive=`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `drawmakeinactive`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWMAKEINACTIVE")) == "YES"

proc `drawsize`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSIZE"))

proc `drawstyle=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"), cstring(value))

proc `drawstyle`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWSTYLE"))

proc `drawtextalignment=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"), cstring(value))

proc `drawtextalignment`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTALIGNMENT"))

proc `drawtextclip=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring(value))

proc `drawtextclip=`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextclip`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTCLIP")) == "YES"

proc `drawtextellipsis=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring(value))

proc `drawtextellipsis=`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS"), cstring((if yes: "YES" else: "NO")))

proc `drawtextellipsis`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTELLIPSIS")) == "YES"

proc `drawtextlayoutcenter=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring(value))

proc `drawtextlayoutcenter=`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER"), cstring((if yes: "YES" else: "NO")))

proc `drawtextlayoutcenter`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTLAYOUTCENTER")) == "YES"

proc `drawtextorientation=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(value))

proc `drawtextorientation=`*(ih: ScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: ScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"), cstring(&"{x}"))

proc `drawtextorientation`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTORIENTATION"))

proc `drawtextwrap=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring(value))

proc `drawtextwrap=`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP"), cstring((if yes: "YES" else: "NO")))

proc `drawtextwrap`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAWTEXTWRAP")) == "YES"

proc `dropfilestarget=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary scrollbox
proc `droptypes`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `dx=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(value))

proc `dx=`*(ih: ScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: ScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DX"), cstring(&"{x}"))

proc `dx`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DX"))

proc `dy=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(value))

proc `dy=`*(ih: ScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: ScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DY"), cstring(&"{x}"))

proc `dy`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DY"))

proc `expand=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable): The default value is "YES".
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: ScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: ScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary scrollbox
proc `font`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary scrollbox
proc `fontface`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: ScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: ScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary scrollbox
proc `fontstyle`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary scrollbox
proc `handlename`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `layoutdrag=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    # LAYOUTDRAG (non inheritable) [Windows Only]: When the scrollbar
    # is moved automatically update the children layout. Default: YES.
    # If set to NO then the layout will be updated only when the mouse
    # drag is released. (since 3.19)
    SetAttribute(cast[PIhandle](ih), cstring("LAYOUTDRAG"), cstring(value))

proc `layoutdrag`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LAYOUTDRAG"), cstring(value))

proc `layoutdrag=`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LAYOUTDRAG"), cstring((if yes: "YES" else: "NO")))

proc `layoutdrag`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LAYOUTDRAG"), cstring((if yes: "YES" else: "NO")))

proc `layoutdrag`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LAYOUTDRAG")) == "YES"

proc `linex=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(value))

proc `linex=`*(ih: ScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: ScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEX"), cstring(&"{x}"))

proc `linex`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEX"))

proc `liney=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(value))

proc `liney=`*(ih: ScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: ScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINEY"), cstring(&"{x}"))

proc `liney`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEY"))

proc `maxsize=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: ScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: ScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: ScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: ScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary scrollbox
proc `name`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary scrollbox
proc `normalizergroup`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary scrollbox
proc `ntheme`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: scrollbox PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: scrollbox PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: ScrollBox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: ScrollBox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `posx=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(value))

proc `posx=`*(ih: ScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: ScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSX"), cstring(&"{x}"))

proc `posx`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSX"))

proc `posy=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(value))

proc `posy=`*(ih: ScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: ScrollBox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSY"), cstring(&"{x}"))

proc `posy`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSY"))

proc `propagatefocus=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: ScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: ScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `sb_resize`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SB_RESIZE"))

proc `screenposition`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `scrollbar=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    # SCROLLBAR (creation only): the default value is "YES".
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar=`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR")) == "YES"

proc `scrollto=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    # SCROLLTO (write-only): position the scroll at the given x,y
    # coordinates relative to the box top-left corner. Format "x,y".
    # Value can also be TOP or BOTTOM for a vertical scroll to the top
    # or to the bottom of the scroll range. (since 3.17)
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTO"), cstring(value))

proc `scrollto`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTO"), cstring(value))

proc `scrollto=`*(ih: ScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTO"), cstring(&"{x}"))

proc `scrollto`*(ih: ScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTO"), cstring(&"{x}"))

proc `scrolltochild=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    # SCROLLTOCHILD (write-only): position the scroll at the top-left
    # corner of the given child located by its name. Use IupSetHandle
    # or IupSetAttributeHandle to associate an Ihandle* to a name. The
    # child must be contained in the Scrollbox hierarchy. (since 3.17)
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTOCHILD"), cstring(value))

proc `scrolltochild`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTOCHILD"), cstring(value))

# TODO ??? String Binary scrollbox
proc `scrolltochild_handle=`*(ih: ScrollBox_t, handle: User_t) {.cdecl.} =
    # SCROLLTOCHILD_HANDLE (write-only): same as SCROLLTOCHILD but
    # directly using the child handle. (since 3.17)
    SetAttributeHandle(cast[PIhandle](ih), cstring("SCROLLTOCHILD_HANDLE"), cast[PIhandle](handle))

proc `scrolltochild_handle`*(ih: ScrollBox_t, handle: User_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("SCROLLTOCHILD_HANDLE"), cast[PIhandle](handle))

proc `size=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: ScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: ScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary scrollbox
proc `theme`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary scrollbox
proc `tip`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: ScrollBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: ScrollBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: ScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: ScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: ScrollBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: ScrollBox_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary scrollbox
proc `tipicon`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary scrollbox
proc `tipmarkup`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: ScrollBox_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: ScrollBox_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `touch=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring(value))

proc `touch=`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOUCH"), cstring((if yes: "YES" else: "NO")))

proc `touch`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TOUCH")) == "YES"

proc `usersize=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: ScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: ScrollBox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wheeldropfocus=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    # WHEELDROPFOCUS: set to Yes. (since 3.28)
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring(value))

proc `wheeldropfocus=`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: ScrollBox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `wheeldropfocus`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WHEELDROPFOCUS")) == "YES"

proc `wid`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

proc `xautohide`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XAUTOHIDE")) == "YES"

proc `xdisplay`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XDISPLAY"))

# TODO unknown: scrollbox XFONTID Unknown Binary
proc `xfontid`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `xhidden`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XHIDDEN")) == "YES"

proc `xmax=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(value))

proc `xmax=`*(ih: ScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: ScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMAX"), cstring(&"{x}"))

proc `xmax`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMAX"))

proc `xmin=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(value))

proc `xmin=`*(ih: ScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: ScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("XMIN"), cstring(&"{x}"))

proc `xmin`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XMIN"))

# TODO unknown: scrollbox XWINDOW Unknown Binary
proc `xwindow`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XWINDOW"))

proc `y`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `yautohide`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YAUTOHIDE")) == "YES"

proc `yhidden`*(ih: ScrollBox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YHIDDEN")) == "YES"

proc `ymax=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(value))

proc `ymax=`*(ih: ScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: ScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMAX"), cstring(&"{x}"))

proc `ymax`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMAX"))

proc `ymin=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(value))

proc `ymin=`*(ih: ScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: ScrollBox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("YMIN"), cstring(&"{x}"))

proc `ymin`*(ih: ScrollBox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("YMIN"))

proc `zorder=`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: ScrollBox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, arg2: cfloat, arg3: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `destroy_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: ScrollBox_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: ScrollBox_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `focus_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `keypress_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    # KEYPRESS_CB KEYPRESS_CB Action generated when a key is pressed
    # or released. If the key is pressed and held several calls will
    # occur. It is called after the callback K_ANY is processed.
    # Callback int function(Ihandle *ih, int c, int press); [in C]
    # ih:keypress_cb(c, press: number) -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. c:
    # identifier of typed key. Please refer to the Keyboard Codes
    # table for a list of possible values. press: 1 is the user
    # pressed the key or 0 otherwise. Returns: If IUP_IGNORE is
    # returned the key is ignored by the system. IUP_CLOSE will be
    # processed. Affects IupCanvas
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, c, press: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB"), cast[Icallback](cb))

proc `keypress_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KEYPRESS_CB")))

proc `killfocus_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `layoutupdate_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LAYOUTUPDATE_CB: Action generated when the layout is updated
    # after a scroll operation. (since 3.24)
    SetCallback(cast[PIhandle](ih), cstring("LAYOUTUPDATE_CB"), cast[Icallback](cb))

proc `layoutupdate_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LAYOUTUPDATE_CB"), cast[Icallback](cb))

proc `layoutupdate_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LAYOUTUPDATE_CB")))

proc `ldestroy_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `postmessage_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `resize_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    # RESIZE_CB RESIZE_CB Action generated when the canvas or dialog
    # size is changed. Callback int function(Ihandle *ih, int width,
    # int height); [in C] ih:resize_cb(width, height: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. width: the width of the internal element size in
    # pixels not considering the decorations (client size) height: the
    # height of the internal element size in pixels not considering
    # the decorations (client size) Notes For the dialog, this action
    # is also generated when the dialog is mapped, after the map and
    # before the show. When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the
    # canvas scrollbar is hidden/shown after changing the DX or DY
    # attributes from inside the callback, the size of the drawing
    # area will immediately change, so the parameters with and height
    # will be invalid. To update the parameters consult the DRAWSIZE
    # attribute. Also activate the drawing toolkit only after updating
    # the DX or DY attributes. Affects IupCanvas, IupGLCanvas,
    # IupDialog
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, width, height: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RESIZE_CB"), cast[Icallback](cb))

proc `resize_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RESIZE_CB")))

proc `scroll_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    # SCROLL_CB SCROLL_CB Called when some manipulation is made to the
    # scrollbar. The canvas is automatically redrawn only if this
    # callback is NOT defined. (GTK 2.8) Also the POSX and POSY values
    # will not be correctly updated for older GTK versions. In Ubuntu,
    # when liboverlay-scrollbar is enabled (the new tiny auto-hide
    # scrollbar) only the IUP_SBPOSV and IUP_SBPOSH codes are used.
    # Callback int function(Ihandle *ih, int op, float posx, float
    # posy); [in C] ih:scroll_cb(op, posx, posy: number) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. op: indicates the operation performed on the
    # scrollbar. If the manipulation was made on the vertical
    # scrollbar, it can have the following values: IUP_SBUP - line up
    # IUP_SBDN - line down IUP_SBPGUP - page up IUP_SBPGDN - page down
    # IUP_SBPOSV - vertical positioning IUP_SBDRAGV - vertical drag If
    # it was on the horizontal scrollbar, the following values are
    # valid: IUP_SBLEFT - column left IUP_SBRIGHT - column right
    # IUP_SBPGLEFT - page left IUP_SBPGRIGHT - page right IUP_SBPOSH -
    # horizontal positioning IUP_SBDRAGH - horizontal drag posx, posy:
    # the same as the ACTION canvas callback (corresponding to the
    # values of attributes POSX and POSY). Notes IUP_SBDRAGH and
    # IUP_SBDRAGV are not supported in GTK. During drag IUP_SBPOSH and
    # IUP_SBPOSV are used. In Windows, after a drag when mouse is
    # released IUP_SBPOSH or IUP_SBPOSV are called. Affects IupCanvas,
    # IupGLCanvas, SCROLLBAR
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, op: cint, posx, posy: cfloat): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SCROLL_CB"), cast[Icallback](cb))

proc `scroll_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SCROLL_CB")))

proc `unmap_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `wheel_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # WHEEL_CB WHEEL_CB Action generated when the mouse wheel is
    # rotated. If this callback is not defined the wheel will
    # automatically scroll the canvas in the vertical direction by
    # some lines, the SCROLL_CB callback if defined will be called
    # with the IUP_SBDRAGV operation. Callback int function(Ihandle
    # *ih, float delta, int x, int y, char *status); [in C]
    # ih:wheel_cb(delta, x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. delta: the amount the wheel was rotated in notches.
    # x, y: position in the canvas where the event has occurred, in
    # pixels. status: status of mouse buttons and certain keyboard
    # keys at the moment the event was generated. The same macros used
    # for BUTTON_CB can be used for this status. Notes In Motif and
    # GTK delta is always 1 or -1. In Windows is some situations delta
    # can reach the value of two. In the future with more precise
    # wheels this increment can be changed. Affects IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, delta: cfloat, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WHEEL_CB"), cast[Icallback](cb))

proc `wheel_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WHEEL_CB")))

proc `wom_cb=`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # WOM_CB WOM_CB Action generated when an audio device receives an
    # event. [Windows Only] Callback int function(Ihandle *ih, int
    # state); [in C] ih:wom_cb(state: number) -> (ret: number) [in
    # Lua] ih: identifies the element that activated the event. state:
    # can be opening=1, done=0, or closing=-1. Notes This callback is
    # used to syncronize video playback with audio. It is sent when
    # the audio device: Message Description opening is opened by using
    # the waveOutOpen function. done is finished with a data block
    # sent by using the waveOutWrite function. closing is closed by
    # using the waveOutClose function. You must use the HWND attribute
    # when calling waveOutOpen in the dwCallback parameter and set
    # fdwOpen to CALLBACK_WINDOW. Affects IupDialog, IupCanvas,
    # IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: ScrollBox_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("WOM_CB"), cast[Icallback](cb))

proc `wom_cb`*(ih: ScrollBox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("WOM_CB")))

proc Separator*(): Separator_t {.cdecl.} =
    # Creates the separator interface element. It shows a line between
    # two menu items.
    return Separator_t(niupc.Separator())

proc `name=`*(ih: Separator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Separator_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary separator
proc `name`*(ih: Separator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `wid`*(ih: Separator_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc Space*(): Space_t {.cdecl.} =
    # Creates void element, which occupies an empty space. It does not
    # have a native representation.
    return Space_t(niupc.Space())

proc `active=`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Space_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Space_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Space_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `canfocus=`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Space_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Space_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Space_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `expand=`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Space_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Space_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary space
proc `font`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary space
proc `fontface`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Space_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Space_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary space
proc `fontstyle`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary space
proc `handlename`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `maxsize=`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Space_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Space_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Space_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Space_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary space
proc `name`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary space
proc `normalizergroup`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary space
proc `ntheme`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: space PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: space PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Space_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Space_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Space_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Space_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Space_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Space_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Space_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `size=`*(ih: Space_t, value: string) {.cdecl.} =
    # SIZE, RASTERSIZE, EXPAND, FONT, POSITION, MINSIZE, MAXSIZE,
    # THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Space_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Space_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary space
proc `theme`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `usersize=`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Space_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Space_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Space_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Space_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Space_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Space_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

# TODO unknown: space XFONTID Unknown Binary
proc `xfontid`*(ih: Space_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `destroy_cb=`*(ih: Space_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Space_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Space_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `ldestroy_cb=`*(ih: Space_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Space_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Space_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: Space_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Space_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Space_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: Space_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Space_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Space_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: Space_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Space_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Space_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc Spin*(): Spin_t {.cdecl.} =
    # This functions will create a control set with a vertical box
    # containing two buttons, one with an up arrow and the other with
    # a down arrow, to be used to increment and decrement values.
    # Unlike the SPIN attribute of the IupText element, the IupSpin
    # element can NOT automatically increment the value and it is NOT
    # inserted inside the IupText area. But they can be used with any
    # element.
    return Spin_t(niupc.Spin())

proc `active=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Spin_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Spin_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Spin_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `alignment=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"))

proc `canfocus=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Spin_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Spin_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Spin_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `cgap=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CGAP"), cstring(value))

proc `cgap`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CGAP"), cstring(value))

proc `cgap=`*(ih: Spin_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CGAP"), cstring(&"{x}"))

proc `cgap`*(ih: Spin_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CGAP"), cstring(&"{x}"))

proc `cgap`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CGAP"))

proc `charsize`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `clientoffset`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `cmargin=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CMARGIN"), cstring(value))

proc `cmargin`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CMARGIN"), cstring(value))

proc `cmargin=`*(ih: Spin_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CMARGIN"), cstring(&"{horiz}x{vert}"))

proc `cmargin`*(ih: Spin_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CMARGIN"), cstring(&"{horiz}x{vert}"))

proc `cmargin`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CMARGIN"))

proc `expand=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandchildren=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDCHILDREN"), cstring(value))

proc `expandchildren`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDCHILDREN"), cstring(value))

proc `expandchildren=`*(ih: Spin_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDCHILDREN"), cstring((if yes: "YES" else: "NO")))

proc `expandchildren`*(ih: Spin_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDCHILDREN"), cstring((if yes: "YES" else: "NO")))

proc `expandchildren`*(ih: Spin_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDCHILDREN")) == "YES"

proc `expandweight=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Spin_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Spin_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary spin
proc `font`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary spin
proc `fontface`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Spin_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Spin_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary spin
proc `fontstyle`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `gap=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("GAP"), cstring(value))

proc `gap`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("GAP"), cstring(value))

proc `gap=`*(ih: Spin_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("GAP"), cstring(&"{x}"))

proc `gap`*(ih: Spin_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("GAP"), cstring(&"{x}"))

proc `gap`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("GAP"))

proc `handlename=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary spin
proc `handlename`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `homogeneous=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HOMOGENEOUS"), cstring(value))

proc `homogeneous`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HOMOGENEOUS"), cstring(value))

proc `homogeneous=`*(ih: Spin_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HOMOGENEOUS"), cstring((if yes: "YES" else: "NO")))

proc `homogeneous`*(ih: Spin_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HOMOGENEOUS"), cstring((if yes: "YES" else: "NO")))

proc `homogeneous`*(ih: Spin_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HOMOGENEOUS")) == "YES"

proc `margin=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(value))

proc `margin`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(value))

proc `margin=`*(ih: Spin_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(&"{horiz}x{vert}"))

proc `margin`*(ih: Spin_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(&"{horiz}x{vert}"))

proc `margin`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MARGIN"))

proc `maxsize=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Spin_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Spin_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Spin_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Spin_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary spin
proc `name`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `ncgap=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCGAP"), cstring(value))

proc `ncgap`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCGAP"), cstring(value))

proc `ncgap=`*(ih: Spin_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCGAP"), cstring(&"{x}"))

proc `ncgap`*(ih: Spin_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCGAP"), cstring(&"{x}"))

proc `ncgap`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NCGAP"))

proc `ncmargin=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"), cstring(value))

proc `ncmargin`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"), cstring(value))

proc `ncmargin=`*(ih: Spin_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"), cstring(&"{horiz}x{vert}"))

proc `ncmargin`*(ih: Spin_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"), cstring(&"{horiz}x{vert}"))

proc `ncmargin`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"))

proc `ngap=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NGAP"), cstring(value))

proc `ngap`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NGAP"), cstring(value))

proc `ngap=`*(ih: Spin_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NGAP"), cstring(&"{x}"))

proc `ngap`*(ih: Spin_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NGAP"), cstring(&"{x}"))

proc `ngap`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NGAP"))

proc `nmargin=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NMARGIN"), cstring(value))

proc `nmargin`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NMARGIN"), cstring(value))

proc `nmargin=`*(ih: Spin_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NMARGIN"), cstring(&"{horiz}x{vert}"))

proc `nmargin`*(ih: Spin_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NMARGIN"), cstring(&"{horiz}x{vert}"))

proc `nmargin`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NMARGIN"))

proc `normalizergroup=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary spin
proc `normalizergroup`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `normalizesize=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZESIZE"), cstring(value))

proc `normalizesize`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZESIZE"), cstring(value))

proc `normalizesize`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZESIZE"))

proc `ntheme=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary spin
proc `ntheme`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `orientation`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"))

# TODO unknown: spin PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: spin PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Spin_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Spin_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Spin_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Spin_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Spin_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Spin_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Spin_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `size=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Spin_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Spin_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary spin
proc `theme`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `usersize=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Spin_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Spin_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Spin_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Spin_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Spin_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Spin_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

# TODO unknown: spin XFONTID Unknown Binary
proc `xfontid`*(ih: Spin_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `destroy_cb=`*(ih: Spin_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Spin_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Spin_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `ldestroy_cb=`*(ih: Spin_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Spin_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Spin_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: Spin_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Spin_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Spin_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: Spin_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Spin_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Spin_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `spin_cb=`*(ih: Spin_t, cb: proc (ih: PIhandle, pos: cint): cint {.cdecl.}) {.cdecl.} =
    # SPIN_CB: Called each time the user clicks in the buttons. It
    # will increment 1 and decrement -1 by default. Holding the Shift
    # key will set a factor of 2, holding Ctrl a factor of 10, and
    # both a factor of 100. int function(Ihandle *ih, int inc); [in C]
    # ih:spin_cb(inc: number) -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("SPIN_CB"), cast[Icallback](cb))

proc `spin_cb`*(ih: Spin_t, cb: proc (ih: PIhandle, pos: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SPIN_CB"), cast[Icallback](cb))

proc `spin_cb`*(ih: Spin_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SPIN_CB")))

proc `unmap_cb=`*(ih: Spin_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Spin_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Spin_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `updateattribfromfont_cb=`*(ih: Spin_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UPDATEATTRIBFROMFONT_CB"), cast[Icallback](cb))

proc `updateattribfromfont_cb`*(ih: Spin_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UPDATEATTRIBFROMFONT_CB"), cast[Icallback](cb))

proc `updateattribfromfont_cb`*(ih: Spin_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UPDATEATTRIBFROMFONT_CB")))

proc Spinbox*(child: IUPhandle_t): Spinbox_t {.cdecl.} =
    return Spinbox_t(niupc.Spinbox(cast[PIhandle](child)))

proc `active=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Spinbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Spinbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Spinbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `canfocus=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Spinbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Spinbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Spinbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `clientoffset`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `expand=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Spinbox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Spinbox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary spinbox
proc `font`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary spinbox
proc `fontface`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Spinbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Spinbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary spinbox
proc `fontstyle`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary spinbox
proc `handlename`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `maxsize=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Spinbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Spinbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Spinbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Spinbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary spinbox
proc `name`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary spinbox
proc `normalizergroup`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary spinbox
proc `ntheme`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: spinbox PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: spinbox PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Spinbox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Spinbox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Spinbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Spinbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Spinbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Spinbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Spinbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `size=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Spinbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Spinbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary spinbox
proc `theme`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `usersize=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Spinbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Spinbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Spinbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Spinbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Spinbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Spinbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

# TODO unknown: spinbox XFONTID Unknown Binary
proc `xfontid`*(ih: Spinbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `destroy_cb=`*(ih: Spinbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Spinbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Spinbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `ldestroy_cb=`*(ih: Spinbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Spinbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Spinbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: Spinbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Spinbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Spinbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: Spinbox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Spinbox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Spinbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `spin_cb=`*(ih: Spinbox_t, cb: proc (ih: PIhandle, pos: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SPIN_CB"), cast[Icallback](cb))

proc `spin_cb`*(ih: Spinbox_t, cb: proc (ih: PIhandle, pos: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SPIN_CB"), cast[Icallback](cb))

proc `spin_cb`*(ih: Spinbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SPIN_CB")))

proc `unmap_cb=`*(ih: Spinbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Spinbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Spinbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc Split*(child1: IUPhandle_t; child2: IUPhandle_t): Split_t {.cdecl.} =
    # Creates a void container that split its client area in two.
    # Allows the provided controls to be enclosed in a box that allows
    # expanding and contracting the element size in one direction, but
    # when one is expanded the other is contracted. It does not have a
    # native representation, but it contains also a IupFlatSeparator
    # to implement the bar handler.
    return Split_t(niupc.Split(cast[PIhandle](child1), cast[PIhandle](child2)))

proc `active=`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Split_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Split_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Split_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `autohide=`*(ih: Split_t, value: string) {.cdecl.} =
    # AUTOHIDE (non inheritable): if the child client area is smaller
    # than the bar size, then automatically hide the child. Default:
    # NO.
    SetAttribute(cast[PIhandle](ih), cstring("AUTOHIDE"), cstring(value))

proc `autohide`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOHIDE"), cstring(value))

proc `autohide=`*(ih: Split_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `autohide`*(ih: Split_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `autohide`*(ih: Split_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("AUTOHIDE")) == "YES"

proc `barsize=`*(ih: Split_t, value: string) {.cdecl.} =
    # BARSIZE (non inheritable): controls the size of the bar handler.
    # Default: 5.
    SetAttribute(cast[PIhandle](ih), cstring("BARSIZE"), cstring(value))

proc `barsize`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BARSIZE"), cstring(value))

proc `barsize=`*(ih: Split_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BARSIZE"), cstring(&"{x}"))

proc `barsize`*(ih: Split_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BARSIZE"), cstring(&"{x}"))

proc `barsize`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BARSIZE"))

proc `canfocus=`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Split_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Split_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Split_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `clientoffset`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `color=`*(ih: Split_t, value: string) {.cdecl.} =
    # COLOR: Changes the color of the bar grip affordance. Default:
    # "160 160 160".
    SetAttribute(cast[PIhandle](ih), cstring("COLOR"), cstring(value))

proc `color`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COLOR"), cstring(value))

proc `color=`*(ih: Split_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `color`*(ih: Split_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("COLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `color`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("COLOR"))

proc `direction=`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIRECTION"), cstring(value))

proc `direction`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DIRECTION"), cstring(value))

proc `direction`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DIRECTION"))

proc `expand=`*(ih: Split_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable): The default value is "YES".
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Split_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Split_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Split_t, value: string) {.cdecl.} =
    # FONT, SIZE, RASTERSIZE, CLIENTSIZE, CLIENTOFFSET, POSITION,
    # MINSIZE, MAXSIZE, THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary split
proc `font`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary split
proc `fontface`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Split_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Split_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary split
proc `fontstyle`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary split
proc `handlename`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `layoutdrag=`*(ih: Split_t, value: string) {.cdecl.} =
    # LAYOUTDRAG (non inheritable): When the bar is moved
    # automatically update the children layout. Default: YES. If set
    # to NO then the layout will be updated only when the mouse drag
    # is released.
    SetAttribute(cast[PIhandle](ih), cstring("LAYOUTDRAG"), cstring(value))

proc `layoutdrag`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LAYOUTDRAG"), cstring(value))

proc `layoutdrag=`*(ih: Split_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LAYOUTDRAG"), cstring((if yes: "YES" else: "NO")))

proc `layoutdrag`*(ih: Split_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LAYOUTDRAG"), cstring((if yes: "YES" else: "NO")))

proc `layoutdrag`*(ih: Split_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LAYOUTDRAG")) == "YES"

proc `maxsize=`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Split_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Split_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

# TODO unknown: split MINMAX Unknown Binary
proc `minmax`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINMAX"))

proc `minsize=`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Split_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Split_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary split
proc `name`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary split
proc `normalizergroup`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary split
proc `ntheme`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `orientation=`*(ih: Split_t, value: string) {.cdecl.} =
    # ORIENTATION (creation only) (non inheritable): Indicates the
    # orientation of the bar handler. The direction of the resize is
    # perpendicular to the orientation. Possible values are "VERTICAL"
    # or "HORIZONTAL". Default: "VERTICAL".
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"))

# TODO unknown: split PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: split PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Split_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Split_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Split_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Split_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Split_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Split_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Split_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `showgrip=`*(ih: Split_t, value: string) {.cdecl.} =
    # SHOWGRIP (non inheritable): Shows the bar grip affordance.
    # Default: YES. When set to NO, the BARSIZE is set to 3. When set
    # to NO, COLOR is used to fill the grip area (since 3.11.1) if
    # defined, if COLOR is not defined the area is filled with the
    # parent background color. If set to "LINES" then instead of the
    # traditional grip appearance, it will be two parallel lines
    # (since 3.11.1).
    SetAttribute(cast[PIhandle](ih), cstring("SHOWGRIP"), cstring(value))

proc `showgrip`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWGRIP"), cstring(value))

proc `showgrip=`*(ih: Split_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWGRIP"), cstring((if yes: "YES" else: "NO")))

proc `showgrip`*(ih: Split_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWGRIP"), cstring((if yes: "YES" else: "NO")))

proc `showgrip`*(ih: Split_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWGRIP")) == "YES"

proc `size=`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Split_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Split_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary split
proc `theme`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `usersize=`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Split_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Split_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: Split_t, value: string) {.cdecl.} =
    # VALUE (non inheritable): The proportion of the left or top
    # (child1) client area relative to the full available area. It is
    # an integer between 0 and 1000. If not defined or set to NULL,
    # the Native size of the two children will define its initial
    # size.
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

# TODO ??? String Binary split
proc `value`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `visible=`*(ih: Split_t, value: string) {.cdecl.} =
    # When AUTOHIDE=Yes the control will set FLOATING=IGNORE and
    # VISIBLE=NO for the child to be auto-hidden, then back to
    # FLOATING=NO and VISIBLE=Yes when shown. So if the child has
    # several children with different combinations of VISIBLE it is
    # recommended that this child to be a native container like
    # IupBackgroundBox or IupFrame, so the VISIBLE attribute will be
    # not be propagated to its children.
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Split_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Split_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Split_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Split_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

# TODO unknown: split XFONTID Unknown Binary
proc `xfontid`*(ih: Split_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `destroy_cb=`*(ih: Split_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Split_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Split_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `ldestroy_cb=`*(ih: Split_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Split_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Split_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: Split_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Split_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Split_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: Split_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Split_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Split_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: Split_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Split_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Split_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `valuechanged_cb=`*(ih: Split_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # VALUECHANGED_CB: Called after the value was interactively
    # changed by the user. (since 3.12) int function(Ihandle *ih); [in
    # C]ih:valuechanged_cb() -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: Split_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: Split_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB")))

proc Submenu*(title: string; child: IUPhandle_t): Submenu_t {.cdecl.} =
    # Creates a menu item that, when selected, opens another menu.
    return Submenu_t(niupc.Submenu(cstring(title), cast[PIhandle](child)))

proc `active=`*(ih: Submenu_t, value: string) {.cdecl.} =
    # ACTIVE, THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Submenu_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Submenu_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Submenu_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Submenu_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `bgcolor=`*(ih: Submenu_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: Submenu_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: Submenu_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Submenu_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Submenu_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `font=`*(ih: Submenu_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Submenu_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary submenu
proc `font`*(ih: Submenu_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `handlename=`*(ih: Submenu_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Submenu_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary submenu
proc `handlename`*(ih: Submenu_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `image=`*(ih: Submenu_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGE [Windows and GTK Only] (non inheritable): Image name of
    # the submenu image. In Windows, an item in a menu bar cannot have
    # a check mark. Ignored if submenu in a menu bar. A recommended
    # size would be 16x16 to fit the image in the menu item. In
    # Windows, if larger than the check mark area it will be cropped.
    # (since 3.0)
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: Submenu_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: Submenu_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGE"))

proc `key=`*(ih: Submenu_t, value: string) {.cdecl.} =
    # KEY (non inheritable): Underlines a key character in the submenu
    # title. It is updated only when TITLE is updated. Deprecated, use
    # the mnemonic support directly in the TITLE attribute.
    SetAttribute(cast[PIhandle](ih), cstring("KEY"), cstring(value))

proc `key`*(ih: Submenu_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("KEY"), cstring(value))

proc `key=`*(ih: Submenu_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("KEY"), cstring(&"{x}"))

proc `key`*(ih: Submenu_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("KEY"), cstring(&"{x}"))

proc `key`*(ih: Submenu_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("KEY"))

proc `name=`*(ih: Submenu_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Submenu_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary submenu
proc `name`*(ih: Submenu_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `title=`*(ih: Submenu_t, value: string) {.cdecl.} =
    # TITLE (non inheritable): Submenu Text. The "&" character can be
    # used to define a mnemonic, the next character will be used as
    # key. Use "&&" to show the "&" character instead on defining a
    # mnemonic.
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: Submenu_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary submenu
proc `title`*(ih: Submenu_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

proc `wid`*(ih: Submenu_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `destroy_cb=`*(ih: Submenu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Submenu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Submenu_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `highlight_cb=`*(ih: Submenu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HIGHLIGHT_CB HIGHLIGHT_CB Callback triggered every time the user
    # selects an IupItem or IupSubmenu. Callback int function(Ihandle
    # *ih); [in C] elem:highlight_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Affects
    # IupItem, IupSubmenu
    SetCallback(cast[PIhandle](ih), cstring("HIGHLIGHT_CB"), cast[Icallback](cb))

proc `highlight_cb`*(ih: Submenu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HIGHLIGHT_CB"), cast[Icallback](cb))

proc `highlight_cb`*(ih: Submenu_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HIGHLIGHT_CB")))

proc `ldestroy_cb=`*(ih: Submenu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Submenu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Submenu_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: Submenu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Submenu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Submenu_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: Submenu_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Submenu_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Submenu_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: Submenu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Submenu_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Submenu_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

macro Tabs*(args: varargs[untyped]): Tabs_t =
    # Creates a native container for composing elements in hidden
    # layers with only one layer visible (just like IupZbox), but its
    # visibility can be interactively controlled. The interaction is
    # done in a line of tabs with titles and arranged according to the
    # tab type. Also known as Notebook in native systems.


    result = nnkCall.newTree(
        nnkDotExpr.newTree(
            newIdentNode("niup"),
            newIdentNode("Tabs_t")
          ),
       )
    let inner = nnkCall.newTree(
            newIdentNode("Tabs")
          )

    if args.len > 0:
        for i in 0 ..< args.len:
          inner.add nnkCast.newTree(newIdentNode("PIhandle"), args[i])
    inner.add newNilLit()
    result.add inner


proc `active=`*(ih: Tabs_t, value: string) {.cdecl.} =
    # ACTIVE, FONT, SCREENPOSITION, POSITION, CLIENTSIZE,
    # CLIENTOFFSET, MINSIZE, MAXSIZE, WID, TIP, RASTERSIZE, ZORDER,
    # VISIBLE, THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Tabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Tabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Tabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `bgcolor=`*(ih: Tabs_t, value: string) {.cdecl.} =
    # BGCOLOR: In Windows and in GTK when in Windows, the tab buttons
    # background it will be always defined by the system. In Windows
    # the default background is different from the dialog background.
    # Default: the global attribute DLGBGCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: Tabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Tabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `canfocus=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Tabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Tabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Tabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `childoffset=`*(ih: Tabs_t, value: string) {.cdecl.} =
    # CHILDOFFSET: Allow to specify a position offset for the child.
    # Available for native containers only. It will not affect the
    # natural size, and allows to position controls outside the client
    # area. Format "dxxdy", where dx and dy are integer values
    # corresponding to the horizontal and vertical offsets,
    # respectively, in pixels. Default: 0x0. (since 3.14)
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(value))

proc `childoffset=`*(ih: Tabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: Tabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"), cstring(&"{width}x{height}"))

proc `childoffset`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHILDOFFSET"))

proc `childsizeall=`*(ih: Tabs_t, value: string) {.cdecl.} =
    # CHILDSIZEALL (non inheritable): compute the natural size using
    # all children. If set to NO will compute using only the current
    # tab. Default: Yes. (since 3.27)
    SetAttribute(cast[PIhandle](ih), cstring("CHILDSIZEALL"), cstring(value))

proc `childsizeall`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDSIZEALL"), cstring(value))

proc `childsizeall=`*(ih: Tabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDSIZEALL"), cstring((if yes: "YES" else: "NO")))

proc `childsizeall`*(ih: Tabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDSIZEALL"), cstring((if yes: "YES" else: "NO")))

proc `childsizeall`*(ih: Tabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHILDSIZEALL")) == "YES"

proc `clientoffset`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `count`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("COUNT"))

proc `expand=`*(ih: Tabs_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable): The default value is "YES".
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Tabs_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Tabs_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `fgcolor=`*(ih: Tabs_t, value: string) {.cdecl.} =
    # FGCOLOR: Tabs title color. Default: the global attribute
    # DLGFGCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: Tabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: Tabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

proc `floating=`*(ih: Tabs_t, value: string) {.cdecl.} =
    # FLOATING (non inheritable) (at children only): If a child has
    # FLOATING=YES then its size and position will be ignored by the
    # layout processing. Default: "NO". (since 3.27)
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary tabs
proc `font`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary tabs
proc `fontface`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Tabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Tabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary tabs
proc `fontstyle`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary tabs
proc `handlename`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `maxsize=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Tabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Tabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Tabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Tabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `multiline=`*(ih: Tabs_t, value: string) {.cdecl.} =
    # MULTILINE [Windows Only] (non inheritable): Enable multiple
    # lines of tab buttons. This will hide the tab scroll and fits to
    # make all tab buttons visible. Can be "YES" or "NO". Default
    # "NO". It is always enabled when TABTYPE=LEFT or TABTYPE=RIGHT.
    # (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("MULTILINE"), cstring(value))

proc `multiline`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MULTILINE"), cstring(value))

proc `multiline=`*(ih: Tabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MULTILINE"), cstring((if yes: "YES" else: "NO")))

proc `multiline`*(ih: Tabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MULTILINE"), cstring((if yes: "YES" else: "NO")))

proc `multiline`*(ih: Tabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MULTILINE")) == "YES"

proc `name=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary tabs
proc `name`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary tabs
proc `normalizergroup`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary tabs
proc `ntheme`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: tabs PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: tabs PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Tabs_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Tabs_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Tabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Tabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Tabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Tabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Tabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `screenposition`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `showclose=`*(ih: Tabs_t, value: string) {.cdecl.} =
    # SHOWCLOSE [Windows and GTK Only] (non inheritable): enables the
    # close button on each tab. Default value: "NO". In Windows the
    # close button imply the classic visual for the control. By
    # default when closed the tab is hidden. To change that behavior
    # use the TABCLOSE_CB callback. (since 3.10)
    SetAttribute(cast[PIhandle](ih), cstring("SHOWCLOSE"), cstring(value))

proc `showclose`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWCLOSE"), cstring(value))

proc `showclose=`*(ih: Tabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWCLOSE"), cstring((if yes: "YES" else: "NO")))

proc `showclose`*(ih: Tabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWCLOSE"), cstring((if yes: "YES" else: "NO")))

proc `showclose`*(ih: Tabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWCLOSE")) == "YES"

proc `size=`*(ih: Tabs_t, value: string) {.cdecl.} =
    # SIZE (non inheritable): The default size is the smallest size
    # that fits its largest child. All child elements are considered
    # even invisible ones.
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Tabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Tabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

# TODO getter tabs TABIMAGE
proc `taborientation=`*(ih: Tabs_t, value: string) {.cdecl.} =
    # TABORIENTATION (non inheritable): Indicates the orientation of
    # tab text, which can be "HORIZONTAL" or "VERTICAL". Default is
    # "HORIZONTAL". VERTICAL is supported only in GTK and in Windows.
    # In Windows, it can NOT be set, it is dependent on the TABTYPE
    # attribute, if TABTYPE=LEFT or TABTYPE=RIGHT then
    # TABORIENTATION=VERTICAL, if TABTYPE=TOP or TABTYPE=BOTTOM then
    # TABORIENTATION=HORIZONTAL. (GTK 2.6)
    SetAttribute(cast[PIhandle](ih), cstring("TABORIENTATION"), cstring(value))

proc `taborientation`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TABORIENTATION"), cstring(value))

proc `taborientation`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABORIENTATION"))

# TODO unknown: tabs TABPADDING Unknown Binary
proc `tabpadding`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABPADDING"))

# TODO getter tabs TABTITLE
proc `tabtype=`*(ih: Tabs_t, value: string) {.cdecl.} =
    # TABTYPE (non inheritable) (creation only in Windows): Indicates
    # the type of tab, which can be "TOP", "BOTTOM", "LEFT" or
    # "RIGHT". Default is "TOP". In Windows, if LEFT or RIGHT then
    # MULTILINE=YES and TABORIENTATION=VERTICAL are set, if TOP or
    # BOTTOM then TABORIENTATION=HORIZONTAL is set. In Windows, when
    # not TOP, then visual style is removed from tabs. In Windows, the
    # Visual Styles work only when TABTYPE is TOP. Windows Classic
    # Windows w/ Styles
    SetAttribute(cast[PIhandle](ih), cstring("TABTYPE"), cstring(value))

proc `tabtype`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TABTYPE"), cstring(value))

proc `tabtype`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABTYPE"))

# TODO getter tabs TABVISIBLE
proc `theme=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary tabs
proc `theme`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary tabs
proc `tip`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: Tabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Tabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: Tabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Tabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: Tabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Tabs_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary tabs
proc `tipicon`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary tabs
proc `tipmarkup`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: Tabs_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Tabs_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: Tabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Tabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Tabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `usersize=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Tabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Tabs_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: Tabs_t, value: string) {.cdecl.} =
    # VALUE (non inheritable): Changes the current tab by its name.
    # The value passed must be the name of one of the elements
    # contained in the tabs. Use IupSetHandle or IupSetAttributeHandle
    # to associate a child to a name. In Lua you can also use the
    # element reference directly.
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

# TODO ??? String Binary tabs
proc `value`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `valuepos=`*(ih: Tabs_t, value: string) {.cdecl.} =
    # VALUEPOS (non inheritable): Changes the current tab by its
    # position, starting at 0. When the tabs is created, the first
    # element inserted is set as the visible child. In GTK, inside the
    # callback the returned value is still the previous one. (since
    # 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("VALUEPOS"), cstring(value))

proc `valuepos`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUEPOS"), cstring(value))

proc `valuepos=`*(ih: Tabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUEPOS"), cstring(&"{x}"))

proc `valuepos`*(ih: Tabs_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUEPOS"), cstring(&"{x}"))

proc `valuepos`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUEPOS"))

proc `value_handle=`*(ih: Tabs_t, handle: User_t) {.cdecl.} =
    # VALUE_HANDLE (non inheritable): Changes the current tab by its
    # handle. The value passed must be the handle of a child contained
    # in the tabs. When the tabs is created, the first element
    # inserted is set as the visible child. (since 3.0)
    SetAttributeHandle(cast[PIhandle](ih), cstring("VALUE_HANDLE"), cast[PIhandle](handle))

proc `value_handle`*(ih: Tabs_t, handle: User_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("VALUE_HANDLE"), cast[PIhandle](handle))

proc `value_handle`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE_HANDLE"))

proc `visible=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Tabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Tabs_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Tabs_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

# TODO unknown: tabs XFONTID Unknown Binary
proc `xfontid`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `y`*(ih: Tabs_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `zorder=`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: Tabs_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `destroy_cb=`*(ih: Tabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Tabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Tabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `enterwindow_cb=`*(ih: Tabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Tabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Tabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `focus_cb=`*(ih: Tabs_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    # FOCUS_CB: Called when a child of the container gets or looses
    # the focus. It is called only if PROPAGATEFOCUS is defined in the
    # child. (since 3.23) int function(Ihandle *ih, int focus); [in
    # C]ih:focus_cb(focus: number) -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: Tabs_t, cb: proc (ih: PIhandle, focus: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("FOCUS_CB"), cast[Icallback](cb))

proc `focus_cb`*(ih: Tabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("FOCUS_CB")))

proc `getfocus_cb=`*(ih: Tabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Tabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Tabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: Tabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Tabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Tabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `killfocus_cb=`*(ih: Tabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Tabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Tabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: Tabs_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Tabs_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Tabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: Tabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Tabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Tabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: Tabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Tabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Tabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: Tabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Tabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Tabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: Tabs_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Tabs_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Tabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `rightclick_cb=`*(ih: Tabs_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # RIGHTCLICK_CB: Callback called when the user clicks on some tab
    # using the right mouse button (since 3.10). int function(Ihandle*
    # ih, int pos); [in C] ih:rightclick_cb(pos: number) -> (ret:
    # number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("RIGHTCLICK_CB"), cast[Icallback](cb))

proc `rightclick_cb`*(ih: Tabs_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RIGHTCLICK_CB"), cast[Icallback](cb))

proc `rightclick_cb`*(ih: Tabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RIGHTCLICK_CB")))

proc `tabchangepos_cb=`*(ih: Tabs_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    # TABCHANGEPOS_CB: Callback called when the user changes the
    # current tab. Called only when TABCHANGE_CB is not defined.
    # (since 3.3) int function(Ihandle* ih, int new_pos, int old_pos);
    # [in C] ih:tabchange_cb(new_pos, old_pos: number) -> (ret:
    # number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("TABCHANGEPOS_CB"), cast[Icallback](cb))

proc `tabchangepos_cb`*(ih: Tabs_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("TABCHANGEPOS_CB"), cast[Icallback](cb))

proc `tabchangepos_cb`*(ih: Tabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("TABCHANGEPOS_CB")))

proc `tabchange_cb=`*(ih: Tabs_t, cb: proc (ih: PIhandle, arg2: PIhandle, arg3: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # TABCHANGE_CB: Callback called when the user changes the current
    # tab. It is not called when the current tab is programmatically
    # changed or removed. int function(Ihandle* ih, Ihandle* new_tab,
    # Ihandle* old_tab); [in C] ih:tabchange_cb(new_tab, old_tab:
    # ihandle) -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("TABCHANGE_CB"), cast[Icallback](cb))

proc `tabchange_cb`*(ih: Tabs_t, cb: proc (ih: PIhandle, arg2: PIhandle, arg3: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("TABCHANGE_CB"), cast[Icallback](cb))

proc `tabchange_cb`*(ih: Tabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("TABCHANGE_CB")))

proc `tabclose_cb=`*(ih: Tabs_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    # TABCLOSE_CB [Windows and GTK Only]: Callback called when the
    # user clicks on the close button (since 3.10). Called only when
    # SHOWCLOSE=Yes. int function(Ihandle* ih, int pos); [in C]
    # ih:tabclose_cb(pos: number) -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("TABCLOSE_CB"), cast[Icallback](cb))

proc `tabclose_cb`*(ih: Tabs_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("TABCLOSE_CB"), cast[Icallback](cb))

proc `tabclose_cb`*(ih: Tabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("TABCLOSE_CB")))

proc `unmap_cb=`*(ih: Tabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Tabs_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Tabs_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc Text*(action: string): Text_t {.cdecl.} =
    # Creates an editable text field.
    return Text_t(niupc.Text(cstring(action)))

proc Text*(): Text_t {.cdecl.} =
    # Creates an editable text field.
    return Text_t(niupc.Text(nil))

proc `active=`*(ih: Text_t, value: string) {.cdecl.} =
    # ACTIVE, FONT, EXPAND, SCREENPOSITION, POSITION, MINSIZE,
    # MAXSIZE, WID, TIP, RASTERSIZE, ZORDER, VISIBLE, THEME: also
    # accepted.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `addformattag=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ADDFORMATTAG"), cstring(value))

proc `addformattag`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ADDFORMATTAG"), cstring(value))

# TODO ??? String Binary text
proc `addformattag`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ADDFORMATTAG"))

proc `addformattag_handle=`*(ih: Text_t, handle: User_t) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ADDFORMATTAG_HANDLE"), cstring(cast[cstring](handle)))

proc `addformattag_handle`*(ih: Text_t, handle: User_t) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ADDFORMATTAG_HANDLE"), cstring(cast[cstring](handle)))

proc `addformattag_handle`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ADDFORMATTAG_HANDLE"))

proc `alignment=`*(ih: Text_t, value: string) {.cdecl.} =
    # ALIGNMENT [Windows and GTK Only] (non inheritable): horizontal
    # text alignment. Possible values: "ALEFT", "ARIGHT", "ACENTER".
    # Default: "ALEFT". In Motif, text is always left aligned.
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"))

proc `append=`*(ih: Text_t, value: string) {.cdecl.} =
    # APPEND (write-only): Inserts a text at the end of the current
    # text. In the Multiline, if APPENDNEWLINE=YES, a "\n" character
    # will be automatically inserted before the appended text if the
    # current text is not empty(APPENDNEWLINE default is YES). Ignored
    # if set before map.
    SetAttribute(cast[PIhandle](ih), cstring("APPEND"), cstring(value))

proc `append`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("APPEND"), cstring(value))

# TODO ??? String Binary text
proc `appendnewline=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("APPENDNEWLINE"), cstring(value))

proc `appendnewline`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("APPENDNEWLINE"), cstring(value))

proc `appendnewline=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("APPENDNEWLINE"), cstring((if yes: "YES" else: "NO")))

proc `appendnewline`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("APPENDNEWLINE"), cstring((if yes: "YES" else: "NO")))

proc `appendnewline`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("APPENDNEWLINE")) == "YES"

proc `autohide=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOHIDE"), cstring(value))

proc `autohide`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOHIDE"), cstring(value))

proc `autohide=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `autohide`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("AUTOHIDE"), cstring((if yes: "YES" else: "NO")))

proc `autohide`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("AUTOHIDE")) == "YES"

proc `bgcolor=`*(ih: Text_t, value: string) {.cdecl.} =
    # BGCOLOR: Background color of the text. Default: the global
    # attribute TXTBGCOLOR. Ignored in GTK when MULTILINE=NO.
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: Text_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Text_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `border=`*(ih: Text_t, value: string) {.cdecl.} =
    # BORDER (creation only): Shows a border around the text. Default:
    # "YES".
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring(value))

proc `border=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BORDER"), cstring((if yes: "YES" else: "NO")))

proc `border`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BORDER")) == "YES"

proc `canfocus=`*(ih: Text_t, value: string) {.cdecl.} =
    # CANFOCUS (creation only) (non inheritable): enables the focus
    # traversal of the control. In Windows the control will still get
    # the focus when clicked. Default: YES. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `caret=`*(ih: Text_t, value: string) {.cdecl.} =
    # CARET (non inheritable): Character position of the insertion
    # point. Its format depends in MULTILINE=YES. The first position,
    # lin or col, is "1".
    SetAttribute(cast[PIhandle](ih), cstring("CARET"), cstring(value))

proc `caret`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CARET"), cstring(value))

proc `caret=`*(ih: Text_t, lin, col:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CARET"), cstring(&"{lin},{col}"))

proc `caret`*(ih: Text_t, lin, col:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CARET"), cstring(&"{lin},{col}"))

proc `caret`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CARET"))

proc `caretpos=`*(ih: Text_t, value: string) {.cdecl.} =
    # CARETPOS (non inheritable): Also the character position of the
    # insertion point, but using a zero based character unique index
    # "pos". Useful for indexing the VALUE string. See the Notes below
    # if using UTF-8 strings in GTK. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("CARETPOS"), cstring(value))

proc `caretpos`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CARETPOS"), cstring(value))

proc `caretpos=`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CARETPOS"), cstring(&"{x}"))

proc `caretpos`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CARETPOS"), cstring(&"{x}"))

proc `caretpos`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CARETPOS"))

proc `changecase=`*(ih: Text_t, value: string) {.cdecl.} =
    # CHANGECASE (non inheritable): Change case according to given
    # conversion. Can be UPPER, LOWER, TOGGLE, or TITLE. TITLE case
    # change first letter of words separated by spaces to upper case
    # others to lower case, but first letter is changed only if word
    # has more than 3 characters, for instance: "Best of the World".
    # Supports Latin-1 encoding only, even when using UTF-8. Does not
    # depends on current locale. (since 3.28)
    SetAttribute(cast[PIhandle](ih), cstring("CHANGECASE"), cstring(value))

proc `changecase`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHANGECASE"), cstring(value))

proc `charsize`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `clipboard=`*(ih: Text_t, value: string) {.cdecl.} =
    # CLIPBOARD (write-only): clear, cut, copy or paste the selection
    # to or from the clipboard. Values: "CLEAR", "CUT", "COPY" or
    # "PASTE". In Windows UNDO is also available, and REDO is
    # available when FORMATTING=YES. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("CLIPBOARD"), cstring(value))

proc `clipboard`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLIPBOARD"), cstring(value))

proc `clipboard`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIPBOARD"))

proc `count`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("COUNT"))

proc `cpadding=`*(ih: Text_t, value: string) {.cdecl.} =
    # CPADDING: same as PADDING but using the units of the SIZE
    # attribute. It will actually set the PADDING attribute. (since
    # 3.29)
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding=`*(ih: Text_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: Text_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CPADDING"))

proc `cuebanner=`*(ih: Text_t, value: string) {.cdecl.} =
    # CUEBANNER [Windows and GTK Only] (non inheritable): a text that
    # is displayed when there is no text at the control. It works as a
    # textual cue, or tip to prompt the user for input. Valid only for
    # MULTILINE=NO, and works only when Visual Styles are enabled.
    # (since 3.0) [GTK 3.2] (GTK support added in IUP 3.20)
    SetAttribute(cast[PIhandle](ih), cstring("CUEBANNER"), cstring(value))

proc `cuebanner`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CUEBANNER"), cstring(value))

# TODO ??? String Binary text
proc `cuebanner`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CUEBANNER"))

proc `dragdrop=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragsource=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary text
proc `dragtypes`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

proc `dropfilestarget=`*(ih: Text_t, value: string) {.cdecl.} =
    # DROPFILESTARGET [Windows and GTK Only] (non inheritable): Enable
    # or disable the drop of files. Default: NO, but if DROPFILES_CB
    # is defined when the element is mapped then it will be
    # automatically enabled. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary text
proc `droptypes`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `expand=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Text_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Text_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `fgcolor=`*(ih: Text_t, value: string) {.cdecl.} =
    # FGCOLOR: Text color. Default: the global attribute TXTFGCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: Text_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: Text_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

proc `filter=`*(ih: Text_t, value: string) {.cdecl.} =
    # FILTER [Windows Only] (non inheritable): allows a custom filter
    # to process the characters: Can be LOWERCASE, UPPERCASE or NUMBER
    # (only numbers allowed). (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("FILTER"), cstring(value))

proc `filter`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FILTER"), cstring(value))

proc `filter`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FILTER"))

proc `floating=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary text
proc `font`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary text
proc `fontface`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary text
proc `fontstyle`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `formatting=`*(ih: Text_t, value: string) {.cdecl.} =
    # FORMATTING [Windows and GTK Only] (non inheritable): When
    # enabled allow the use of text formatting attributes. In GTK is
    # always enabled, but only when MULTILINE=YES. Default: NO. (since
    # 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("FORMATTING"), cstring(value))

proc `formatting`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FORMATTING"), cstring(value))

proc `formatting=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FORMATTING"), cstring((if yes: "YES" else: "NO")))

proc `formatting`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FORMATTING"), cstring((if yes: "YES" else: "NO")))

proc `formatting`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FORMATTING")) == "YES"

proc `handlename=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary text
proc `handlename`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

# TODO unknown: text INSERT Unknown Binary
proc `linecount`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINECOUNT"))

proc `linevalue`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LINEVALUE"))

proc `mask=`*(ih: Text_t, value: string) {.cdecl.} =
    # MASK (non inheritable): Defines a mask that will filter
    # interactive text input.
    SetAttribute(cast[PIhandle](ih), cstring("MASK"), cstring(value))

proc `mask`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASK"), cstring(value))

# TODO ??? String Binary text
proc `mask`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASK"))

proc `maskcasei=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKCASEI"), cstring(value))

proc `maskcasei`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKCASEI"), cstring(value))

proc `maskcasei=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKCASEI"), cstring((if yes: "YES" else: "NO")))

proc `maskcasei`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKCASEI"), cstring((if yes: "YES" else: "NO")))

proc `maskcasei`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASKCASEI")) == "YES"

proc `maskdecimalsymbol=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKDECIMALSYMBOL"), cstring(value))

proc `maskdecimalsymbol`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKDECIMALSYMBOL"), cstring(value))

# TODO ??? String Binary text
proc `maskdecimalsymbol`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASKDECIMALSYMBOL"))

proc `maskfloat=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKFLOAT"), cstring(value))

proc `maskfloat`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKFLOAT"), cstring(value))

proc `maskfloat=`*(ih: Text_t, min, max:float) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKFLOAT"), cstring(&"{min},{max}"))

proc `maskfloat`*(ih: Text_t, min, max:float) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKFLOAT"), cstring(&"{min},{max}"))

proc `maskfloat`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASKFLOAT"))

proc `maskint=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKINT"), cstring(value))

proc `maskint`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKINT"), cstring(value))

proc `maskint=`*(ih: Text_t, min, max:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKINT"), cstring(&"{min},{max}"))

proc `maskint`*(ih: Text_t, min, max:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKINT"), cstring(&"{min},{max}"))

proc `maskint`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASKINT"))

proc `masknoempty=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKNOEMPTY"), cstring(value))

proc `masknoempty`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKNOEMPTY"), cstring(value))

proc `masknoempty=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKNOEMPTY"), cstring((if yes: "YES" else: "NO")))

proc `masknoempty`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKNOEMPTY"), cstring((if yes: "YES" else: "NO")))

proc `masknoempty`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASKNOEMPTY")) == "YES"

proc `maskreal=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKREAL"), cstring(value))

proc `maskreal`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MASKREAL"), cstring(value))

proc `maskreal`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MASKREAL"))

proc `maxsize=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Text_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Text_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Text_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Text_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `multiline=`*(ih: Text_t, value: string) {.cdecl.} =
    # MULTILINE (creation only) (non inheritable): allows the edition
    # of multiple lines. In single line mode some characters are
    # invalid, like "\t", "\r" and "\n". Default: NO. When set to Yes
    # will also reset the SCROLLBAR attribute to Yes. The values ALL
    # and NONE are also accepted independently of MULTILINE (since
    # 3.0).
    SetAttribute(cast[PIhandle](ih), cstring("MULTILINE"), cstring(value))

proc `multiline`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MULTILINE"), cstring(value))

proc `multiline=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MULTILINE"), cstring((if yes: "YES" else: "NO")))

proc `multiline`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MULTILINE"), cstring((if yes: "YES" else: "NO")))

proc `multiline`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MULTILINE")) == "YES"

proc `name=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary text
proc `name`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `nc=`*(ih: Text_t, value: string) {.cdecl.} =
    # NC: Maximum number of characters allowed for keyboard input,
    # larger text can still be set using attributes. The maximum value
    # is the limit of the VALUE attribute. The "0" value is the same
    # as maximum. Default: maximum.
    SetAttribute(cast[PIhandle](ih), cstring("NC"), cstring(value))

proc `nc`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NC"), cstring(value))

proc `nc=`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NC"), cstring(&"{x}"))

proc `nc`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NC"), cstring(&"{x}"))

proc `nc`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NC"))

proc `normalizergroup=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary text
proc `normalizergroup`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary text
proc `ntheme`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `overwrite=`*(ih: Text_t, value: string) {.cdecl.} =
    # OVERWRITE [Windows and GTK Only] (non inheritable): turns the
    # overwrite mode ON or OFF. Works only when FORMATTING=YES. (since
    # 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("OVERWRITE"), cstring(value))

proc `overwrite`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OVERWRITE"), cstring(value))

proc `overwrite=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OVERWRITE"), cstring((if yes: "YES" else: "NO")))

proc `overwrite`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("OVERWRITE"), cstring((if yes: "YES" else: "NO")))

proc `overwrite`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("OVERWRITE")) == "YES"

proc `padding=`*(ih: Text_t, value: string) {.cdecl.} =
    # PADDING: internal margin. Works just like the MARGIN attribute
    # of the IupHbox and IupVbox containers, but uses a different name
    # to avoid inheritance problems. Default value: "0x0". In Windows,
    # only the horizontal value is used. (since 3.0) (GTK 2.10 for
    # single line)
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding=`*(ih: Text_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: Text_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PADDING"))

# TODO unknown: text PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: text PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `password=`*(ih: Text_t, value: string) {.cdecl.} =
    # PASSWORD (creation only) [Windows and GTK Only] (non
    # inheritable): Hide the typed character using an "*". Default:
    # "NO".
    SetAttribute(cast[PIhandle](ih), cstring("PASSWORD"), cstring(value))

proc `password`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PASSWORD"), cstring(value))

proc `password=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PASSWORD"), cstring((if yes: "YES" else: "NO")))

proc `password`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PASSWORD"), cstring((if yes: "YES" else: "NO")))

proc `password`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PASSWORD")) == "YES"

proc `position=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Text_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Text_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Text_t, value: string) {.cdecl.} =
    # PROPAGATEFOCUS(non inheritable): enables the focus callback
    # forwarding to the next native parent with FOCUS_CB defined.
    # Default: NO. (since 3.23)
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Text_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Text_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `readonly=`*(ih: Text_t, value: string) {.cdecl.} =
    # READONLY: Allows the user only to read the contents, without
    # changing it. Restricts keyboard input only, text value can still
    # be changed using attributes. Navigation keys are still
    # available. Possible values: "YES", "NO". Default: NO.
    SetAttribute(cast[PIhandle](ih), cstring("READONLY"), cstring(value))

proc `readonly`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("READONLY"), cstring(value))

proc `readonly=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("READONLY"), cstring((if yes: "YES" else: "NO")))

proc `readonly`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("READONLY"), cstring((if yes: "YES" else: "NO")))

proc `readonly`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("READONLY")) == "YES"

proc `removeformatting=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("REMOVEFORMATTING"), cstring(value))

proc `removeformatting`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("REMOVEFORMATTING"), cstring(value))

proc `screenposition`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `scrollbar=`*(ih: Text_t, value: string) {.cdecl.} =
    # SCROLLBAR (creation only): Valid only when MULTILINE=YES.
    # Associates an automatic horizontal and/or vertical scrollbar to
    # the multiline. Can be: "VERTICAL", "HORIZONTAL", "YES" (both) or
    # "NO" (none). Default: "YES". For all systems, when SCROLLBAR!=NO
    # the natural size will always include its size even if the native
    # system hides the scrollbar. If AUTOHIDE=YES scrollbars are
    # visible only if they are necessary, by default AUTOHIDE=NO. In
    # Windows when FORMATTING=NO, AUTOHIDE is not supported. In Motif
    # AUTOHIDE is not supported.
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring(value))

proc `scrollbar=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR"), cstring((if yes: "YES" else: "NO")))

proc `scrollbar`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCROLLBAR")) == "YES"

proc `scrollto=`*(ih: Text_t, value: string) {.cdecl.} =
    # SCROLLTO (non inheritable, write only): Scroll the text to make
    # the given character position visible. It uses the same format
    # and reference of the CARET attribute ("lin:col" or "col"
    # starting at 1). In Windows, when FORMATTING=Yes "col" is
    # ignored. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTO"), cstring(value))

proc `scrollto`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTO"), cstring(value))

proc `scrollto=`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTO"), cstring(&"{x}"))

proc `scrollto`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTO"), cstring(&"{x}"))

proc `scrolltopos=`*(ih: Text_t, value: string) {.cdecl.} =
    # SCROLLTOPOS (non inheritable, write only): Scroll the text to
    # make the given character position visible. It uses the same
    # format and reference of the CARETPOS attribute ("pos" starting
    # at 0). (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTOPOS"), cstring(value))

proc `scrolltopos`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTOPOS"), cstring(value))

proc `scrolltopos=`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTOPOS"), cstring(&"{x}"))

proc `scrolltopos`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SCROLLTOPOS"), cstring(&"{x}"))

proc `selectedtext=`*(ih: Text_t, value: string) {.cdecl.} =
    # SELECTEDTEXT (non inheritable): Selection text. Returns NULL if
    # there is no selection. When changed replaces the current
    # selection. Similar to INSERT, but does nothing if there is no
    # selection.
    SetAttribute(cast[PIhandle](ih), cstring("SELECTEDTEXT"), cstring(value))

proc `selectedtext`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTEDTEXT"), cstring(value))

# TODO ??? String Binary text
proc `selectedtext`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SELECTEDTEXT"))

proc `selection=`*(ih: Text_t, value: string) {.cdecl.} =
    # SELECTION (non inheritable): Selection interval in characters.
    # Returns NULL if there is no selection. Its format depends in
    # MULTILINE=YES. The first position, lin or col, is "1".
    SetAttribute(cast[PIhandle](ih), cstring("SELECTION"), cstring(value))

proc `selection`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTION"), cstring(value))

proc `selection=`*(ih: Text_t, lin1,col1,lin2,col2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTION"), cstring(&"{lin1},{col1}:{lin2},{col2}"))

proc `selection`*(ih: Text_t, lin1,col1,lin2,col2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTION"), cstring(&"{lin1},{col1}:{lin2},{col2}"))

proc `selection=`*(ih: Text_t, col1,col2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTION"), cstring(&"{col1}:{col2}"))

proc `selection`*(ih: Text_t, col1,col2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTION"), cstring(&"{col1}:{col2}"))

proc `selection`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SELECTION"))

proc `selectionpos=`*(ih: Text_t, value: string) {.cdecl.} =
    # SELECTIONPOS (non inheritable): Same as SELECTION but using a
    # zero based character index "pos1:pos2". Useful for indexing the
    # VALUE string. The values ALL and NONE are also accepted. See the
    # Notes below if using UTF-8 strings in GTK. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("SELECTIONPOS"), cstring(value))

proc `selectionpos`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTIONPOS"), cstring(value))

proc `selectionpos=`*(ih: Text_t, min, max:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTIONPOS"), cstring(&"{min},{max}"))

proc `selectionpos`*(ih: Text_t, min, max:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTIONPOS"), cstring(&"{min},{max}"))

proc `selectionpos`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SELECTIONPOS"))

proc `size=`*(ih: Text_t, value: string) {.cdecl.} =
    # SIZE (non inheritable): Since the contents can be changed by the
    # user, the Natural Size is not affected by the text contents
    # (since 3.0). Use VISIBLECOLUMNS and VISIBLELINES to control the
    # Natural Size.
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Text_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Text_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `spin=`*(ih: Text_t, value: string) {.cdecl.} =
    # SPIN (non inheritable, creation only): enables a spin control
    # attached to the element. Default: NO. The spin increments and
    # decrements an integer number. The editing in the element is
    # still available. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("SPIN"), cstring(value))

proc `spin`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPIN"), cstring(value))

proc `spin=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPIN"), cstring((if yes: "YES" else: "NO")))

proc `spin`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPIN"), cstring((if yes: "YES" else: "NO")))

proc `spin`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPIN")) == "YES"

proc `spinalign=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINALIGN"), cstring(value))

proc `spinalign`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINALIGN"), cstring(value))

proc `spinalign`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPINALIGN"))

proc `spinauto=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINAUTO"), cstring(value))

proc `spinauto`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINAUTO"), cstring(value))

proc `spinauto=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINAUTO"), cstring((if yes: "YES" else: "NO")))

proc `spinauto`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINAUTO"), cstring((if yes: "YES" else: "NO")))

proc `spinauto`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPINAUTO")) == "YES"

proc `spininc=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPININC"), cstring(value))

proc `spininc`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPININC"), cstring(value))

proc `spininc=`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPININC"), cstring(&"{x}"))

proc `spininc`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPININC"), cstring(&"{x}"))

proc `spininc`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPININC"))

proc `spinmax=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINMAX"), cstring(value))

proc `spinmax`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINMAX"), cstring(value))

proc `spinmax=`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINMAX"), cstring(&"{x}"))

proc `spinmax`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINMAX"), cstring(&"{x}"))

proc `spinmax`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPINMAX"))

proc `spinmin=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINMIN"), cstring(value))

proc `spinmin`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINMIN"), cstring(value))

proc `spinmin=`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINMIN"), cstring(&"{x}"))

proc `spinmin`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINMIN"), cstring(&"{x}"))

proc `spinmin`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPINMIN"))

proc `spinvalue=`*(ih: Text_t, value: string) {.cdecl.} =
    # SPINVALUE (non inheritable): the current value of the spin. The
    # value is limited to the minimum and maximum values. SPINMAX (non
    # inheritable): the maximum value. Default: 100. SPINMIN (non
    # inheritable): the minimum value. Default: 0. SPININC (non
    # inheritable): the increment value. Default: 1. SPINALIGN
    # (creation only): the position of the spin. Can be LEFT or RIGHT.
    # Default: RIGHT. In GTK is always RIGHT. SPINWRAP (creation
    # only): if the position reach a limit it continues from the
    # opposite limit. Default: NO. SPINAUTO (creation only): enables
    # the automatic update of the text contents. Default: YES. Use
    # SPINAUTO=NO and the VALUE attribute during SPIN_CB to control
    # the text contents when the spin is incremented.
    SetAttribute(cast[PIhandle](ih), cstring("SPINVALUE"), cstring(value))

proc `spinvalue`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINVALUE"), cstring(value))

proc `spinvalue=`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINVALUE"), cstring(&"{x}"))

proc `spinvalue`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINVALUE"), cstring(&"{x}"))

proc `spinvalue`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPINVALUE"))

proc `spinwrap=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINWRAP"), cstring(value))

proc `spinwrap`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINWRAP"), cstring(value))

proc `spinwrap=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINWRAP"), cstring((if yes: "YES" else: "NO")))

proc `spinwrap`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPINWRAP"), cstring((if yes: "YES" else: "NO")))

proc `spinwrap`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPINWRAP")) == "YES"

proc `tabsize=`*(ih: Text_t, value: string) {.cdecl.} =
    # TABSIZE [Windows and GTK Only]: Valid only when MULTILINE=YES.
    # Controls the number of characters for a tab stop. Default: 8.
    SetAttribute(cast[PIhandle](ih), cstring("TABSIZE"), cstring(value))

proc `tabsize`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TABSIZE"), cstring(value))

proc `tabsize=`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TABSIZE"), cstring(&"{x}"))

proc `tabsize`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TABSIZE"), cstring(&"{x}"))

proc `tabsize`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TABSIZE"))

proc `theme=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary text
proc `theme`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary text
proc `tip`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: Text_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Text_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: Text_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Text_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary text
proc `tipicon`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary text
proc `tipmarkup`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: Text_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Text_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `usersize=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Text_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Text_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: Text_t, value: string) {.cdecl.} =
    # VALUE (non inheritable): Text entered by the user. The '\n'
    # character indicates a new line, valid only when MULTILINE=YES.
    # After the element is mapped and if there is no text will return
    # the empty string "".
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

# TODO ??? String Binary text
proc `value`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `valuemasked=`*(ih: Text_t, value: string) {.cdecl.} =
    # VALUEMASKED (non inheritable) (write-only): sets VALUE but first
    # checks if it is validated by MASK. If not does nothing. (since
    # 3.4)
    SetAttribute(cast[PIhandle](ih), cstring("VALUEMASKED"), cstring(value))

proc `valuemasked`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUEMASKED"), cstring(value))

# TODO ??? String Binary text
proc `visible=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `visiblecolumns=`*(ih: Text_t, value: string) {.cdecl.} =
    # VISIBLECOLUMNS: Defines the number of visible columns for the
    # Natural Size, this means that will act also as minimum number of
    # visible columns. It uses a wider character size than the one
    # used for the SIZE attribute so strings will fit better without
    # the need of extra columns. As for SIZE you can set to NULL after
    # map to use it as an initial value. Default: 5 (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"), cstring(value))

proc `visiblecolumns`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"), cstring(value))

proc `visiblecolumns=`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"), cstring(&"{x}"))

proc `visiblecolumns`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"), cstring(&"{x}"))

proc `visiblecolumns`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLECOLUMNS"))

proc `visiblelines=`*(ih: Text_t, value: string) {.cdecl.} =
    # VISIBLELINES: When MULTILINE=YES defines the number of visible
    # lines for the Natural Size, this means that will act also as
    # minimum number of visible lines. As for SIZE you can set to NULL
    # after map to use it as an initial value. Default: 1 (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLELINES"), cstring(value))

proc `visiblelines`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLELINES"), cstring(value))

proc `visiblelines=`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLELINES"), cstring(&"{x}"))

proc `visiblelines`*(ih: Text_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLELINES"), cstring(&"{x}"))

proc `visiblelines`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLELINES"))

proc `wid`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `wordwrap=`*(ih: Text_t, value: string) {.cdecl.} =
    # WORDWRAP (creation only): Valid only when MULTILINE=YES. If
    # enabled will force a word wrap of lines that are greater than
    # the with of the control, and the horizontal scrollbar will be
    # removed. Default: NO.
    SetAttribute(cast[PIhandle](ih), cstring("WORDWRAP"), cstring(value))

proc `wordwrap`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WORDWRAP"), cstring(value))

proc `wordwrap=`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WORDWRAP"), cstring((if yes: "YES" else: "NO")))

proc `wordwrap`*(ih: Text_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WORDWRAP"), cstring((if yes: "YES" else: "NO")))

proc `wordwrap`*(ih: Text_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WORDWRAP")) == "YES"

proc `x`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

# TODO unknown: text XFONTID Unknown Binary
proc `xfontid`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `y`*(ih: Text_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `zorder=`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: Text_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: Text_t, cb: proc (ih: PIhandle, c: cint, new_value: cstring): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: Text_t, cb: proc (ih: PIhandle, c: cint, new_value: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `button_cb=`*(ih: Text_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: Text_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `caret_cb=`*(ih: Text_t, cb: proc (ih: PIhandle, lin, col,  pos: cint): cint {.cdecl.}) {.cdecl.} =
    # CARET_CB: Action generated when the caret/cursor position is
    # changed. int function(Ihandle *ih, int lin, int col, int pos);
    # [in C]ih:caret_cb(lin, col, pos: number) -> (ret: number) [in
    # Lua]
    SetCallback(cast[PIhandle](ih), cstring("CARET_CB"), cast[Icallback](cb))

proc `caret_cb`*(ih: Text_t, cb: proc (ih: PIhandle, lin, col,  pos: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("CARET_CB"), cast[Icallback](cb))

proc `caret_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("CARET_CB")))

proc `destroy_cb=`*(ih: Text_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Text_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: Text_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: Text_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: Text_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: Text_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: Text_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: Text_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragend_cb=`*(ih: Text_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: Text_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: Text_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: Text_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: Text_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: Text_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: Text_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: Text_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: Text_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Text_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `getfocus_cb=`*(ih: Text_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Text_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: Text_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Text_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `killfocus_cb=`*(ih: Text_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Text_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: Text_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Text_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: Text_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Text_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: Text_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Text_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: Text_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Text_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: Text_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: Text_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `postmessage_cb=`*(ih: Text_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Text_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `spin_cb=`*(ih: Text_t, cb: proc (ih: PIhandle, pos: cint): cint {.cdecl.}) {.cdecl.} =
    # SPIN_CB: Action generated when a spin button is pressed. Valid
    # only when SPIN=YES. When this callback is called the ACTION
    # callback is not called. The VALUE attribute can be changed
    # during this callback only if SPINAUTO=NO. (since 3.0) int
    # function(Ihandle *ih, int pos); [in C]ih:spin_cb(pos: number) ->
    # (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("SPIN_CB"), cast[Icallback](cb))

proc `spin_cb`*(ih: Text_t, cb: proc (ih: PIhandle, pos: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SPIN_CB"), cast[Icallback](cb))

proc `spin_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SPIN_CB")))

proc `unmap_cb=`*(ih: Text_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Text_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `valuechanged_cb=`*(ih: Text_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # VALUECHANGED_CB: Called after the value was interactively
    # changed by the user. (since 3.0) int function(Ihandle *ih); [in
    # C]ih:valuechanged_cb() -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: Text_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: Text_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB")))

proc Thread*(): Thread_t {.cdecl.} =
    # Creates a thread element in IUP, which is not associated to any
    # interface element. It is a very simple support to create and
    # manage threads in a multithread environment. It inherits from
    # IupUser. In non Windows systems uses the pthreads library.
    return Thread_t(niupc.Thread())

# TODO unknown: thread EXIT Unknown Binary
proc `iscurrent`*(ih: Thread_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ISCURRENT"))

# TODO unknown: thread JOIN Unknown Binary
# TODO unknown: thread LOCK Unknown Binary
proc `lock`*(ih: Thread_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LOCK"))

proc `start=`*(ih: Thread_t, value: string) {.cdecl.} =
    # START (write-only, non inheritable): starts the thread and calls
    # the callback. Can be YES only. The thread exits when the
    # callback is terminated.
    SetAttribute(cast[PIhandle](ih), cstring("START"), cstring(value))

proc `start`*(ih: Thread_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("START"), cstring(value))

proc `start=`*(ih: Thread_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("START"), cstring((if yes: "YES" else: "NO")))

proc `start`*(ih: Thread_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("START"), cstring((if yes: "YES" else: "NO")))

# TODO unknown: thread YIELD Unknown Binary
proc `thread_cb=`*(ih: Thread_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # THREAD_CB: Action generated when the thread is started. If this
    # callback returns or does not exist the thread is terminated. int
    # function(Ihandle* ih); [in C]ih:thread_cb() -> (ret: number) [in
    # Lua]
    SetCallback(cast[PIhandle](ih), cstring("THREAD_CB"), cast[Icallback](cb))

proc `thread_cb`*(ih: Thread_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("THREAD_CB"), cast[Icallback](cb))

proc `thread_cb`*(ih: Thread_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("THREAD_CB")))

proc Timer*(): Timer_t {.cdecl.} =
    # Creates a timer which periodically invokes a callback when the
    # time is up. Each timer should be destroyed using IupDestroy.
    return Timer_t(niupc.Timer())

# TODO unknown: timer RUN Unknown Binary
proc `run`*(ih: Timer_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RUN"))

# TODO unknown: timer TIME Unknown Binary
proc `time`*(ih: Timer_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIME"))

proc `wid`*(ih: Timer_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `run=`*(ih: Timer_t, yes: bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RUN"), cstring((if yes: "YES" else: "NO")))

proc `run`*(ih: Timer_t, yes: bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RUN"), cstring((if yes: "YES" else: "NO")))

proc `time=`*(ih: Timer_t, miliseconds: int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIME"), cstring(&"{miliseconds}"))

proc `time`*(ih: Timer_t, miliseconds: int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIME"), cstring(&"{miliseconds}"))

proc `action_cb=`*(ih: Timer_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ACTION_CB: Called every time the defined time interval is
    # reached. To stop the callback from being called simply stop de
    # timer with RUN=NO. Inside the callback the attribute ELAPSEDTIME
    # returns the time elapsed since the timer was started in
    # milliseconds (since 3.15). int function(Ihandle *ih); [in C]
    # ih:action_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed.
    SetCallback(cast[PIhandle](ih), cstring("ACTION_CB"), cast[Icallback](cb))

proc `action_cb`*(ih: Timer_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION_CB"), cast[Icallback](cb))

proc `action_cb`*(ih: Timer_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION_CB")))

proc Toggle*(title: string; action: string): Toggle_t {.cdecl.} =
    # Creates the toggle interface element. It is a two-state (on/off)
    # button that, when selected, generates an action that activates a
    # function in the associated application. Its visual
    # representation can contain a text or an image.
    return Toggle_t(niupc.Toggle(cstring(title), cstring(action)))

proc Toggle*(title: string): Toggle_t {.cdecl.} =
    # Creates the toggle interface element. It is a two-state (on/off)
    # button that, when selected, generates an action that activates a
    # function in the associated application. Its visual
    # representation can contain a text or an image.
    return Toggle_t(niupc.Toggle(title, nil))

proc `active=`*(ih: Toggle_t, value: string) {.cdecl.} =
    # ACTIVE, FONT, EXPAND, SCREENPOSITION, POSITION, MINSIZE,
    # MAXSIZE, WID, TIP, SIZE, RASTERSIZE, ZORDER, VISIBLE, THEME:
    # also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Toggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Toggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Toggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `alignment=`*(ih: Toggle_t, value: string) {.cdecl.} =
    # ALIGNMENT (non inheritable): horizontal and vertical alignment
    # when IMAGE is defined. Possible values: "ALEFT", "ACENTER" and
    # "ARIGHT", combined to "ATOP", "ACENTER" and "ABOTTOM". Default:
    # "ACENTER:ACENTER". Partial values are also accepted, like
    # "ARIGHT" or ":ATOP", the other value will be obtained from the
    # default value. In Motif, vertical alignment is restricted to
    # "ACENTER". In Windows works only when Visual Styles is active.
    # Text is always left aligned. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"))

proc `bgcolor=`*(ih: Toggle_t, value: string) {.cdecl.} =
    # BGCOLOR: Background color of toggle mark when displaying a text.
    # The text background is transparent, it will use the background
    # color of the native parent. When displaying an image in Windows
    # the background is ignored and the system color is used. Default:
    # the global attribute DLGBGCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: Toggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Toggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `canfocus=`*(ih: Toggle_t, value: string) {.cdecl.} =
    # CANFOCUS (creation only) (non inheritable): enables the focus
    # traversal of the control. In Windows the control will still get
    # the focus when clicked. Default: YES. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Toggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Toggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Toggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `expand=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Toggle_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Toggle_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `fgcolor=`*(ih: Toggle_t, value: string) {.cdecl.} =
    # FGCOLOR: Color of the text shown on the toggle. In Windows, when
    # using Visual Styles FGCOLOR is ignored. Default: the global
    # attribute DLGFGCOLOR.
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: Toggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: Toggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

proc `flat=`*(ih: Toggle_t, value: string) {.cdecl.} =
    # FLAT (creation only): Hides the toggle borders until the mouse
    # enter the toggle area when the toggle is not checked. If the
    # toggle is checked, then the borders will be shown even if flat
    # is enabled. Used only when IMAGE is defined. Can be YES or NO.
    # Default: NO. (since 3.3)
    SetAttribute(cast[PIhandle](ih), cstring("FLAT"), cstring(value))

proc `flat`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLAT"), cstring(value))

proc `flat=`*(ih: Toggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLAT"), cstring((if yes: "YES" else: "NO")))

proc `flat`*(ih: Toggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLAT"), cstring((if yes: "YES" else: "NO")))

proc `flat`*(ih: Toggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLAT")) == "YES"

proc `floating=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary toggle
proc `font`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary toggle
proc `fontface`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Toggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Toggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary toggle
proc `fontstyle`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary toggle
proc `handlename`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `ignoreradio=`*(ih: Toggle_t, value: string) {.cdecl.} =
    # IGNORERADIO (non inheritable): when set the toggle will not
    # behave as a radio when inside an IupRadio hierarchy. (since
    # 3.21)
    SetAttribute(cast[PIhandle](ih), cstring("IGNORERADIO"), cstring(value))

proc `ignoreradio`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("IGNORERADIO"), cstring(value))

proc `ignoreradio=`*(ih: Toggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("IGNORERADIO"), cstring((if yes: "YES" else: "NO")))

proc `ignoreradio`*(ih: Toggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("IGNORERADIO"), cstring((if yes: "YES" else: "NO")))

proc `ignoreradio`*(ih: Toggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IGNORERADIO")) == "YES"

proc `image=`*(ih: Toggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGE (non inheritable): Image name. When the IMAGE attribute is
    # defined, the TITLE is not shown. This makes the toggle looks
    # just like a button with an image, but its behavior remains the
    # same. Use IupSetHandle or IupSetAttributeHandle to associate an
    # image to a name. See also IupImage. (GTK 2.6)
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: Toggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGE"), cast[PIhandle](handle))

proc `image`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGE"))

proc `iminactive=`*(ih: Toggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMINACTIVE (non inheritable): Image name of the inactive toggle.
    # If it is not defined but IMAGE is defined then for inactive
    # toggles the colors will be replaced by a modified version of the
    # background color creating the disabled effect. (GTK 2.6)
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMINACTIVE"), cast[PIhandle](handle))

proc `iminactive`*(ih: Toggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMINACTIVE"), cast[PIhandle](handle))

proc `iminactive`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMINACTIVE"))

proc `impress=`*(ih: Toggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMPRESS (non inheritable): Image name of the pressed toggle.
    # Unlike buttons, toggles always display the button border when
    # IMAGE and IMPRESS are both defined. (GTK 2.6)
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMPRESS"), cast[PIhandle](handle))

proc `impress`*(ih: Toggle_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMPRESS"), cast[PIhandle](handle))

proc `impress`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMPRESS"))

proc `markup=`*(ih: Toggle_t, value: string) {.cdecl.} =
    # MARKUP [GTK only]: allows the title string to contains pango
    # markup commands. Works only if a mnemonic is NOT defined in the
    # title. Can be "YES" or "NO". Default: "NO".
    SetAttribute(cast[PIhandle](ih), cstring("MARKUP"), cstring(value))

proc `markup`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKUP"), cstring(value))

proc `markup=`*(ih: Toggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKUP"), cstring((if yes: "YES" else: "NO")))

proc `markup`*(ih: Toggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKUP"), cstring((if yes: "YES" else: "NO")))

proc `markup`*(ih: Toggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MARKUP")) == "YES"

proc `maxsize=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Toggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Toggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Toggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Toggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary toggle
proc `name`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary toggle
proc `normalizergroup`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary toggle
proc `ntheme`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `padding=`*(ih: Toggle_t, value: string) {.cdecl.} =
    # PADDING: internal margin when IMAGE is defined. Works just like
    # the MARGIN attribute of the IupHbox and IupVbox containers, but
    # uses a different name to avoid inheritance problems. Default
    # value: "0x0". Value can be DEFAULTBUTTONPADDING, so the global
    # attribute of this name will be used instead (since 3.29). (since
    # 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(value))

proc `padding=`*(ih: Toggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: Toggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PADDING"), cstring(&"{width}x{height}"))

proc `padding`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PADDING"))

# TODO unknown: toggle PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: toggle PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Toggle_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Toggle_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Toggle_t, value: string) {.cdecl.} =
    # PROPAGATEFOCUS(non inheritable): enables the focus callback
    # forwarding to the next native parent with FOCUS_CB defined.
    # Default: NO. (since 3.23)
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Toggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Toggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Toggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `radio`*(ih: Toggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RADIO")) == "YES"

proc `rastersize=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Toggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Toggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `rightbutton=`*(ih: Toggle_t, value: string) {.cdecl.} =
    # RIGHTBUTTON (Windows Only) (creation only): place the check
    # button at the right of the text. Can be "YES" or "NO". Default:
    # "NO".
    SetAttribute(cast[PIhandle](ih), cstring("RIGHTBUTTON"), cstring(value))

proc `rightbutton`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RIGHTBUTTON"), cstring(value))

proc `rightbutton=`*(ih: Toggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RIGHTBUTTON"), cstring((if yes: "YES" else: "NO")))

proc `rightbutton`*(ih: Toggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RIGHTBUTTON"), cstring((if yes: "YES" else: "NO")))

proc `rightbutton`*(ih: Toggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RIGHTBUTTON")) == "YES"

proc `screenposition`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

proc `size=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Toggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Toggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary toggle
proc `theme`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary toggle
proc `tip`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: Toggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Toggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: Toggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Toggle_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: Toggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Toggle_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary toggle
proc `tipicon`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary toggle
proc `tipmarkup`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: Toggle_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Toggle_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: Toggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Toggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Toggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `title=`*(ih: Toggle_t, value: string) {.cdecl.} =
    # TITLE (non inheritable): Toggle's text. If IMAGE is not defined
    # before map, then the default behavior is to contain a text. The
    # button behavior can not be changed after map. The natural size
    # will be larger enough to include all the text in the selected
    # font, even using multiple lines, plus the button borders or
    # check box if any. The '\n' character is accepted for line
    # change. The "&" character can be used to define a mnemonic, the
    # next character will be used as key. Use "&&" to show the "&"
    # character instead on defining a mnemonic. The toggle can be
    # activated from any control in the dialog using the "Alt+key"
    # combination. (mnemonic support since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

proc `title`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TITLE"), cstring(value))

# TODO ??? String Binary toggle
proc `title`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TITLE"))

proc `usersize=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Toggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Toggle_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: Toggle_t, value: string) {.cdecl.} =
    # VALUE (non inheritable): Toggle's state. Values can be "ON",
    # "OFF" or "TOGGLE". If 3STATE=YES then can also be "NOTDEF".
    # Default: "OFF". The TOGGLE option will invert the current state
    # (since 3.7). In GTK if you change the state of a radio, the
    # unchecked toggle will receive an ACTION callback notification.
    # Can only be set to ON if the toggle is inside a radio, it will
    # automatically set to OFF the previous toggle that was ON in the
    # radio.
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `visible=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Toggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Toggle_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Toggle_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

# TODO unknown: toggle XFONTID Unknown Binary
proc `xfontid`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `y`*(ih: Toggle_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `zorder=`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: Toggle_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `action=`*(ih: Toggle_t, cb: proc (ih: PIhandle, state: cint): cint {.cdecl.}) {.cdecl.} =
    # ACTION ACTION Action generated when the element is activated.
    # Affects each element differently. Callback int function(Ihandle
    # *ih); [in C] ih:action() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. In some
    # elements, this callback may receive more parameters, apart from
    # ih. Please refer to each element's documentation. Affects
    # IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    # IupToggle
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: Toggle_t, cb: proc (ih: PIhandle, state: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ACTION"), cast[Icallback](cb))

proc `action`*(ih: Toggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ACTION")))

proc `destroy_cb=`*(ih: Toggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Toggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Toggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `enterwindow_cb=`*(ih: Toggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Toggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Toggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `getfocus_cb=`*(ih: Toggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Toggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Toggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: Toggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Toggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Toggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `killfocus_cb=`*(ih: Toggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Toggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Toggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: Toggle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Toggle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Toggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: Toggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Toggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Toggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: Toggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Toggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Toggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: Toggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Toggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Toggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: Toggle_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Toggle_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Toggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: Toggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Toggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Toggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `valuechanged_cb=`*(ih: Toggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # VALUECHANGED_CB: Called after the value was interactively
    # changed by the user. Called after the ACTION callback, but under
    # the same context. (since 3.0) int function(Ihandle *ih); [in
    # C]ih:valuechanged_cb() -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: Toggle_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: Toggle_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB")))

proc Tree*(): Tree_t {.cdecl.} =
    # Creates a tree containing nodes of branches or leaves. Both
    # branches and leaves can have an associated text and image. The
    # branches can be expanded or collapsed. When a branch is
    # expanded, its immediate children are visible, and when it is
    # collapsed they are hidden. The leaves can generate an "executed"
    # or "renamed" actions, branches can only generate a "renamed"
    # action. The focus node is the node with the focus rectangle,
    # marked nodes have their background inverted.
    return Tree_t(niupc.Tree())

proc `active=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Tree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

# TODO getter tree ADDBRANCH
proc `addexpanded=`*(ih: Tree_t, value: string) {.cdecl.} =
    # ADDEXPANDED ADDROOT ADDLEAF ADDBRANCH COPYNODE DELNODE EXPANDALL
    # INSERTLEAF INSERTBRANCH MOVENODE
    SetAttribute(cast[PIhandle](ih), cstring("ADDEXPANDED"), cstring(value))

proc `addexpanded`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ADDEXPANDED"), cstring(value))

proc `addexpanded=`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ADDEXPANDED"), cstring((if yes: "YES" else: "NO")))

proc `addexpanded`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ADDEXPANDED"), cstring((if yes: "YES" else: "NO")))

proc `addexpanded`*(ih: Tree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ADDEXPANDED")) == "YES"

# TODO getter tree ADDLEAF
# TODO unknown: tree ADDROOT Unknown Binary
proc `addroot`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ADDROOT"))

proc `bgcolor=`*(ih: Tree_t, value: string) {.cdecl.} =
    # AUTOREDRAW BGCOLOR COUNT EXPAND FGCOLOR INDENTATION RASTERSIZE
    # SPACING TOPITEM
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: Tree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Tree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `canfocus=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Tree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

# TODO getter tree CHILDCOUNT
# TODO getter tree COLOR
# TODO getter tree COPYNODE
proc `count`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("COUNT"))

proc `cpadding=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(value))

proc `cpadding=`*(ih: Tree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: Tree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CPADDING"), cstring(&"{width}x{height}"))

proc `cpadding`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CPADDING"))

proc `cspacing=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(value))

proc `cspacing`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(value))

proc `cspacing=`*(ih: Tree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(&"{x}"))

proc `cspacing`*(ih: Tree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CSPACING"), cstring(&"{x}"))

proc `cspacing`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CSPACING"))

# TODO unknown: tree CTRL Unknown Binary
proc `ctrl`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CTRL"))

# TODO getter tree DELNODE
# TODO getter tree DEPTH
proc `dragdrop=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring(value))

proc `dragdrop=`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `dragdrop`*(ih: Tree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROP")) == "YES"

proc `dragdroptree=`*(ih: Tree_t, value: string) {.cdecl.} =
    # DRAGDROPTREE DROPFILESTARGET DROPEQUALDRAG SHOWDRAGDROP
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROPTREE"), cstring(value))

proc `dragdroptree`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROPTREE"), cstring(value))

proc `dragdroptree=`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROPTREE"), cstring((if yes: "YES" else: "NO")))

proc `dragdroptree`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGDROPTREE"), cstring((if yes: "YES" else: "NO")))

proc `dragdroptree`*(ih: Tree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGDROPTREE")) == "YES"

proc `dragsource=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring(value))

proc `dragsource=`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE"), cstring((if yes: "YES" else: "NO")))

proc `dragsource`*(ih: Tree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCE")) == "YES"

proc `dragsourcemove=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring(value))

proc `dragsourcemove=`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE"), cstring((if yes: "YES" else: "NO")))

proc `dragsourcemove`*(ih: Tree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGSOURCEMOVE")) == "YES"

proc `dragtypes=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

proc `dragtypes`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"), cstring(value))

# TODO ??? String Binary tree
proc `dragtypes`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DRAGTYPES"))

proc `dropequaldrag=`*(ih: Tree_t, value: string) {.cdecl.} =
    # DRAGDROPTREE DROPFILESTARGET DROPEQUALDRAG SHOWDRAGDROP
    SetAttribute(cast[PIhandle](ih), cstring("DROPEQUALDRAG"), cstring(value))

proc `dropequaldrag`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPEQUALDRAG"), cstring(value))

proc `dropequaldrag=`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPEQUALDRAG"), cstring((if yes: "YES" else: "NO")))

proc `dropequaldrag`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPEQUALDRAG"), cstring((if yes: "YES" else: "NO")))

proc `dropequaldrag`*(ih: Tree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPEQUALDRAG")) == "YES"

proc `dropfilestarget=`*(ih: Tree_t, value: string) {.cdecl.} =
    # DRAGDROPTREE DROPFILESTARGET DROPEQUALDRAG SHOWDRAGDROP
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring(value))

proc `dropfilestarget=`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET"), cstring((if yes: "YES" else: "NO")))

proc `dropfilestarget`*(ih: Tree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPFILESTARGET")) == "YES"

proc `droptarget=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring(value))

proc `droptarget=`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTARGET"), cstring((if yes: "YES" else: "NO")))

proc `droptarget`*(ih: Tree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTARGET")) == "YES"

proc `droptypes=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

proc `droptypes`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"), cstring(value))

# TODO ??? String Binary tree
proc `droptypes`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("DROPTYPES"))

proc `expand=`*(ih: Tree_t, value: string) {.cdecl.} =
    # AUTOREDRAW BGCOLOR COUNT EXPAND FGCOLOR INDENTATION RASTERSIZE
    # SPACING TOPITEM
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandall=`*(ih: Tree_t, ) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDALL"), cstring(""))

proc `expandall`*(ih: Tree_t, ) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDALL"), cstring(""))

proc `expandweight=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Tree_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Tree_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `fgcolor=`*(ih: Tree_t, value: string) {.cdecl.} =
    # AUTOREDRAW BGCOLOR COUNT EXPAND FGCOLOR INDENTATION RASTERSIZE
    # SPACING TOPITEM
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(value))

proc `fgcolor=`*(ih: Tree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: Tree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `fgcolor`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"))

# TODO getter tree FIRST
proc `floating=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary tree
proc `font`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary tree
proc `fontface`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Tree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Tree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary tree
proc `fontstyle`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary tree
proc `handlename`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `hidebuttons=`*(ih: Tree_t, value: string) {.cdecl.} =
    # HIDELINES HIDEBUTTONS
    SetAttribute(cast[PIhandle](ih), cstring("HIDEBUTTONS"), cstring(value))

proc `hidebuttons`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDEBUTTONS"), cstring(value))

proc `hidebuttons=`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDEBUTTONS"), cstring((if yes: "YES" else: "NO")))

proc `hidebuttons`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDEBUTTONS"), cstring((if yes: "YES" else: "NO")))

proc `hidebuttons`*(ih: Tree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIDEBUTTONS")) == "YES"

proc `hidelines=`*(ih: Tree_t, value: string) {.cdecl.} =
    # HIDELINES HIDEBUTTONS
    SetAttribute(cast[PIhandle](ih), cstring("HIDELINES"), cstring(value))

proc `hidelines`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDELINES"), cstring(value))

proc `hidelines=`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDELINES"), cstring((if yes: "YES" else: "NO")))

proc `hidelines`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HIDELINES"), cstring((if yes: "YES" else: "NO")))

proc `hidelines`*(ih: Tree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HIDELINES")) == "YES"

# TODO getter tree IMAGE
proc `imagebranchcollapsed=`*(ih: Tree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGEIMAGEEXPANDEDIMAGELEAF IMAGEBRANCHCOLLAPSED
    # IMAGEBRANCHEXPANDED. In Windows, IMAGELEAF, IMAGEBRANCHCOLLAPSED
    # and IMAGEBRANCHEXPANDED must have the same size. In other
    # systems only IMAGEBRANCHCOLLAPSED and IMAGEBRANCHEXPANDED must
    # have the same size. In Windows, IMAGELEAF defines the size
    # available for the image on all nodes. In Windows, IMAGELEAF,
    # IMAGEBRANCHCOLLAPSED and IMAGEBRANCHEXPANDED must have the same
    # size. In other systems only IMAGEBRANCHCOLLAPSED and
    # IMAGEBRANCHEXPANDED must have the same size. In Windows,
    # IMAGELEAF defines the size available for the image on all nodes.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEBRANCHCOLLAPSED"), cast[PIhandle](handle))

proc `imagebranchcollapsed`*(ih: Tree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEBRANCHCOLLAPSED"), cast[PIhandle](handle))

proc `imagebranchcollapsed`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEBRANCHCOLLAPSED"))

proc `imagebranchexpanded=`*(ih: Tree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # IMAGEIMAGEEXPANDEDIMAGELEAF IMAGEBRANCHCOLLAPSED
    # IMAGEBRANCHEXPANDED. In Windows, IMAGELEAF, IMAGEBRANCHCOLLAPSED
    # and IMAGEBRANCHEXPANDED must have the same size. In other
    # systems only IMAGEBRANCHCOLLAPSED and IMAGEBRANCHEXPANDED must
    # have the same size. In Windows, IMAGELEAF defines the size
    # available for the image on all nodes. In Windows, IMAGELEAF,
    # IMAGEBRANCHCOLLAPSED and IMAGEBRANCHEXPANDED must have the same
    # size. In other systems only IMAGEBRANCHCOLLAPSED and
    # IMAGEBRANCHEXPANDED must have the same size. In Windows,
    # IMAGELEAF defines the size available for the image on all nodes.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEBRANCHEXPANDED"), cast[PIhandle](handle))

proc `imagebranchexpanded`*(ih: Tree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGEBRANCHEXPANDED"), cast[PIhandle](handle))

proc `imagebranchexpanded`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGEBRANCHEXPANDED"))

# TODO getter tree IMAGEEXPANDED
proc `imageleaf=`*(ih: Tree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    # In Windows, IMAGELEAF, IMAGEBRANCHCOLLAPSED and
    # IMAGEBRANCHEXPANDED must have the same size. In other systems
    # only IMAGEBRANCHCOLLAPSED and IMAGEBRANCHEXPANDED must have the
    # same size. In Windows, IMAGELEAF defines the size available for
    # the image on all nodes. In Windows, IMAGELEAF,
    # IMAGEBRANCHCOLLAPSED and IMAGEBRANCHEXPANDED must have the same
    # size. In other systems only IMAGEBRANCHCOLLAPSED and
    # IMAGEBRANCHEXPANDED must have the same size. In Windows,
    # IMAGELEAF defines the size available for the image on all nodes.
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGELEAF"), cast[PIhandle](handle))

proc `imageleaf`*(ih: Tree_t, handle: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("IMAGELEAF"), cast[PIhandle](handle))

proc `imageleaf`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("IMAGELEAF"))

proc `indentation=`*(ih: Tree_t, value: string) {.cdecl.} =
    # AUTOREDRAW BGCOLOR COUNT EXPAND FGCOLOR INDENTATION RASTERSIZE
    # SPACING TOPITEM
    SetAttribute(cast[PIhandle](ih), cstring("INDENTATION"), cstring(value))

proc `indentation`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("INDENTATION"), cstring(value))

proc `indentation=`*(ih: Tree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("INDENTATION"), cstring(&"{x}"))

proc `indentation`*(ih: Tree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("INDENTATION"), cstring(&"{x}"))

proc `indentation`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("INDENTATION"))

# TODO getter tree INSERTBRANCH
# TODO getter tree INSERTLEAF
# TODO getter tree KIND
# TODO getter tree LAST
proc `lastaddnode`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("LASTADDNODE"))

proc `mark=`*(ih: Tree_t, value: string) {.cdecl.} =
    # MARK MARKED MARKEDNODESMARKMODE MARKSTARTMARKWHENTOGGLE
    SetAttribute(cast[PIhandle](ih), cstring("MARK"), cstring(value))

proc `mark`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARK"), cstring(value))

# TODO getter tree MARKED
proc `markednodes=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKEDNODES"), cstring(value))

proc `markednodes`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKEDNODES"), cstring(value))

# TODO ??? String Binary tree
proc `markednodes`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MARKEDNODES"))

proc `markmode=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKMODE"), cstring(value))

proc `markmode`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKMODE"), cstring(value))

proc `markmode`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MARKMODE"))

proc `markstart=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKSTART"), cstring(value))

proc `markstart`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKSTART"), cstring(value))

proc `markstart=`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKSTART"), cstring((if yes: "YES" else: "NO")))

proc `markstart`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKSTART"), cstring((if yes: "YES" else: "NO")))

proc `markstart`*(ih: Tree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MARKSTART")) == "YES"

proc `markwhentoggle=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKWHENTOGGLE"), cstring(value))

proc `markwhentoggle`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKWHENTOGGLE"), cstring(value))

proc `markwhentoggle=`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKWHENTOGGLE"), cstring((if yes: "YES" else: "NO")))

proc `markwhentoggle`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARKWHENTOGGLE"), cstring((if yes: "YES" else: "NO")))

proc `markwhentoggle`*(ih: Tree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MARKWHENTOGGLE")) == "YES"

proc `maxsize=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Tree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Tree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Tree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Tree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

# TODO getter tree MOVENODE
proc `name=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary tree
proc `name`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

# TODO getter tree NEXT
proc `normalizergroup=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary tree
proc `normalizergroup`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary tree
proc `ntheme`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: tree PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: tree PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

# TODO getter tree PARENT
proc `position=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Tree_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Tree_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

# TODO getter tree PREVIOUS
proc `propagatefocus=`*(ih: Tree_t, value: string) {.cdecl.} =
    # VALUECANFOCUS PROPAGATEFOCUS
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Tree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Tree_t, value: string) {.cdecl.} =
    # AUTOREDRAW BGCOLOR COUNT EXPAND FGCOLOR INDENTATION RASTERSIZE
    # SPACING TOPITEM
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Tree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Tree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `rename=`*(ih: Tree_t, ) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RENAME"), cstring(""))

proc `rename`*(ih: Tree_t, ) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RENAME"), cstring(""))

proc `renamecaret=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RENAMECARET"), cstring(value))

proc `renamecaret`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RENAMECARET"), cstring(value))

# TODO ??? String Binary tree
proc `renamecaret`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RENAMECARET"))

proc `renameselection=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RENAMESELECTION"), cstring(value))

proc `renameselection`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RENAMESELECTION"), cstring(value))

# TODO ??? String Binary tree
proc `renameselection`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RENAMESELECTION"))

proc `rootcount`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ROOTCOUNT"))

proc `rubberband=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RUBBERBAND"), cstring(value))

proc `rubberband`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RUBBERBAND"), cstring(value))

# TODO ??? String Binary tree
proc `rubberband`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RUBBERBAND"))

proc `screenposition`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

# TODO unknown: tree SHIFT Unknown Binary
proc `shift`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHIFT"))

proc `showdragdrop=`*(ih: Tree_t, value: string) {.cdecl.} =
    # DRAGDROPTREE DROPFILESTARGET DROPEQUALDRAG SHOWDRAGDROP
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDRAGDROP"), cstring(value))

proc `showdragdrop`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDRAGDROP"), cstring(value))

proc `showdragdrop=`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `showdragdrop`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWDRAGDROP"), cstring((if yes: "YES" else: "NO")))

proc `showdragdrop`*(ih: Tree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWDRAGDROP")) == "YES"

proc `showrename=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWRENAME"), cstring(value))

proc `showrename`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWRENAME"), cstring(value))

proc `showrename=`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWRENAME"), cstring((if yes: "YES" else: "NO")))

proc `showrename`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWRENAME"), cstring((if yes: "YES" else: "NO")))

proc `showrename`*(ih: Tree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWRENAME")) == "YES"

proc `showtoggle=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWTOGGLE"), cstring(value))

proc `showtoggle`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWTOGGLE"), cstring(value))

proc `showtoggle=`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWTOGGLE"), cstring((if yes: "YES" else: "NO")))

proc `showtoggle`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SHOWTOGGLE"), cstring((if yes: "YES" else: "NO")))

proc `showtoggle`*(ih: Tree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWTOGGLE")) == "YES"

proc `size=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Tree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Tree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `spacing=`*(ih: Tree_t, value: string) {.cdecl.} =
    # AUTOREDRAW BGCOLOR COUNT EXPAND FGCOLOR INDENTATION RASTERSIZE
    # SPACING TOPITEM
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(value))

proc `spacing`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(value))

proc `spacing=`*(ih: Tree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(&"{x}"))

proc `spacing`*(ih: Tree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACING"), cstring(&"{x}"))

proc `spacing`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SPACING"))

# TODO unknown: tree STARTING Unknown Binary
proc `starting`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("STARTING"))

# TODO getter tree STATE
proc `theme=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary tree
proc `theme`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `tip=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary tree
proc `tip`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: Tree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Tree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: Tree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Tree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: Tree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Tree_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary tree
proc `tipicon`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary tree
proc `tipmarkup`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: Tree_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Tree_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Tree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

# TODO getter tree TITLE
# TODO getter tree TITLEFONT
# TODO getter tree TITLEFONTSIZE
# TODO getter tree TITLEFONTSTYLE
# TODO getter tree TOGGLEVALUE
# TODO getter tree TOGGLEVISIBLE
proc `topitem=`*(ih: Tree_t, value: string) {.cdecl.} =
    # AUTOREDRAW BGCOLOR COUNT EXPAND FGCOLOR INDENTATION RASTERSIZE
    # SPACING TOPITEM
    SetAttribute(cast[PIhandle](ih), cstring("TOPITEM"), cstring(value))

proc `topitem`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPITEM"), cstring(value))

proc `topitem=`*(ih: Tree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPITEM"), cstring(&"{x}"))

proc `topitem`*(ih: Tree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TOPITEM"), cstring(&"{x}"))

# TODO getter tree TOTALCHILDCOUNT
# TODO getter tree USERDATA
proc `usersize=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Tree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Tree_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value=`*(ih: Tree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(&"{x}"))

proc `value`*(ih: Tree_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(&"{x}"))

proc `value`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `visible=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Tree_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Tree_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

# TODO unknown: tree XFONTID Unknown Binary
proc `xfontid`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `y`*(ih: Tree_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `zorder=`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: Tree_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `branchclose_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BRANCHCLOSE_CB"), cast[Icallback](cb))

proc `branchclose_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BRANCHCLOSE_CB"), cast[Icallback](cb))

proc `branchclose_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BRANCHCLOSE_CB")))

proc `branchopen_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BRANCHOPEN_CB"), cast[Icallback](cb))

proc `branchopen_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BRANCHOPEN_CB"), cast[Icallback](cb))

proc `branchopen_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BRANCHOPEN_CB")))

proc `button_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    # BUTTON_CB BUTTON_CB Action generated when a mouse button is
    # pressed or released. Callback int function(Ihandle* ih, int
    # button, int pressed, int x, int y, char* status); [in C]
    # ih:button_cb(button, pressed, x, y: number, status: string) ->
    # (ret: number) [in Lua] ih: identifies the element that activated
    # the event. button: identifies the activated mouse button:
    # IUP_BUTTON1 - left mouse button (button 1); IUP_BUTTON2 - middle
    # mouse button (button 2); IUP_BUTTON3 - right mouse button
    # (button 3). pressed: indicates the state of the button: 0 -
    # mouse button was released; 1 - mouse button was pressed. x, y:
    # position in the canvas where the event has occurred, in pixels.
    # status: status of the mouse buttons and some keyboard keys at
    # the moment the event is generated. The following macros must be
    # used for verification: iup_isshift(status) iup_iscontrol(status)
    # iup_isbutton1(status) iup_isbutton2(status)
    # iup_isbutton3(status) iup_isbutton4(status)
    # iup_isbutton5(status) iup_isdouble(status) iup_isalt(status)
    # iup_issys(status) They return 1 if the respective key or button
    # is pressed, and 0 otherwise. These macros are also available in
    # Lua, returning a boolean. Returns: IUP_CLOSE will be processed.
    # On some controls if IUP_IGNORE is returned the action is ignored
    # (this is system dependent). Notes This callback can be used to
    # customize a button behavior. For a standard button behavior use
    # the ACTION callback of the IupButton. For a single click the
    # callback is called twice, one for pressed=1 and one for
    # pressed=0. Only after both calls the ACTION callback is called.
    # In Windows, if a dialog is shown or popup in any situation there
    # could be unpredictable results because the native system still
    # has processing to be done even after the callback is called. A
    # double click is preceded by two single clicks, one for pressed=1
    # and one for pressed=0, and followed by a press=0, all three
    # without the double click flag set. In GTK, it is preceded by an
    # additional two single clicks sequence. For example, for one
    # double click all the following calls are made: BUTTON_CB(but=1
    # (1), x=154, y=83 [ 1 ]) BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ])
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (0), x=154, y=83 [ 1 ]) (in GTK only)
    # BUTTON_CB(but=1 (1), x=154, y=83 [ 1 D ]) BUTTON_CB(but=1 (0),
    # x=154, y=83 [ 1 ]) Between press and release all mouse events
    # are redirected only to this control, even if the cursor moves
    # outside the element. So the BUTTON_CB callback when released and
    # the MOTION_CB callback can be called with coordinates outside
    # the element rectangle. Affects IupCanvas, IupButton, IupText,
    # IupList, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint, arg4: cint, arg5: cint, arg6: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_CB"), cast[Icallback](cb))

proc `button_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_CB")))

proc `destroy_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Tree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `dragbegin_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, x: cint, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB"), cast[Icallback](cb))

proc `dragbegin_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGBEGIN_CB")))

proc `dragdatasize_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, dragtype: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB"), cast[Icallback](cb))

proc `dragdatasize_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATASIZE_CB")))

proc `dragdata_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB"), cast[Icallback](cb))

proc `dragdata_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDATA_CB")))

proc `dragdrop_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, drag_id, drop_id, isshift, iscontrol: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDROP_CB"), cast[Icallback](cb))

proc `dragdrop_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, drag_id, drop_id, isshift, iscontrol: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGDROP_CB"), cast[Icallback](cb))

proc `dragdrop_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGDROP_CB")))

proc `dragend_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, action: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB"), cast[Icallback](cb))

proc `dragend_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DRAGEND_CB")))

proc `dropdata_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, dragtype: cstring, data: pointer, size, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB"), cast[Icallback](cb))

proc `dropdata_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPDATA_CB")))

proc `dropfiles_cb=`*(ih: Tree_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    # DROPFILES_CB DROPFILES_CB Action called when a file is "dropped"
    # into the control. When several files are dropped at once, the
    # callback is called several times, once for each file. If defined
    # after the element is mapped then the attribute DROPFILESTARGET
    # must be set to YES. [Windows and GTK Only] (GTK 2.6) Callback
    # int function(Ihandle *ih, const char* filename, int num, int x,
    # int y); [in C] ih:dropfiles_cb(filename: string; num, x, y:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. filename: Name of the dropped file.
    # num: Number index of the dropped file. If several files are
    # dropped, num is the index of the dropped file starting from
    # "total-1" to "0". x: X coordinate of the point where the user
    # released the mouse button. y: Y coordinate of the point where
    # the user released the mouse button. Returns: If IUP_IGNORE is
    # returned the callback will NOT be called for the next dropped
    # files, and the processing of dropped files will be interrupted.
    # Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: Tree_t, cb: proc (Ih: PIhandle, filename: cstring, num, x, y: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB"), cast[Icallback](cb))

proc `dropfiles_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPFILES_CB")))

proc `dropmotion_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB"), cast[Icallback](cb))

proc `dropmotion_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DROPMOTION_CB")))

proc `enterwindow_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Tree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `executebranch_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("EXECUTEBRANCH_CB"), cast[Icallback](cb))

proc `executebranch_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("EXECUTEBRANCH_CB"), cast[Icallback](cb))

proc `executebranch_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("EXECUTEBRANCH_CB")))

proc `executeleaf_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("EXECUTELEAF_CB"), cast[Icallback](cb))

proc `executeleaf_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("EXECUTELEAF_CB"), cast[Icallback](cb))

proc `executeleaf_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("EXECUTELEAF_CB")))

proc `getfocus_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Tree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Tree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `killfocus_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Tree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: Tree_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Tree_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Tree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Tree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Tree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `motion_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    # MOTION_CB MOTION_CB Action generated when the mouse moves.
    # Callback int function(Ihandle *ih, int x, int y, char *status);
    # [in C] ih:motion_cb(x, y: number, status: string) -> (ret:
    # number) [in Lua] ih: identifier of the element that activated
    # the event. x, y: position in the canvas where the event has
    # occurred, in pixels. status: status of mouse buttons and certain
    # keyboard keys at the moment the event was generated. The same
    # macros used for BUTTON_CB can be used for this status. Notes
    # Between press and release all mouse events are redirected only
    # to this control, even if the cursor moves outside the element.
    # So the BUTTON_CB callback when released and the MOTION_CB
    # callback can be called with coordinates outside the element
    # rectangle. Affects IupCanvas, IupGLCanvas
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, x, y: cint, status: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOTION_CB"), cast[Icallback](cb))

proc `motion_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOTION_CB")))

proc `multiselection_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: ptr cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MULTISELECTION_CB"), cast[Icallback](cb))

proc `multiselection_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: ptr cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MULTISELECTION_CB"), cast[Icallback](cb))

proc `multiselection_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MULTISELECTION_CB")))

proc `multiunselection_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: ptr cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MULTIUNSELECTION_CB"), cast[Icallback](cb))

proc `multiunselection_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: ptr cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MULTIUNSELECTION_CB"), cast[Icallback](cb))

proc `multiunselection_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MULTIUNSELECTION_CB")))

proc `noderemoved_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("NODEREMOVED_CB"), cast[Icallback](cb))

proc `noderemoved_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("NODEREMOVED_CB"), cast[Icallback](cb))

proc `noderemoved_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("NODEREMOVED_CB")))

proc `postmessage_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `rename_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RENAME_CB"), cast[Icallback](cb))

proc `rename_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cstring): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RENAME_CB"), cast[Icallback](cb))

proc `rename_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RENAME_CB")))

proc `rightclick_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RIGHTCLICK_CB"), cast[Icallback](cb))

proc `rightclick_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("RIGHTCLICK_CB"), cast[Icallback](cb))

proc `rightclick_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("RIGHTCLICK_CB")))

proc `selection_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    # SELECTION_CB: Action generated when an node is selected or
    # deselected. MULTISELECTION_CB: Action generated when multiple
    # nodes are selected with the mouse and the shift key pressed.
    # MULTIUNSELECTION_CB: Action generated before multiple nodes are
    # unselected in one single operation. BRANCHOPEN_CB: Action
    # generated when a branch is expanded. BRANCHCLOSE_CB: Action
    # generated when a branch is collapsed. EXECUTELEAF_CB: Action
    # generated when a leaf is executed. EXECUTEBRANCH_CB: Action
    # generated when a branch is executed. SHOWRENAME_CB: Action
    # generated before a node is renamed. RENAME_CB: Action generated
    # after a node is renamed. DRAGDROP_CB: Action generated when an
    # internal drag & drop is executed. NODEREMOVED_CB: Action
    # generated when a node is about to be removed. RIGHTCLICK_CB:
    # Action generated when the right mouse button is pressed over a
    # node. TOGGLEVALUE_CB: Action generated when the toggle&#39;s
    # state was changed. The callback also receives the new
    # toggle&#39;s state.
    SetCallback(cast[PIhandle](ih), cstring("SELECTION_CB"), cast[Icallback](cb))

proc `selection_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SELECTION_CB"), cast[Icallback](cb))

proc `selection_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SELECTION_CB")))

proc `showrename_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SHOWRENAME_CB"), cast[Icallback](cb))

proc `showrename_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("SHOWRENAME_CB"), cast[Icallback](cb))

proc `showrename_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("SHOWRENAME_CB")))

proc `togglevalue_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("TOGGLEVALUE_CB"), cast[Icallback](cb))

proc `togglevalue_cb`*(ih: Tree_t, cb: proc (ih: PIhandle, arg2: cint, arg3: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("TOGGLEVALUE_CB"), cast[Icallback](cb))

proc `togglevalue_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("TOGGLEVALUE_CB")))

proc `unmap_cb=`*(ih: Tree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Tree_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Tree_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc User*(): User_t {.cdecl.} =
    # Creates a user element in IUP, which is not associated to any
    # interface element. It is used to map an external element to a
    # IUP element. Its use is usually for additional elements, but you
    # can use it to create an Ihandle* to store private attributes. It
    # is also a void container. Its children can be dynamically added
    # using IupAppend or IupInsert.
    return User_t(niupc.User())

# TODO unknown: user CLEARATTRIBUTES Unknown Binary
proc `alignment=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(cstring(value)))

proc `alignment`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(cstring(value)))

proc `bgcolor=`*(ih: User_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: User_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bulk=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BULK"), cstring(cstring(value)))

proc `bulk`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BULK"), cstring(cstring(value)))

proc `cleanout=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLEANOUT"), cstring(cstring(value)))

proc `cleanout`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLEANOUT"), cstring(cstring(value)))

proc `clearattributes=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLEARATTRIBUTES"), cstring(cstring(value)))

proc `clearattributes`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CLEARATTRIBUTES"), cstring(cstring(value)))

proc `disabled=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DISABLED"), cstring(cstring(value)))

proc `disabled`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("DISABLED"), cstring(cstring(value)))

proc `fgcolor=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(cstring(value)))

proc `fgcolor`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FGCOLOR"), cstring(cstring(value)))

proc `fontface=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(cstring(value)))

proc `fontface`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(cstring(value)))

proc `fontscale=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSCALE"), cstring(cstring(value)))

proc `fontscale`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSCALE"), cstring(cstring(value)))

proc `fontsize=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(cstring(value)))

proc `fontsize`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(cstring(value)))

proc `indent=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("INDENT"), cstring(cstring(value)))

proc `indent`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("INDENT"), cstring(cstring(value)))

proc `italic=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ITALIC"), cstring(cstring(value)))

proc `italic`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ITALIC"), cstring(cstring(value)))

proc `italic=`*(ih: User_t, yes: bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ITALIC"), cstring((if yes: "YES" else: "NO")))

proc `italic`*(ih: User_t, yes: bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ITALIC"), cstring((if yes: "YES" else: "NO")))

proc `language=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LANGUAGE"), cstring(cstring(value)))

proc `language`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LANGUAGE"), cstring(cstring(value)))

proc `linespacing=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINESPACING"), cstring(cstring(value)))

proc `linespacing`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("LINESPACING"), cstring(cstring(value)))

proc `name=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(cstring(value)))

proc `name`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(cstring(value)))

proc `numbering=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NUMBERING"), cstring(cstring(value)))

proc `numbering`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NUMBERING"), cstring(cstring(value)))

proc `numberingstyle=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NUMBERINGSTYLE"), cstring(cstring(value)))

proc `numberingstyle`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NUMBERINGSTYLE"), cstring(cstring(value)))

proc `numberingtab=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NUMBERINGTAB"), cstring(cstring(value)))

proc `numberingtab`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NUMBERINGTAB"), cstring(cstring(value)))

proc `protected=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROTECTED"), cstring(cstring(value)))

proc `protected`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROTECTED"), cstring(cstring(value)))

proc `rise=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RISE"), cstring(cstring(value)))

proc `rise`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RISE"), cstring(cstring(value)))

proc `selection=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTION"), cstring(cstring(value)))

proc `selection`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTION"), cstring(cstring(value)))

proc `selectionpos=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTIONPOS"), cstring(cstring(value)))

proc `selectionpos`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SELECTIONPOS"), cstring(cstring(value)))

proc `smallcaps=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SMALLCAPS"), cstring(cstring(value)))

proc `smallcaps`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SMALLCAPS"), cstring(cstring(value)))

proc `spaceafter=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACEAFTER"), cstring(cstring(value)))

proc `spaceafter`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACEAFTER"), cstring(cstring(value)))

proc `spacebefore=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACEBEFORE"), cstring(cstring(value)))

proc `spacebefore`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SPACEBEFORE"), cstring(cstring(value)))

proc `stretch=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STRETCH"), cstring(cstring(value)))

proc `stretch`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STRETCH"), cstring(cstring(value)))

proc `strikeout=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STRIKEOUT"), cstring(cstring(value)))

proc `strikeout`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STRIKEOUT"), cstring(cstring(value)))

proc `strikeout=`*(ih: User_t, yes: bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STRIKEOUT"), cstring((if yes: "YES" else: "NO")))

proc `strikeout`*(ih: User_t, yes: bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STRIKEOUT"), cstring((if yes: "YES" else: "NO")))

proc `tabsarray=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TABSARRAY"), cstring(cstring(value)))

proc `tabsarray`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TABSARRAY"), cstring(cstring(value)))

proc `underline=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("UNDERLINE"), cstring(cstring(value)))

proc `underline`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("UNDERLINE"), cstring(cstring(value)))

proc `units=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("UNITS"), cstring(cstring(value)))

proc `units`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("UNITS"), cstring(cstring(value)))

proc `weight=`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WEIGHT"), cstring(cstring(value)))

proc `weight`*(ih: User_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("WEIGHT"), cstring(cstring(value)))

proc `destroy_cb=`*(ih: User_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: User_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: User_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `ldestroy_cb=`*(ih: User_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: User_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: User_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: User_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: User_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: User_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: User_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: User_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: User_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: User_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: User_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: User_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc Val*(`type`: string): Val_t {.cdecl.} =
    # Creates a Valuator control. Selects a value in a limited
    # interval. Also known as Scale or Trackbar in native systems.
    return Val_t(niupc.Val(cstring(`type`)))

proc `active=`*(ih: Val_t, value: string) {.cdecl.} =
    # ACTIVE, EXPAND, FONT, SCREENPOSITION, POSITION, MINSIZE,
    # MAXSIZE, WID, TIP, SIZE, ZORDER, VISIBLE, THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Val_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Val_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Val_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `bgcolor=`*(ih: Val_t, value: string) {.cdecl.} =
    # BGCOLOR: transparent in all systems except in Motif. It will use
    # the background color of the native parent.
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(value))

proc `bgcolor=`*(ih: Val_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Val_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `bgcolor`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("BGCOLOR"))

proc `canfocus=`*(ih: Val_t, value: string) {.cdecl.} =
    # CANFOCUS (creation only) (non inheritable): enables the focus
    # traversal of the control. In Windows the control will still get
    # the focus when clicked. Default: YES. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Val_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Val_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Val_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `expand=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Val_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Val_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary val
proc `font`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary val
proc `fontface`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Val_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Val_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary val
proc `fontstyle`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary val
proc `handlename`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

# TODO unknown: val INVERTED Unknown Binary
proc `inverted`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("INVERTED"))

proc `max=`*(ih: Val_t, value: string) {.cdecl.} =
    # MAX: Contains the maximum valuator value. Default is "1". When
    # changed the display will not be updated until VALUE is set.
    SetAttribute(cast[PIhandle](ih), cstring("MAX"), cstring(value))

proc `max`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAX"), cstring(value))

proc `max=`*(ih: Val_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAX"), cstring(&"{x}"))

proc `max`*(ih: Val_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAX"), cstring(&"{x}"))

proc `max`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAX"))

proc `maxsize=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Val_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Val_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `min=`*(ih: Val_t, value: string) {.cdecl.} =
    # MIN: Contains the minimum valuator value. Default is "0". When
    # changed the display will not be updated until VALUE is set.
    SetAttribute(cast[PIhandle](ih), cstring("MIN"), cstring(value))

proc `min`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MIN"), cstring(value))

proc `min=`*(ih: Val_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MIN"), cstring(&"{x}"))

proc `min`*(ih: Val_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MIN"), cstring(&"{x}"))

proc `min`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MIN"))

proc `minsize=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Val_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Val_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary val
proc `name`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary val
proc `normalizergroup`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary val
proc `ntheme`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `orientation=`*(ih: Val_t, value: string) {.cdecl.} =
    # ORIENTATION (creation only) (non inheritable): Informs whether
    # the valuator is "VERTICAL" or "HORIZONTAL". Vertical valuators
    # are bottom to up, and horizontal valuators are left to right
    # variations of min to max (but can be inverted using INVERTED).
    # Default: "HORIZONTAL".
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"), cstring(value))

proc `orientation`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"))

# TODO unknown: val PAGESTEP Unknown Binary
proc `pagestep`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PAGESTEP"))

# TODO unknown: val PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: val PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Val_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Val_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Val_t, value: string) {.cdecl.} =
    # PROPAGATEFOCUS(non inheritable): enables the focus callback
    # forwarding to the next native parent with FOCUS_CB defined.
    # Default: NO. (since 3.23)
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Val_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Val_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Val_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Val_t, value: string) {.cdecl.} =
    # RASTERSIZE (non inheritable): The initial size is 100 pixels
    # along the major axis, and the handler normal size on the minor
    # axis. If there are ticks then they are added to the natural size
    # on the minor axis. The handler can be smaller than the normal
    # size. Set to NULL to allow the automatic layout use smaller
    # values.
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Val_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Val_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `screenposition`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SCREENPOSITION"))

# TODO unknown: val SHOWTICKS Unknown Binary
proc `showticks`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SHOWTICKS"))

proc `size=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Val_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Val_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `step=`*(ih: Val_t, value: string) {.cdecl.} =
    # STEP: Controls the increment for keyboard control and the mouse
    # wheel. It is not the size of the increment. The increment size
    # is "step*(max-min)", so it must be 0<step<1. Default is "0.01".
    SetAttribute(cast[PIhandle](ih), cstring("STEP"), cstring(value))

proc `step`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STEP"), cstring(value))

proc `step=`*(ih: Val_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STEP"), cstring(&"{x}"))

proc `step`*(ih: Val_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("STEP"), cstring(&"{x}"))

proc `step`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("STEP"))

proc `theme=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary val
proc `theme`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

# TODO unknown: val TICKSPOS Unknown Binary
proc `tickspos`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TICKSPOS"))

proc `tip=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

proc `tip`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIP"), cstring(value))

# TODO ??? String Binary val
proc `tip`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIP"))

proc `tipbgcolor=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(value))

proc `tipbgcolor=`*(ih: Val_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Val_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipbgcolor`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPBGCOLOR"))

proc `tipdelay=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(value))

proc `tipdelay=`*(ih: Val_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Val_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"), cstring(&"{x}"))

proc `tipdelay`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPDELAY"))

proc `tipfgcolor=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(value))

proc `tipfgcolor=`*(ih: Val_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Val_t, red, green, blue:int, alpha:int = 255) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"), cstring(&"{red} {green} {blue} {alpha}"))

proc `tipfgcolor`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPFGCOLOR"))

proc `tipicon=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

proc `tipicon`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPICON"), cstring(value))

# TODO ??? String Binary val
proc `tipicon`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPICON"))

proc `tipmarkup=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

proc `tipmarkup`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"), cstring(value))

# TODO ??? String Binary val
proc `tipmarkup`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPMARKUP"))

proc `tiprect=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(value))

proc `tiprect=`*(ih: Val_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Val_t, x1, y1, x2, y2:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPRECT"), cstring(&"{x1} {y1} {x2} {y2}"))

proc `tiprect`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPRECT"))

proc `tipvisible=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring(value))

proc `tipvisible=`*(ih: Val_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Val_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `tipvisible`*(ih: Val_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TIPVISIBLE")) == "YES"

proc `type=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TYPE"), cstring(value))

proc `type`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("TYPE"), cstring(value))

proc `type`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("TYPE"))

proc `usersize=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Val_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Val_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: Val_t, value: string) {.cdecl.} =
    # VALUE (non inheritable): Contains a number between MIN and MAX,
    # indicating the valuator position. Default: "0.0".
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

# TODO ??? String Binary val
proc `value`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `visible=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Val_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Val_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Val_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

proc `x`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("X"))

# TODO unknown: val XFONTID Unknown Binary
proc `xfontid`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `y`*(ih: Val_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("Y"))

proc `zorder=`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `zorder`*(ih: Val_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ZORDER"), cstring(value))

proc `button_press_cb=`*(ih: Val_t, cb: proc (ih: PIhandle, arg2: cdouble): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_PRESS_CB"), cast[Icallback](cb))

proc `button_press_cb`*(ih: Val_t, cb: proc (ih: PIhandle, arg2: cdouble): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_PRESS_CB"), cast[Icallback](cb))

proc `button_press_cb`*(ih: Val_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_PRESS_CB")))

proc `button_release_cb=`*(ih: Val_t, cb: proc (ih: PIhandle, arg2: cdouble): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_RELEASE_CB"), cast[Icallback](cb))

proc `button_release_cb`*(ih: Val_t, cb: proc (ih: PIhandle, arg2: cdouble): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("BUTTON_RELEASE_CB"), cast[Icallback](cb))

proc `button_release_cb`*(ih: Val_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("BUTTON_RELEASE_CB")))

proc `destroy_cb=`*(ih: Val_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Val_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Val_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `enterwindow_cb=`*(ih: Val_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse
    # enters the native element. Callback int function(Ihandle *ih);
    # [in C] ih:enterwindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # LEAVEWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Val_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB"), cast[Icallback](cb))

proc `enterwindow_cb`*(ih: Val_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("ENTERWINDOW_CB")))

proc `getfocus_cb=`*(ih: Val_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # GETFOCUS_CB GETFOCUS_CB Action generated when an element is
    # given keyboard focus. This callback is called after the
    # KILLFOCUS_CB of the element that loosed the focus. The
    # IupGetFocus function during the callback returns the element
    # that loosed the focus. Callback int function(Ihandle *ih); [in
    # C] ih:getfocus_cb() -> (ret: number) [in Lua] ih: identifier of
    # the element that received keyboard focus. Affects All elements
    # with user interaction, except menus. See Also KILLFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Val_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB"), cast[Icallback](cb))

proc `getfocus_cb`*(ih: Val_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("GETFOCUS_CB")))

proc `help_cb=`*(ih: Val_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # HELP_CB HELP_CB Action generated when the user press F1 at a
    # control. In Motif is also activated by the Help button in some
    # workstations keyboard. Callback void function(Ihandle *ih); [in
    # C] ih:help_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Returns: IUP_CLOSE will be
    # processed. Affects All elements with user interaction.
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Val_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("HELP_CB"), cast[Icallback](cb))

proc `help_cb`*(ih: Val_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("HELP_CB")))

proc `killfocus_cb=`*(ih: Val_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses
    # keyboard focus. This callback is called before the GETFOCUS_CB
    # of the element that gets the focus. Callback int
    # function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret: number)
    # [in Lua] ih: identifier of the element that activated the event.
    # Affects All elements with user interaction, except menus. In
    # Windows, there are restrictions when using this callback. From
    # MSDN on WM_KILLFOCUS: "While processing this message, do not
    # make any function calls that display or activate a window. This
    # causes the thread to yield control and can cause the application
    # to stop responding to messages. See Also GETFOCUS_CB,
    # IupGetFocus, IupSetFocus
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Val_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB"), cast[Icallback](cb))

proc `killfocus_cb`*(ih: Val_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("KILLFOCUS_CB")))

proc `k_any=`*(ih: Val_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    # K_ANY K_ANY Action generated when a keyboard event occurs.
    # Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c:
    # number) -> (ret: number) [in Lua] ih: identifier of the element
    # that activated the event. c: identifier of typed key. Please
    # refer to the Keyboard Codes table for a list of possible values.
    # Returns: If IUP_IGNORE is returned the key is ignored and not
    # processed by the control and not propagated. If returns
    # IUP_CONTINUE, the key will be processed and the event will be
    # propagated to the parent of the element receiving it, this is
    # the default behavior. If returns IUP_DEFAULT the key is
    # processed but it is not propagated. IUP_CLOSE will be processed.
    # Notes Keyboard callbacks depend on the keyboard usage of the
    # control with the focus. So if you return IUP_IGNORE the control
    # will usually not process the key. But be aware that sometimes
    # the control process the key in another event so even returning
    # IUP_IGNORE the key can get processed. Although it will not be
    # propagated. IMPORTANT: The callbacks "K_*" of the dialog or
    # native containers depend on the IUP_CONTINUE return value to
    # work while the control is in focus. If the callback does not
    # exists it is automatically propagated to the parent of the
    # element. K_* callbacks All defined keys are also callbacks of
    # any element, called when the respective key is activated. For
    # example: "K_cC" is also a callback activated when the user press
    # Ctrl+C, when the focus is at the element or at a children with
    # focus. This is the way an application can create shortcut keys,
    # also called hot keys. These callbacks are not available in
    # IupLua. Affects All elements with keyboard interaction.
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Val_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("K_ANY"), cast[Icallback](cb))

proc `k_any`*(ih: Val_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("K_ANY")))

proc `ldestroy_cb=`*(ih: Val_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Val_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Val_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `leavewindow_cb=`*(ih: Val_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse
    # leaves the native element. Callback int function(Ihandle *ih);
    # [in C] ih:leavewindow_cb() -> (ret: number) [in Lua] ih:
    # identifier of the element that activated the event. Notes When
    # the cursor is moved from one element to another, the call order
    # in all platforms will be first the LEAVEWINDOW_CB callback of
    # the old control followed by the ENTERWINDOW_CB callback of the
    # new control. (since 3.14) If the mouse button is hold pressed
    # and the cursor moves outside the element the behavior is system
    # dependent. In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB
    # callbacks are NOT called, in GTK the callbacks are called.
    # Affects All controls with user interaction. See Also
    # ENTERWINDOW_CB
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Val_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB"), cast[Icallback](cb))

proc `leavewindow_cb`*(ih: Val_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LEAVEWINDOW_CB")))

proc `map_cb=`*(ih: Val_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Val_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Val_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `mousemove_cb=`*(ih: Val_t, cb: proc (ih: PIhandle, arg2: cdouble): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOUSEMOVE_CB"), cast[Icallback](cb))

proc `mousemove_cb`*(ih: Val_t, cb: proc (ih: PIhandle, arg2: cdouble): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MOUSEMOVE_CB"), cast[Icallback](cb))

proc `mousemove_cb`*(ih: Val_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MOUSEMOVE_CB")))

proc `postmessage_cb=`*(ih: Val_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Val_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Val_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: Val_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Val_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Val_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `valuechanged_cb=`*(ih: Val_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # VALUECHANGED_CB: Called after the value was interactively
    # changed by the user. int function(Ihandle *ih); [in
    # C]ih:valuechanged_cb() -> (ret: number) [in Lua]
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: Val_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB"), cast[Icallback](cb))

proc `valuechanged_cb`*(ih: Val_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("VALUECHANGED_CB")))

macro Vbox*(args: varargs[untyped]): Vbox_t =
    # Creates a void container for composing elements vertically. It
    # is a box that arranges the elements it contains from top to
    # bottom. It does not have a native representation.


    result = nnkCall.newTree(
        nnkDotExpr.newTree(
            newIdentNode("niup"),
            newIdentNode("Vbox_t")
          ),
       )
    let inner = nnkCall.newTree(
            newIdentNode("Vbox")
          )

    if args.len > 0:
        for i in 0 ..< args.len:
          inner.add nnkCast.newTree(newIdentNode("PIhandle"), args[i])
    inner.add newNilLit()
    result.add inner


proc `active=`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Vbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Vbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Vbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `alignment=`*(ih: Vbox_t, value: string) {.cdecl.} =
    # ALIGNMENT (non inheritable): Horizontally aligns the elements.
    # Possible values: "ALEFT", "ACENTER", "ARIGHT". Default: "ALEFT".
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"))

proc `canfocus=`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Vbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Vbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Vbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `cgap=`*(ih: Vbox_t, value: string) {.cdecl.} =
    # GAP, CGAP: Defines a vertical space in pixels between the
    # children, CGAP is in the same units of the SIZE attribute for
    # the height. Default: "0". (CGAP since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("CGAP"), cstring(value))

proc `cgap`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CGAP"), cstring(value))

proc `cgap=`*(ih: Vbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CGAP"), cstring(&"{x}"))

proc `cgap`*(ih: Vbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CGAP"), cstring(&"{x}"))

proc `cgap`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CGAP"))

proc `charsize`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `clientoffset`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `cmargin=`*(ih: Vbox_t, value: string) {.cdecl.} =
    # MARGIN, CMARGIN: Defines a margin in pixels, CMARGIN is in the
    # same units of the SIZE attribute. Its value has the format
    # "widthxheight", where width and height are integer values
    # corresponding to the horizontal and vertical margins,
    # respectively. Default: "0x0" (no margin). (CMARGIN since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("CMARGIN"), cstring(value))

proc `cmargin`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CMARGIN"), cstring(value))

proc `cmargin=`*(ih: Vbox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CMARGIN"), cstring(&"{horiz}x{vert}"))

proc `cmargin`*(ih: Vbox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CMARGIN"), cstring(&"{horiz}x{vert}"))

proc `cmargin`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CMARGIN"))

proc `expand=`*(ih: Vbox_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable*): The default value is "YES". See the
    # documentation of the attribute for EXPAND inheritance.
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandchildren=`*(ih: Vbox_t, value: string) {.cdecl.} =
    # EXPANDCHILDREN (non inheritable): forces all children to expand
    # horizontally and to fully occupy its space available inside the
    # box. Default: "NO". This has the same effect as setting
    # EXPAND=HORIZONTAL on each child. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDCHILDREN"), cstring(value))

proc `expandchildren`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDCHILDREN"), cstring(value))

proc `expandchildren=`*(ih: Vbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDCHILDREN"), cstring((if yes: "YES" else: "NO")))

proc `expandchildren`*(ih: Vbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDCHILDREN"), cstring((if yes: "YES" else: "NO")))

proc `expandchildren`*(ih: Vbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDCHILDREN")) == "YES"

proc `expandweight=`*(ih: Vbox_t, value: string) {.cdecl.} =
    # EXPANDWEIGHT (non inheritable) (at children only): If a child
    # defines the expand weight, then it is used to multiply the free
    # space used for expansion. (since 3.1)
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Vbox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Vbox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: Vbox_t, value: string) {.cdecl.} =
    # FLOATING (non inheritable) (at children only): If a child has
    # FLOATING=YES then its size and position will be ignored by the
    # layout processing. Default: "NO". (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Vbox_t, value: string) {.cdecl.} =
    # FONT, CLIENTSIZE, CLIENTOFFSET, POSITION, MINSIZE, MAXSIZE,
    # THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary vbox
proc `font`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary vbox
proc `fontface`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Vbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Vbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary vbox
proc `fontstyle`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `gap=`*(ih: Vbox_t, value: string) {.cdecl.} =
    # GAP, CGAP: Defines a vertical space in pixels between the
    # children, CGAP is in the same units of the SIZE attribute for
    # the height. Default: "0". (CGAP since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("GAP"), cstring(value))

proc `gap`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("GAP"), cstring(value))

proc `gap=`*(ih: Vbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("GAP"), cstring(&"{x}"))

proc `gap`*(ih: Vbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("GAP"), cstring(&"{x}"))

proc `gap`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("GAP"))

proc `handlename=`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary vbox
proc `handlename`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `homogeneous=`*(ih: Vbox_t, value: string) {.cdecl.} =
    # HOMOGENEOUS (non inheritable): forces all children to get equal
    # vertical space. The space height will be based on the highest
    # child. Default: "NO". Notice that this does not changes the
    # children size, only the available space for each one of them to
    # expand. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("HOMOGENEOUS"), cstring(value))

proc `homogeneous`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HOMOGENEOUS"), cstring(value))

proc `homogeneous=`*(ih: Vbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HOMOGENEOUS"), cstring((if yes: "YES" else: "NO")))

proc `homogeneous`*(ih: Vbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HOMOGENEOUS"), cstring((if yes: "YES" else: "NO")))

proc `homogeneous`*(ih: Vbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HOMOGENEOUS")) == "YES"

proc `margin=`*(ih: Vbox_t, value: string) {.cdecl.} =
    # MARGIN, CMARGIN: Defines a margin in pixels, CMARGIN is in the
    # same units of the SIZE attribute. Its value has the format
    # "widthxheight", where width and height are integer values
    # corresponding to the horizontal and vertical margins,
    # respectively. Default: "0x0" (no margin). (CMARGIN since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(value))

proc `margin`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(value))

proc `margin=`*(ih: Vbox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(&"{horiz}x{vert}"))

proc `margin`*(ih: Vbox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MARGIN"), cstring(&"{horiz}x{vert}"))

proc `margin`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MARGIN"))

proc `maxsize=`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Vbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Vbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Vbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Vbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary vbox
proc `name`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `ncgap=`*(ih: Vbox_t, value: string) {.cdecl.} =
    # NGAP, NCGAP (non inheritable): Same as GAP but are non
    # inheritable. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("NCGAP"), cstring(value))

proc `ncgap`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCGAP"), cstring(value))

proc `ncgap=`*(ih: Vbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCGAP"), cstring(&"{x}"))

proc `ncgap`*(ih: Vbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCGAP"), cstring(&"{x}"))

proc `ncgap`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NCGAP"))

proc `ncmargin=`*(ih: Vbox_t, value: string) {.cdecl.} =
    # NMARGIN, NCMARGIN (non inheritable): Same as MARGIN but are non
    # inheritable. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"), cstring(value))

proc `ncmargin`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"), cstring(value))

proc `ncmargin=`*(ih: Vbox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"), cstring(&"{horiz}x{vert}"))

proc `ncmargin`*(ih: Vbox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"), cstring(&"{horiz}x{vert}"))

proc `ncmargin`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NCMARGIN"))

proc `ngap=`*(ih: Vbox_t, value: string) {.cdecl.} =
    # NGAP, NCGAP (non inheritable): Same as GAP but are non
    # inheritable. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("NGAP"), cstring(value))

proc `ngap`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NGAP"), cstring(value))

proc `ngap=`*(ih: Vbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NGAP"), cstring(&"{x}"))

proc `ngap`*(ih: Vbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NGAP"), cstring(&"{x}"))

proc `ngap`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NGAP"))

proc `nmargin=`*(ih: Vbox_t, value: string) {.cdecl.} =
    # NMARGIN, NCMARGIN (non inheritable): Same as MARGIN but are non
    # inheritable. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("NMARGIN"), cstring(value))

proc `nmargin`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NMARGIN"), cstring(value))

proc `nmargin=`*(ih: Vbox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NMARGIN"), cstring(&"{horiz}x{vert}"))

proc `nmargin`*(ih: Vbox_t, horiz, vert:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NMARGIN"), cstring(&"{horiz}x{vert}"))

proc `nmargin`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NMARGIN"))

proc `normalizergroup=`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary vbox
proc `normalizergroup`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `normalizesize=`*(ih: Vbox_t, value: string) {.cdecl.} =
    # NORMALIZESIZE (non inheritable): normalizes all children natural
    # size to be the biggest natural size among them. All natural
    # width will be set to the biggest width, and all natural height
    # will be set to the biggest height according to is value. Can be
    # NO, HORIZONTAL, VERTICAL or BOTH. Default: "NO". Same as using
    # IupNormalizer. (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZESIZE"), cstring(value))

proc `normalizesize`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZESIZE"), cstring(value))

proc `normalizesize`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZESIZE"))

proc `ntheme=`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary vbox
proc `ntheme`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

proc `orientation`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ORIENTATION"))

# TODO unknown: vbox PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: vbox PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Vbox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Vbox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Vbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Vbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Vbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Vbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Vbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `size=`*(ih: Vbox_t, value: string) {.cdecl.} =
    # SIZE / RASTERSIZE (non inheritable): Defines the height of the
    # box. When consulted behaves as the standard SIZE/RASTERSIZE
    # attributes. The standard format "wxh" can also be used, but
    # width will be ignored (since 3.3).
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Vbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{x}"))

proc `size`*(ih: Vbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{x}"))

proc `size`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary vbox
proc `theme`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `usersize=`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Vbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Vbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `visible=`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Vbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Vbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Vbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Vbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

# TODO unknown: vbox XFONTID Unknown Binary
proc `xfontid`*(ih: Vbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `destroy_cb=`*(ih: Vbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Vbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Vbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `ldestroy_cb=`*(ih: Vbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Vbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Vbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: Vbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Vbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Vbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: Vbox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Vbox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Vbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: Vbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Vbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Vbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc `updateattribfromfont_cb=`*(ih: Vbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UPDATEATTRIBFROMFONT_CB"), cast[Icallback](cb))

proc `updateattribfromfont_cb`*(ih: Vbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UPDATEATTRIBFROMFONT_CB"), cast[Icallback](cb))

proc `updateattribfromfont_cb`*(ih: Vbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UPDATEATTRIBFROMFONT_CB")))

macro Zbox*(args: varargs[untyped]): Zbox_t =
    # Creates a void container for composing elements in hidden layers
    # with only one layer visible. It is a box that piles up the
    # children it contains, only the one child is visible. It does not
    # have a native representation. Zbox works by changing the VISIBLE
    # attribute of its children, so if any of the grand children has
    # its VISIBLE attribute directly defined then Zbox will NOT change
    # its state.


    result = nnkCall.newTree(
        nnkDotExpr.newTree(
            newIdentNode("niup"),
            newIdentNode("Zbox_t")
          ),
       )
    let inner = nnkCall.newTree(
            newIdentNode("Zbox")
          )

    if args.len > 0:
        for i in 0 ..< args.len:
          inner.add nnkCast.newTree(newIdentNode("PIhandle"), args[i])
    inner.add newNilLit()
    result.add inner


proc `active=`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring(value))

proc `active=`*(ih: Zbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Zbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ACTIVE"), cstring((if yes: "YES" else: "NO")))

proc `active`*(ih: Zbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ACTIVE")) == "YES"

proc `alignment=`*(ih: Zbox_t, value: string) {.cdecl.} =
    # ALIGNMENT (non inheritable): Defines the alignment of the
    # visible child. Possible values:
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"), cstring(value))

proc `alignment`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("ALIGNMENT"))

proc `canfocus=`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring(value))

proc `canfocus=`*(ih: Zbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Zbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CANFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `canfocus`*(ih: Zbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CANFOCUS")) == "YES"

proc `charsize`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHARSIZE"))

proc `childsizeall=`*(ih: Zbox_t, value: string) {.cdecl.} =
    # CHILDSIZEALL (non inheritable): compute the natural size using
    # all children. If set to NO will compute using only the visible
    # child. Default: Yes. (since 3.27)
    SetAttribute(cast[PIhandle](ih), cstring("CHILDSIZEALL"), cstring(value))

proc `childsizeall`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDSIZEALL"), cstring(value))

proc `childsizeall=`*(ih: Zbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDSIZEALL"), cstring((if yes: "YES" else: "NO")))

proc `childsizeall`*(ih: Zbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("CHILDSIZEALL"), cstring((if yes: "YES" else: "NO")))

proc `childsizeall`*(ih: Zbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CHILDSIZEALL")) == "YES"

proc `clientoffset`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTOFFSET"))

proc `clientsize`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("CLIENTSIZE"))

proc `expand=`*(ih: Zbox_t, value: string) {.cdecl.} =
    # EXPAND (non inheritable): The default value is "YES".
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPAND"), cstring(value))

proc `expand`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPAND"))

proc `expandweight=`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(value))

proc `expandweight=`*(ih: Zbox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Zbox_t, x:int64) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"), cstring(&"{x}"))

proc `expandweight`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("EXPANDWEIGHT"))

proc `floating=`*(ih: Zbox_t, value: string) {.cdecl.} =
    # FLOATING (non inheritable) (at children only): If a child has
    # FLOATING=YES then its size and position will be ignored by the
    # layout processing. Default: "NO". (since 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FLOATING"), cstring(value))

proc `floating`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FLOATING"))

proc `font=`*(ih: Zbox_t, value: string) {.cdecl.} =
    # FONT, CLIENTSIZE, CLIENTOFFSET, POSITION, MINSIZE, MAXSIZE,
    # THEME: also accepted.
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

proc `font`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONT"), cstring(value))

# TODO ??? String Binary zbox
proc `font`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONT"))

proc `fontface=`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

proc `fontface`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTFACE"), cstring(value))

# TODO ??? String Binary zbox
proc `fontface`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTFACE"))

proc `fontsize=`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(value))

proc `fontsize=`*(ih: Zbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Zbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"), cstring(&"{x}"))

proc `fontsize`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSIZE"))

proc `fontstyle=`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

proc `fontstyle`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"), cstring(value))

# TODO ??? String Binary zbox
proc `fontstyle`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("FONTSTYLE"))

proc `handlename=`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

proc `handlename`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"), cstring(value))

# TODO ??? String Binary zbox
proc `handlename`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("HANDLENAME"))

proc `maxsize=`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(value))

proc `maxsize=`*(ih: Zbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Zbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"), cstring(&"{width}x{height}"))

proc `maxsize`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MAXSIZE"))

proc `minsize=`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(value))

proc `minsize=`*(ih: Zbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Zbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("MINSIZE"), cstring(&"{width}x{height}"))

proc `minsize`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("MINSIZE"))

proc `name=`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

proc `name`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NAME"), cstring(value))

# TODO ??? String Binary zbox
proc `name`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NAME"))

proc `naturalsize`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NATURALSIZE"))

proc `normalizergroup=`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

proc `normalizergroup`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"), cstring(value))

# TODO ??? String Binary zbox
proc `normalizergroup`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NORMALIZERGROUP"))

proc `ntheme=`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

proc `ntheme`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("NTHEME"), cstring(value))

# TODO ??? String Binary zbox
proc `ntheme`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("NTHEME"))

# TODO unknown: zbox PANGOFONTDESC Unknown Binary
proc `pangofontdesc`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOFONTDESC"))

# TODO unknown: zbox PANGOLAYOUT Unknown Binary
proc `pangolayout`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PANGOLAYOUT"))

proc `position=`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(value))

proc `position=`*(ih: Zbox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Zbox_t, x, y:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("POSITION"), cstring(&"{x},{y}"))

proc `position`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("POSITION"))

proc `propagatefocus=`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring(value))

proc `propagatefocus=`*(ih: Zbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Zbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS"), cstring((if yes: "YES" else: "NO")))

proc `propagatefocus`*(ih: Zbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("PROPAGATEFOCUS")) == "YES"

proc `rastersize=`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(value))

proc `rastersize=`*(ih: Zbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Zbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"), cstring(&"{width}x{height}"))

proc `rastersize`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("RASTERSIZE"))

proc `size=`*(ih: Zbox_t, value: string) {.cdecl.} =
    # SIZE / RASTERSIZE (non inheritable): The default size is the
    # smallest size that fits its largest child. All child elements
    # are considered even invisible ones, except when FLOATING=YES in
    # a child.
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(value))

proc `size=`*(ih: Zbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Zbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("SIZE"), cstring(&"{width}x{height}"))

proc `size`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("SIZE"))

proc `theme=`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

proc `theme`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("THEME"), cstring(value))

# TODO ??? String Binary zbox
proc `theme`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("THEME"))

proc `usersize=`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(value))

proc `usersize=`*(ih: Zbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Zbox_t, width, height:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("USERSIZE"), cstring(&"{width}x{height}"))

proc `usersize`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("USERSIZE"))

proc `value=`*(ih: Zbox_t, value: string) {.cdecl.} =
    # VALUE (non inheritable): The visible child accessed by its name.
    # The value passed must be the name of one of the children
    # contained in the zbox. Use IupSetHandle or IupSetAttributeHandle
    # to associate a child to a name. In Lua you can also use the
    # element reference directly. When the value is changed the
    # selected child is made visible and all other children are made
    # invisible, regardless their previous visible state.
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

proc `value`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUE"), cstring(value))

# TODO ??? String Binary zbox
proc `value`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE"))

proc `valuepos=`*(ih: Zbox_t, value: string) {.cdecl.} =
    # VALUEPOS (non inheritable): The visible child accessed by its
    # position. The value passed must be the index of a child
    # contained in the zbox, starting at 0. When the zbox is created,
    # the first element inserted is set as the visible child. (since
    # 3.0)
    SetAttribute(cast[PIhandle](ih), cstring("VALUEPOS"), cstring(value))

proc `valuepos`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUEPOS"), cstring(value))

proc `valuepos=`*(ih: Zbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUEPOS"), cstring(&"{x}"))

proc `valuepos`*(ih: Zbox_t, x:int) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VALUEPOS"), cstring(&"{x}"))

proc `valuepos`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUEPOS"))

proc `value_handle=`*(ih: Zbox_t, handle: User_t) {.cdecl.} =
    # VALUE_HANDLE (non inheritable): The visible child accessed by
    # its handle. The value passed must be the handle of a child
    # contained in the zbox. When the zbox is created, the first
    # element inserted is set as the visible child. (since 3.0)
    SetAttributeHandle(cast[PIhandle](ih), cstring("VALUE_HANDLE"), cast[PIhandle](handle))

proc `value_handle`*(ih: Zbox_t, handle: User_t) {.cdecl.} =
    SetAttributeHandle(cast[PIhandle](ih), cstring("VALUE_HANDLE"), cast[PIhandle](handle))

proc `value_handle`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VALUE_HANDLE"))

proc `visible=`*(ih: Zbox_t, value: string) {.cdecl.} =
    # The ZBOX relies on the VISIBLE attribute. If a child that is
    # hidden by the zbox has its VISIBLE attribute changed then it can
    # be made visible regardless of the zbox configuration. For the
    # zbox behave as a IupTabs use native containers as immediate
    # children of the zbox, like IupScrollBox, IupTabs, IupFrame or
    # IupBackgroundBox. The ZBOX relies on the VISIBLE attribute. If a
    # child that is hidden by the zbox has its VISIBLE attribute
    # changed then it can be made visible regardless of the zbox
    # configuration. For the zbox behave as a IupTabs use native
    # containers as immediate children of the zbox, like IupScrollBox,
    # IupTabs, IupFrame or IupBackgroundBox.
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible`*(ih: Zbox_t, value: string) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring(value))

proc `visible=`*(ih: Zbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Zbox_t, yes:bool) {.cdecl.} =
    SetAttribute(cast[PIhandle](ih), cstring("VISIBLE"), cstring((if yes: "YES" else: "NO")))

proc `visible`*(ih: Zbox_t): bool {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("VISIBLE")) == "YES"

proc `wid`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("WID"))

# TODO unknown: zbox XFONTID Unknown Binary
proc `xfontid`*(ih: Zbox_t): string {.cdecl.} =
    return $GetAttribute(cast[PIhandle](ih), cstring("XFONTID"))

proc `destroy_cb=`*(ih: Zbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # DESTROY_CB DESTROY_CB Called right before an element is
    # destroyed. Callback int function(Ihandle *ih); [in C]
    # ih:destroy_cb() -> (ret: number) [in Lua] ih: identifier of the
    # element that activated the event. Notes If the dialog is visible
    # then it is hidden before it is destroyed. The callback will be
    # called right after it is hidden. The callback will be called
    # before all other destroy procedures. For instance, if the
    # element has children then it is called before the children are
    # destroyed. For language binding implementations use the callback
    # name "LDESTROY_CB" to release memory allocated by the binding
    # for the element. Also the callback will be called before the
    # language callback. Affects All.
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Zbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("DESTROY_CB"), cast[Icallback](cb))

proc `destroy_cb`*(ih: Zbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("DESTROY_CB")))

proc `ldestroy_cb=`*(ih: Zbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Zbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB"), cast[Icallback](cb))

proc `ldestroy_cb`*(ih: Zbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("LDESTROY_CB")))

proc `map_cb=`*(ih: Zbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # MAP_CB MAP_CB Called right after an element is mapped and its
    # attributes updated in IupMap. When the element is a dialog, it
    # is called after the layout is updated. For all other elements is
    # called before the layout is updated, so the element current size
    # will still be 0x0 during MAP_CB (since 3.14). Callback int
    # function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    # Lua] ih: identifier of the element that activated the event.
    # Affects All that have a native representation.
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Zbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("MAP_CB"), cast[Icallback](cb))

proc `map_cb`*(ih: Zbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("MAP_CB")))

proc `postmessage_cb=`*(ih: Zbox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Zbox_t, cb: proc (ih: PIhandle, arg2: cstring, arg3: cint, arg4: cdouble, arg5: pointer): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB"), cast[Icallback](cb))

proc `postmessage_cb`*(ih: Zbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("POSTMESSAGE_CB")))

proc `unmap_cb=`*(ih: Zbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    # UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    # Callback int function(Ihandle *ih); [in C] ih:unmap_cb() ->
    # (ret: number) [in Lua] ih: identifier of the element that
    # activated the event. Affects All that have a native
    # representation.
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Zbox_t, cb: proc (ih: PIhandle): cint {.cdecl.}) {.cdecl.} =
    SetCallback(cast[PIhandle](ih), cstring("UNMAP_CB"), cast[Icallback](cb))

proc `unmap_cb`*(ih: Zbox_t): proc (ih: PIhandle): cint {.cdecl.} =
    return cast[proc (ih: PIhandle): cint {.cdecl.}](GetCallback(cast[PIhandle](ih), cstring("UNMAP_CB")))

proc cdVersion*(): string {.cdecl.} =
    return $niupc.cdVersion()

proc cdVersionDate*(): string {.cdecl.} =
    return $niupc.cdVersionDate()

proc cdVersionNumber*(): cint {.cdecl.} =
    return niupc.cdVersionNumber()

proc cdCreateCanvas*(context: ptr cdContext; data: pointer): ptr cdCanvas {.cdecl.} =
    return niupc.cdCreateCanvas(context, data)

proc cdKillCanvas*(canvas: ptr cdCanvas) {.cdecl.} =
    niupc.cdKillCanvas(canvas)

proc cdCanvasGetContext*(canvas: ptr cdCanvas): ptr cdContext {.cdecl.} =
    return niupc.cdCanvasGetContext(canvas)

proc cdCanvasActivate*(canvas: ptr cdCanvas): cint {.cdecl.} =
    return niupc.cdCanvasActivate(canvas)

proc cdCanvasDeactivate*(canvas: ptr cdCanvas) {.cdecl.} =
    niupc.cdCanvasDeactivate(canvas)

proc cdUseContextPlus*(use: cint): cint {.cdecl.} =
    return niupc.cdUseContextPlus(use)

proc cdInitContextPlus*() {.cdecl.} =
    niupc.cdInitContextPlus()

proc cdFinishContextPlus*() {.cdecl.} =
    niupc.cdFinishContextPlus()

proc cdContextRegisterCallback*(context: ptr cdContext; cb: cint; `func`: cdCallback): cint {.cdecl.} =
    return niupc.cdContextRegisterCallback(context, cb, `func`)

proc cdContextCaps*(context: ptr cdContext): culong {.cdecl.} =
    return niupc.cdContextCaps(context)

proc cdContextIsPlus*(context: ptr cdContext): cint {.cdecl.} =
    return niupc.cdContextIsPlus(context)

proc cdContextType*(context: ptr cdContext): cint {.cdecl.} =
    return niupc.cdContextType(context)

proc cdCanvasSimulate*(canvas: ptr cdCanvas; mode: cint): cint {.cdecl.} =
    return niupc.cdCanvasSimulate(canvas, mode)

proc cdCanvasFlush*(canvas: ptr cdCanvas) {.cdecl.} =
    niupc.cdCanvasFlush(canvas)

proc cdCanvasClear*(canvas: ptr cdCanvas) {.cdecl.} =
    niupc.cdCanvasClear(canvas)

proc cdCanvasSaveState*(canvas: ptr cdCanvas): ptr cdState {.cdecl.} =
    return niupc.cdCanvasSaveState(canvas)

proc cdCanvasRestoreState*(canvas: ptr cdCanvas; state: ptr cdState) {.cdecl.} =
    niupc.cdCanvasRestoreState(canvas, state)

proc cdReleaseState*(state: ptr cdState) {.cdecl.} =
    niupc.cdReleaseState(state)

proc cdCanvasSetAttribute*(canvas: ptr cdCanvas; name: string; data: string) {.cdecl.} =
    niupc.cdCanvasSetAttribute(canvas, cstring(name), cstring(data))

proc cdCanvasGetAttribute*(canvas: ptr cdCanvas; name: string): string {.cdecl.} =
    return $niupc.cdCanvasGetAttribute(canvas, cstring(name))

proc cdCanvasPlay*(canvas: ptr cdCanvas; context: ptr cdContext; xmin: cint; xmax: cint; ymin: cint; ymax: cint; data: pointer): cint {.cdecl.} =
    return niupc.cdCanvasPlay(canvas, context, xmin, xmax, ymin, ymax, data)

proc cdCanvasGetSize*(canvas: ptr cdCanvas; width: ptr cint; height: ptr cint; width_mm: ptr cdouble; height_mm: ptr cdouble) {.cdecl.} =
    niupc.cdCanvasGetSize(canvas, width, height, width_mm, height_mm)

proc cdCanvasUpdateYAxis*(canvas: ptr cdCanvas; y: ptr cint): cint {.cdecl.} =
    return niupc.cdCanvasUpdateYAxis(canvas, y)

proc cdfCanvasUpdateYAxis*(canvas: ptr cdCanvas; y: ptr cdouble): cdouble {.cdecl.} =
    return niupc.cdfCanvasUpdateYAxis(canvas, y)

proc cdCanvasInvertYAxis*(canvas: ptr cdCanvas; y: cint): cint {.cdecl.} =
    return niupc.cdCanvasInvertYAxis(canvas, y)

proc cdfCanvasInvertYAxis*(canvas: ptr cdCanvas; y: cdouble): cdouble {.cdecl.} =
    return niupc.cdfCanvasInvertYAxis(canvas, y)

proc cdCanvasMM2Pixel*(canvas: ptr cdCanvas; mm_dx: cdouble; mm_dy: cdouble; dx: ptr cint; dy: ptr cint) {.cdecl.} =
    niupc.cdCanvasMM2Pixel(canvas, mm_dx, mm_dy, dx, dy)

proc cdCanvasPixel2MM*(canvas: ptr cdCanvas; dx: cint; dy: cint; mm_dx: ptr cdouble; mm_dy: ptr cdouble) {.cdecl.} =
    niupc.cdCanvasPixel2MM(canvas, dx, dy, mm_dx, mm_dy)

proc cdfCanvasMM2Pixel*(canvas: ptr cdCanvas; mm_dx: cdouble; mm_dy: cdouble; dx: ptr cdouble; dy: ptr cdouble) {.cdecl.} =
    niupc.cdfCanvasMM2Pixel(canvas, mm_dx, mm_dy, dx, dy)

proc cdfCanvasPixel2MM*(canvas: ptr cdCanvas; dx: cdouble; dy: cdouble; mm_dx: ptr cdouble; mm_dy: ptr cdouble) {.cdecl.} =
    niupc.cdfCanvasPixel2MM(canvas, dx, dy, mm_dx, mm_dy)

proc cdCanvasOrigin*(canvas: ptr cdCanvas; x: cint; y: cint) {.cdecl.} =
    niupc.cdCanvasOrigin(canvas, x, y)

proc cdfCanvasOrigin*(canvas: ptr cdCanvas; x: cdouble; y: cdouble) {.cdecl.} =
    niupc.cdfCanvasOrigin(canvas, x, y)

proc cdCanvasGetOrigin*(canvas: ptr cdCanvas; x: ptr cint; y: ptr cint) {.cdecl.} =
    niupc.cdCanvasGetOrigin(canvas, x, y)

proc cdfCanvasGetOrigin*(canvas: ptr cdCanvas; x: ptr cdouble; y: ptr cdouble) {.cdecl.} =
    niupc.cdfCanvasGetOrigin(canvas, x, y)

proc cdCanvasTransform*(canvas: ptr cdCanvas; matrix: ptr cdouble) {.cdecl.} =
    niupc.cdCanvasTransform(canvas, matrix)

proc cdCanvasGetTransform*(canvas: ptr cdCanvas): ptr cdouble {.cdecl.} =
    return niupc.cdCanvasGetTransform(canvas)

proc cdCanvasTransformMultiply*(canvas: ptr cdCanvas; matrix: ptr cdouble) {.cdecl.} =
    niupc.cdCanvasTransformMultiply(canvas, matrix)

proc cdCanvasTransformRotate*(canvas: ptr cdCanvas; angle: cdouble) {.cdecl.} =
    niupc.cdCanvasTransformRotate(canvas, angle)

proc cdCanvasTransformScale*(canvas: ptr cdCanvas; sx: cdouble; sy: cdouble) {.cdecl.} =
    niupc.cdCanvasTransformScale(canvas, sx, sy)

proc cdCanvasTransformTranslate*(canvas: ptr cdCanvas; dx: cdouble; dy: cdouble) {.cdecl.} =
    niupc.cdCanvasTransformTranslate(canvas, dx, dy)

proc cdCanvasTransformPoint*(canvas: ptr cdCanvas; x: cint; y: cint; tx: ptr cint; ty: ptr cint) {.cdecl.} =
    niupc.cdCanvasTransformPoint(canvas, x, y, tx, ty)

proc cdfCanvasTransformPoint*(canvas: ptr cdCanvas; x: cdouble; y: cdouble; tx: ptr cdouble; ty: ptr cdouble) {.cdecl.} =
    niupc.cdfCanvasTransformPoint(canvas, x, y, tx, ty)

proc cdCanvasClip*(canvas: ptr cdCanvas; mode: cint): cint {.cdecl.} =
    return niupc.cdCanvasClip(canvas, mode)

proc cdCanvasClipArea*(canvas: ptr cdCanvas; xmin: cint; xmax: cint; ymin: cint; ymax: cint) {.cdecl.} =
    niupc.cdCanvasClipArea(canvas, xmin, xmax, ymin, ymax)

proc cdCanvasGetClipArea*(canvas: ptr cdCanvas; xmin: ptr cint; xmax: ptr cint; ymin: ptr cint; ymax: ptr cint): cint {.cdecl.} =
    return niupc.cdCanvasGetClipArea(canvas, xmin, xmax, ymin, ymax)

proc cdfCanvasClipArea*(canvas: ptr cdCanvas; xmin: cdouble; xmax: cdouble; ymin: cdouble; ymax: cdouble) {.cdecl.} =
    niupc.cdfCanvasClipArea(canvas, xmin, xmax, ymin, ymax)

proc cdfCanvasGetClipArea*(canvas: ptr cdCanvas; xmin: ptr cdouble; xmax: ptr cdouble; ymin: ptr cdouble; ymax: ptr cdouble): cint {.cdecl.} =
    return niupc.cdfCanvasGetClipArea(canvas, xmin, xmax, ymin, ymax)

proc cdCanvasIsPointInRegion*(canvas: ptr cdCanvas; x: cint; y: cint): cint {.cdecl.} =
    return niupc.cdCanvasIsPointInRegion(canvas, x, y)

proc cdCanvasOffsetRegion*(canvas: ptr cdCanvas; x: cint; y: cint) {.cdecl.} =
    niupc.cdCanvasOffsetRegion(canvas, x, y)

proc cdCanvasGetRegionBox*(canvas: ptr cdCanvas; xmin: ptr cint; xmax: ptr cint; ymin: ptr cint; ymax: ptr cint) {.cdecl.} =
    niupc.cdCanvasGetRegionBox(canvas, xmin, xmax, ymin, ymax)

proc cdCanvasRegionCombineMode*(canvas: ptr cdCanvas; mode: cint): cint {.cdecl.} =
    return niupc.cdCanvasRegionCombineMode(canvas, mode)

proc cdCanvasPixel*(canvas: ptr cdCanvas; x: cint; y: cint; color: clong) {.cdecl.} =
    niupc.cdCanvasPixel(canvas, x, y, color)

proc cdCanvasMark*(canvas: ptr cdCanvas; x: cint; y: cint) {.cdecl.} =
    niupc.cdCanvasMark(canvas, x, y)

proc cdfCanvasPixel*(canvas: ptr cdCanvas; x: cdouble; y: cdouble; color: clong) {.cdecl.} =
    niupc.cdfCanvasPixel(canvas, x, y, color)

proc cdfCanvasMark*(canvas: ptr cdCanvas; x: cdouble; y: cdouble) {.cdecl.} =
    niupc.cdfCanvasMark(canvas, x, y)

proc cdCanvasBegin*(canvas: ptr cdCanvas; mode: cint) {.cdecl.} =
    niupc.cdCanvasBegin(canvas, mode)

proc cdCanvasPathSet*(canvas: ptr cdCanvas; action: cint) {.cdecl.} =
    niupc.cdCanvasPathSet(canvas, action)

proc cdCanvasEnd*(canvas: ptr cdCanvas) {.cdecl.} =
    niupc.cdCanvasEnd(canvas)

proc cdCanvasLine*(canvas: ptr cdCanvas; x1: cint; y1: cint; x2: cint; y2: cint) {.cdecl.} =
    niupc.cdCanvasLine(canvas, x1, y1, x2, y2)

proc cdCanvasVertex*(canvas: ptr cdCanvas; x: cint; y: cint) {.cdecl.} =
    niupc.cdCanvasVertex(canvas, x, y)

proc cdCanvasRect*(canvas: ptr cdCanvas; xmin: cint; xmax: cint; ymin: cint; ymax: cint) {.cdecl.} =
    niupc.cdCanvasRect(canvas, xmin, xmax, ymin, ymax)

proc cdCanvasBox*(canvas: ptr cdCanvas; xmin: cint; xmax: cint; ymin: cint; ymax: cint) {.cdecl.} =
    niupc.cdCanvasBox(canvas, xmin, xmax, ymin, ymax)

proc cdCanvasArc*(canvas: ptr cdCanvas; xc: cint; yc: cint; w: cint; h: cint; angle1: cdouble; angle2: cdouble) {.cdecl.} =
    niupc.cdCanvasArc(canvas, xc, yc, w, h, angle1, angle2)

proc cdCanvasSector*(canvas: ptr cdCanvas; xc: cint; yc: cint; w: cint; h: cint; angle1: cdouble; angle2: cdouble) {.cdecl.} =
    niupc.cdCanvasSector(canvas, xc, yc, w, h, angle1, angle2)

proc cdCanvasChord*(canvas: ptr cdCanvas; xc: cint; yc: cint; w: cint; h: cint; angle1: cdouble; angle2: cdouble) {.cdecl.} =
    niupc.cdCanvasChord(canvas, xc, yc, w, h, angle1, angle2)

proc cdCanvasText*(canvas: ptr cdCanvas; x: cint; y: cint; s: string) {.cdecl.} =
    niupc.cdCanvasText(canvas, x, y, cstring(s))

proc cdfCanvasLine*(canvas: ptr cdCanvas; x1: cdouble; y1: cdouble; x2: cdouble; y2: cdouble) {.cdecl.} =
    niupc.cdfCanvasLine(canvas, x1, y1, x2, y2)

proc cdfCanvasVertex*(canvas: ptr cdCanvas; x: cdouble; y: cdouble) {.cdecl.} =
    niupc.cdfCanvasVertex(canvas, x, y)

proc cdfCanvasRect*(canvas: ptr cdCanvas; xmin: cdouble; xmax: cdouble; ymin: cdouble; ymax: cdouble) {.cdecl.} =
    niupc.cdfCanvasRect(canvas, xmin, xmax, ymin, ymax)

proc cdfCanvasBox*(canvas: ptr cdCanvas; xmin: cdouble; xmax: cdouble; ymin: cdouble; ymax: cdouble) {.cdecl.} =
    niupc.cdfCanvasBox(canvas, xmin, xmax, ymin, ymax)

proc cdfCanvasArc*(canvas: ptr cdCanvas; xc: cdouble; yc: cdouble; w: cdouble; h: cdouble; angle1: cdouble; angle2: cdouble) {.cdecl.} =
    niupc.cdfCanvasArc(canvas, xc, yc, w, h, angle1, angle2)

proc cdfCanvasSector*(canvas: ptr cdCanvas; xc: cdouble; yc: cdouble; w: cdouble; h: cdouble; angle1: cdouble; angle2: cdouble) {.cdecl.} =
    niupc.cdfCanvasSector(canvas, xc, yc, w, h, angle1, angle2)

proc cdfCanvasChord*(canvas: ptr cdCanvas; xc: cdouble; yc: cdouble; w: cdouble; h: cdouble; angle1: cdouble; angle2: cdouble) {.cdecl.} =
    niupc.cdfCanvasChord(canvas, xc, yc, w, h, angle1, angle2)

proc cdfCanvasText*(canvas: ptr cdCanvas; x: cdouble; y: cdouble; s: string) {.cdecl.} =
    niupc.cdfCanvasText(canvas, x, y, cstring(s))

proc cdCanvasSetBackground*(canvas: ptr cdCanvas; color: clong) {.cdecl.} =
    niupc.cdCanvasSetBackground(canvas, color)

proc cdCanvasSetForeground*(canvas: ptr cdCanvas; color: clong) {.cdecl.} =
    niupc.cdCanvasSetForeground(canvas, color)

proc cdCanvasBackground*(canvas: ptr cdCanvas; color: clong): clong {.cdecl.} =
    return niupc.cdCanvasBackground(canvas, color)

proc cdCanvasForeground*(canvas: ptr cdCanvas; color: clong): clong {.cdecl.} =
    return niupc.cdCanvasForeground(canvas, color)

proc cdCanvasBackOpacity*(canvas: ptr cdCanvas; opacity: cint): cint {.cdecl.} =
    return niupc.cdCanvasBackOpacity(canvas, opacity)

proc cdCanvasWriteMode*(canvas: ptr cdCanvas; mode: cint): cint {.cdecl.} =
    return niupc.cdCanvasWriteMode(canvas, mode)

proc cdCanvasLineStyle*(canvas: ptr cdCanvas; style: cint): cint {.cdecl.} =
    return niupc.cdCanvasLineStyle(canvas, style)

proc cdCanvasLineStyleDashes*(canvas: ptr cdCanvas; dashes: ptr cint; count: cint) {.cdecl.} =
    niupc.cdCanvasLineStyleDashes(canvas, dashes, count)

proc cdCanvasLineWidth*(canvas: ptr cdCanvas; width: cint): cint {.cdecl.} =
    return niupc.cdCanvasLineWidth(canvas, width)

proc cdCanvasLineJoin*(canvas: ptr cdCanvas; join: cint): cint {.cdecl.} =
    return niupc.cdCanvasLineJoin(canvas, join)

proc cdCanvasLineCap*(canvas: ptr cdCanvas; cap: cint): cint {.cdecl.} =
    return niupc.cdCanvasLineCap(canvas, cap)

proc cdCanvasInteriorStyle*(canvas: ptr cdCanvas; style: cint): cint {.cdecl.} =
    return niupc.cdCanvasInteriorStyle(canvas, style)

proc cdCanvasHatch*(canvas: ptr cdCanvas; style: cint): cint {.cdecl.} =
    return niupc.cdCanvasHatch(canvas, style)

proc cdCanvasStipple*(canvas: ptr cdCanvas; w: cint; h: cint; stipple: openArray[uint8]) {.cdecl.} =
    niupc.cdCanvasStipple(canvas, w, h, cast[ptr uint8](stipple))

proc cdCanvasGetStipple*(canvas: ptr cdCanvas; n: ptr cint; m: ptr cint): ptr uint8 {.cdecl.} =
    return niupc.cdCanvasGetStipple(canvas, n, m)

proc cdCanvasPattern*(canvas: ptr cdCanvas; w: cint; h: cint; pattern: ptr clong) {.cdecl.} =
    niupc.cdCanvasPattern(canvas, w, h, pattern)

proc cdCanvasGetPattern*(canvas: ptr cdCanvas; n: ptr cint; m: ptr cint): ptr clong {.cdecl.} =
    return niupc.cdCanvasGetPattern(canvas, n, m)

proc cdCanvasFillMode*(canvas: ptr cdCanvas; mode: cint): cint {.cdecl.} =
    return niupc.cdCanvasFillMode(canvas, mode)

proc cdCanvasFont*(canvas: ptr cdCanvas; type_face: string; style: cint; size: cint): cint {.cdecl.} =
    return niupc.cdCanvasFont(canvas, cstring(type_face), style, size)

proc cdCanvasGetFont*(canvas: ptr cdCanvas; type_face: string; style: ptr cint; size: ptr cint) {.cdecl.} =
    niupc.cdCanvasGetFont(canvas, cstring(type_face), style, size)

proc cdCanvasNativeFont*(canvas: ptr cdCanvas; font: string): string {.cdecl.} =
    return $niupc.cdCanvasNativeFont(canvas, cstring(font))

proc cdCanvasTextAlignment*(canvas: ptr cdCanvas; alignment: cint): cint {.cdecl.} =
    return niupc.cdCanvasTextAlignment(canvas, alignment)

proc cdCanvasTextOrientation*(canvas: ptr cdCanvas; angle: cdouble): cdouble {.cdecl.} =
    return niupc.cdCanvasTextOrientation(canvas, angle)

proc cdCanvasMarkType*(canvas: ptr cdCanvas; `type`: cint): cint {.cdecl.} =
    return niupc.cdCanvasMarkType(canvas, `type`)

proc cdCanvasMarkSize*(canvas: ptr cdCanvas; size: cint): cint {.cdecl.} =
    return niupc.cdCanvasMarkSize(canvas, size)

proc cdCanvasVectorText*(canvas: ptr cdCanvas; x: cint; y: cint; s: string) {.cdecl.} =
    niupc.cdCanvasVectorText(canvas, x, y, cstring(s))

proc cdCanvasMultiLineVectorText*(canvas: ptr cdCanvas; x: cint; y: cint; s: string) {.cdecl.} =
    niupc.cdCanvasMultiLineVectorText(canvas, x, y, cstring(s))

proc cdCanvasVectorFont*(canvas: ptr cdCanvas; filename: string): string {.cdecl.} =
    return $niupc.cdCanvasVectorFont(canvas, cstring(filename))

proc cdCanvasVectorTextDirection*(canvas: ptr cdCanvas; x1: cint; y1: cint; x2: cint; y2: cint) {.cdecl.} =
    niupc.cdCanvasVectorTextDirection(canvas, x1, y1, x2, y2)

proc cdCanvasVectorTextTransform*(canvas: ptr cdCanvas; matrix: ptr cdouble): ptr cdouble {.cdecl.} =
    return niupc.cdCanvasVectorTextTransform(canvas, matrix)

proc cdCanvasVectorTextSize*(canvas: ptr cdCanvas; size_x: cint; size_y: cint; s: string) {.cdecl.} =
    niupc.cdCanvasVectorTextSize(canvas, size_x, size_y, cstring(s))

proc cdCanvasVectorCharSize*(canvas: ptr cdCanvas; size: cint): cint {.cdecl.} =
    return niupc.cdCanvasVectorCharSize(canvas, size)

proc cdCanvasVectorFontSize*(canvas: ptr cdCanvas; size_x: cdouble; size_y: cdouble) {.cdecl.} =
    niupc.cdCanvasVectorFontSize(canvas, size_x, size_y)

proc cdCanvasGetVectorFontSize*(canvas: ptr cdCanvas; size_x: ptr cdouble; size_y: ptr cdouble) {.cdecl.} =
    niupc.cdCanvasGetVectorFontSize(canvas, size_x, size_y)

proc cdCanvasGetVectorTextSize*(canvas: ptr cdCanvas; s: string; x: ptr cint; y: ptr cint) {.cdecl.} =
    niupc.cdCanvasGetVectorTextSize(canvas, cstring(s), x, y)

proc cdCanvasGetVectorTextBounds*(canvas: ptr cdCanvas; s: string; x: cint; y: cint; rect: ptr cint) {.cdecl.} =
    niupc.cdCanvasGetVectorTextBounds(canvas, cstring(s), x, y, rect)

proc cdCanvasGetVectorTextBox*(canvas: ptr cdCanvas; x: cint; y: cint; s: string; xmin: ptr cint; xmax: ptr cint; ymin: ptr cint; ymax: ptr cint) {.cdecl.} =
    niupc.cdCanvasGetVectorTextBox(canvas, x, y, cstring(s), xmin, xmax, ymin, ymax)

proc cdfCanvasVectorTextDirection*(canvas: ptr cdCanvas; x1: cdouble; y1: cdouble; x2: cdouble; y2: cdouble) {.cdecl.} =
    niupc.cdfCanvasVectorTextDirection(canvas, x1, y1, x2, y2)

proc cdfCanvasVectorTextSize*(canvas: ptr cdCanvas; size_x: cdouble; size_y: cdouble; s: string) {.cdecl.} =
    niupc.cdfCanvasVectorTextSize(canvas, size_x, size_y, cstring(s))

proc cdfCanvasGetVectorTextSize*(canvas: ptr cdCanvas; s: string; x: ptr cdouble; y: ptr cdouble) {.cdecl.} =
    niupc.cdfCanvasGetVectorTextSize(canvas, cstring(s), x, y)

proc cdfCanvasVectorCharSize*(canvas: ptr cdCanvas; size: cdouble): cdouble {.cdecl.} =
    return niupc.cdfCanvasVectorCharSize(canvas, size)

proc cdfCanvasVectorText*(canvas: ptr cdCanvas; x: cdouble; y: cdouble; s: string) {.cdecl.} =
    niupc.cdfCanvasVectorText(canvas, x, y, cstring(s))

proc cdfCanvasMultiLineVectorText*(canvas: ptr cdCanvas; x: cdouble; y: cdouble; s: string) {.cdecl.} =
    niupc.cdfCanvasMultiLineVectorText(canvas, x, y, cstring(s))

proc cdfCanvasGetVectorTextBounds*(canvas: ptr cdCanvas; s: string; x: cdouble; y: cdouble; rect: ptr cdouble) {.cdecl.} =
    niupc.cdfCanvasGetVectorTextBounds(canvas, cstring(s), x, y, rect)

proc cdfCanvasGetVectorTextBox*(canvas: ptr cdCanvas; x: cdouble; y: cdouble; s: string; xmin: ptr cdouble; xmax: ptr cdouble; ymin: ptr cdouble; ymax: ptr cdouble) {.cdecl.} =
    niupc.cdfCanvasGetVectorTextBox(canvas, x, y, cstring(s), xmin, xmax, ymin, ymax)

proc cdCanvasGetFontDim*(canvas: ptr cdCanvas; max_width: ptr cint; height: ptr cint; ascent: ptr cint; descent: ptr cint) {.cdecl.} =
    niupc.cdCanvasGetFontDim(canvas, max_width, height, ascent, descent)

proc cdCanvasGetTextSize*(canvas: ptr cdCanvas; s: string; width: ptr cint; height: ptr cint) {.cdecl.} =
    niupc.cdCanvasGetTextSize(canvas, cstring(s), width, height)

proc cdCanvasGetTextBox*(canvas: ptr cdCanvas; x: cint; y: cint; s: string; xmin: ptr cint; xmax: ptr cint; ymin: ptr cint; ymax: ptr cint) {.cdecl.} =
    niupc.cdCanvasGetTextBox(canvas, x, y, cstring(s), xmin, xmax, ymin, ymax)

proc cdfCanvasGetTextBox*(canvas: ptr cdCanvas; x: cdouble; y: cdouble; s: string; xmin: ptr cdouble; xmax: ptr cdouble; ymin: ptr cdouble; ymax: ptr cdouble) {.cdecl.} =
    niupc.cdfCanvasGetTextBox(canvas, x, y, cstring(s), xmin, xmax, ymin, ymax)

proc cdCanvasGetTextBounds*(canvas: ptr cdCanvas; x: cint; y: cint; s: string; rect: ptr cint) {.cdecl.} =
    niupc.cdCanvasGetTextBounds(canvas, x, y, cstring(s), rect)

proc cdfCanvasGetTextBounds*(canvas: ptr cdCanvas; x: cdouble; y: cdouble; s: string; rect: ptr cdouble) {.cdecl.} =
    niupc.cdfCanvasGetTextBounds(canvas, x, y, cstring(s), rect)

proc cdCanvasGetColorPlanes*(canvas: ptr cdCanvas): cint {.cdecl.} =
    return niupc.cdCanvasGetColorPlanes(canvas)

proc cdCanvasPalette*(canvas: ptr cdCanvas; n: cint; palette: ptr clong; mode: cint) {.cdecl.} =
    niupc.cdCanvasPalette(canvas, n, palette, mode)

proc cdCanvasGetImageRGB*(canvas: ptr cdCanvas; r: openArray[uint8]; g: openArray[uint8]; b: openArray[uint8]; x: cint; y: cint; iw: cint; ih: cint) {.cdecl.} =
    niupc.cdCanvasGetImageRGB(canvas, cast[ptr uint8](r), cast[ptr uint8](g), cast[ptr uint8](b), x, y, iw, ih)

proc cdCanvasPutImageRectRGB*(canvas: ptr cdCanvas; iw: cint; ih: cint; r: openArray[uint8]; g: openArray[uint8]; b: openArray[uint8]; x: cint; y: cint; w: cint; h: cint; xmin: cint; xmax: cint; ymin: cint; ymax: cint) {.cdecl.} =
    niupc.cdCanvasPutImageRectRGB(canvas, iw, ih, cast[ptr uint8](r), cast[ptr uint8](g), cast[ptr uint8](b), x, y, w, h, xmin, xmax, ymin, ymax)

proc cdCanvasPutImageRectRGBA*(canvas: ptr cdCanvas; iw: cint; ih: cint; r: openArray[uint8]; g: openArray[uint8]; b: openArray[uint8]; a: openArray[uint8]; x: cint; y: cint; w: cint; h: cint; xmin: cint; xmax: cint; ymin: cint; ymax: cint) {.cdecl.} =
    niupc.cdCanvasPutImageRectRGBA(canvas, iw, ih, cast[ptr uint8](r), cast[ptr uint8](g), cast[ptr uint8](b), cast[ptr uint8](a), x, y, w, h, xmin, xmax, ymin, ymax)

proc cdCanvasPutImageRectMap*(canvas: ptr cdCanvas; iw: cint; ih: cint; index: openArray[uint8]; colors: ptr clong; x: cint; y: cint; w: cint; h: cint; xmin: cint; xmax: cint; ymin: cint; ymax: cint) {.cdecl.} =
    niupc.cdCanvasPutImageRectMap(canvas, iw, ih, cast[ptr uint8](index), colors, x, y, w, h, xmin, xmax, ymin, ymax)

proc cdfCanvasPutImageRectRGB*(canvas: ptr cdCanvas; iw: cint; ih: cint; r: openArray[uint8]; g: openArray[uint8]; b: openArray[uint8]; x: cdouble; y: cdouble; w: cdouble; h: cdouble; xmin: cint; xmax: cint; ymin: cint; ymax: cint) {.cdecl.} =
    niupc.cdfCanvasPutImageRectRGB(canvas, iw, ih, cast[ptr uint8](r), cast[ptr uint8](g), cast[ptr uint8](b), x, y, w, h, xmin, xmax, ymin, ymax)

proc cdfCanvasPutImageRectRGBA*(canvas: ptr cdCanvas; iw: cint; ih: cint; r: openArray[uint8]; g: openArray[uint8]; b: openArray[uint8]; a: openArray[uint8]; x: cdouble; y: cdouble; w: cdouble; h: cdouble; xmin: cint; xmax: cint; ymin: cint; ymax: cint) {.cdecl.} =
    niupc.cdfCanvasPutImageRectRGBA(canvas, iw, ih, cast[ptr uint8](r), cast[ptr uint8](g), cast[ptr uint8](b), cast[ptr uint8](a), x, y, w, h, xmin, xmax, ymin, ymax)

proc cdfCanvasPutImageRectMap*(canvas: ptr cdCanvas; iw: cint; ih: cint; index: openArray[uint8]; colors: ptr clong; x: cdouble; y: cdouble; w: cdouble; h: cdouble; xmin: cint; xmax: cint; ymin: cint; ymax: cint) {.cdecl.} =
    niupc.cdfCanvasPutImageRectMap(canvas, iw, ih, cast[ptr uint8](index), colors, x, y, w, h, xmin, xmax, ymin, ymax)

proc cdCanvasCreateImage*(canvas: ptr cdCanvas; w: cint; h: cint): ptr cdImage {.cdecl.} =
    return niupc.cdCanvasCreateImage(canvas, w, h)

proc cdKillImage*(image: ptr cdImage) {.cdecl.} =
    niupc.cdKillImage(image)

proc cdCanvasGetImage*(canvas: ptr cdCanvas; image: ptr cdImage; x: cint; y: cint) {.cdecl.} =
    niupc.cdCanvasGetImage(canvas, image, x, y)

proc cdCanvasPutImageRect*(canvas: ptr cdCanvas; image: ptr cdImage; x: cint; y: cint; xmin: cint; xmax: cint; ymin: cint; ymax: cint) {.cdecl.} =
    niupc.cdCanvasPutImageRect(canvas, image, x, y, xmin, xmax, ymin, ymax)

proc cdCanvasScrollArea*(canvas: ptr cdCanvas; xmin: cint; xmax: cint; ymin: cint; ymax: cint; dx: cint; dy: cint) {.cdecl.} =
    niupc.cdCanvasScrollArea(canvas, xmin, xmax, ymin, ymax, dx, dy)

proc cdCreateBitmap*(w: cint; h: cint; `type`: cint): ptr cdBitmap {.cdecl.} =
    return niupc.cdCreateBitmap(w, h, `type`)

proc cdKillBitmap*(bitmap: ptr cdBitmap) {.cdecl.} =
    niupc.cdKillBitmap(bitmap)

proc cdBitmapGetData*(bitmap: ptr cdBitmap; dataptr: cint): ptr uint8 {.cdecl.} =
    return niupc.cdBitmapGetData(bitmap, dataptr)

proc cdBitmapSetRect*(bitmap: ptr cdBitmap; xmin: cint; xmax: cint; ymin: cint; ymax: cint) {.cdecl.} =
    niupc.cdBitmapSetRect(bitmap, xmin, xmax, ymin, ymax)

proc cdCanvasPutBitmap*(canvas: ptr cdCanvas; bitmap: ptr cdBitmap; x: cint; y: cint; w: cint; h: cint) {.cdecl.} =
    niupc.cdCanvasPutBitmap(canvas, bitmap, x, y, w, h)

proc cdCanvasGetBitmap*(canvas: ptr cdCanvas; bitmap: ptr cdBitmap; x: cint; y: cint) {.cdecl.} =
    niupc.cdCanvasGetBitmap(canvas, bitmap, x, y)

proc cdBitmapRGB2Map*(bitmap_rgb: ptr cdBitmap; bitmap_map: ptr cdBitmap) {.cdecl.} =
    niupc.cdBitmapRGB2Map(bitmap_rgb, bitmap_map)

proc cdEncodeColor*(red: uint8; green: uint8; blue: uint8): clong {.cdecl.} =
    return niupc.cdEncodeColor(red, green, blue)

proc cdEncodeColorAlpha*(red: uint8; green: uint8; blue: uint8; alpha: uint8): clong {.cdecl.} =
    return niupc.cdEncodeColorAlpha(red, green, blue, alpha)

proc cdEncodeAlpha*(color: clong; alpha: uint8): clong {.cdecl.} =
    return niupc.cdEncodeAlpha(color, alpha)

proc cdDecodeColor*(color: clong; red: openArray[uint8]; green: openArray[uint8]; blue: openArray[uint8]) {.cdecl.} =
    niupc.cdDecodeColor(color, cast[ptr uint8](red), cast[ptr uint8](green), cast[ptr uint8](blue))

proc cdDecodeColorAlpha*(color: clong; red: openArray[uint8]; green: openArray[uint8]; blue: openArray[uint8]; alpha: openArray[uint8]) {.cdecl.} =
    niupc.cdDecodeColorAlpha(color, cast[ptr uint8](red), cast[ptr uint8](green), cast[ptr uint8](blue), cast[ptr uint8](alpha))

proc cdDecodeAlpha*(color: clong): uint8 {.cdecl.} =
    return niupc.cdDecodeAlpha(color)

proc cdRGB2Map*(width: cint; height: cint; red: openArray[uint8]; green: openArray[uint8]; blue: openArray[uint8]; index: openArray[uint8]; pal_size: cint; color: ptr clong) {.cdecl.} =
    niupc.cdRGB2Map(width, height, cast[ptr uint8](red), cast[ptr uint8](green), cast[ptr uint8](blue), cast[ptr uint8](index), pal_size, color)

proc cdContextIup*(): ptr cdContext {.cdecl.} =
    return niupc.cdContextIup()

proc cdContextIupDBuffer*(): ptr cdContext {.cdecl.} =
    return niupc.cdContextIupDBuffer()

proc cdContextIupDBufferRGB*(): ptr cdContext {.cdecl.} =
    return niupc.cdContextIupDBufferRGB()

proc cdContextPrinter*(): ptr cdContext {.cdecl.} =
    return niupc.cdContextPrinter()

proc cdContextImageRGB*(): ptr cdContext {.cdecl.} =
    return niupc.cdContextImageRGB()

proc cdContextDBufferRGB*(): ptr cdContext {.cdecl.} =
    return niupc.cdContextDBufferRGB()

proc cdRedImage*(cnv: ptr cdCanvas): ptr uint8 {.cdecl.} =
    return niupc.cdRedImage(cnv)

proc cdGreenImage*(cnv: ptr cdCanvas): ptr uint8 {.cdecl.} =
    return niupc.cdGreenImage(cnv)

proc cdBlueImage*(cnv: ptr cdCanvas): ptr uint8 {.cdecl.} =
    return niupc.cdBlueImage(cnv)

proc cdAlphaImage*(cnv: ptr cdCanvas): ptr uint8 {.cdecl.} =
    return niupc.cdAlphaImage(cnv)

proc imFileOpen*(file_name: string; error: ptr imErrorCodes): ptr imFile {.cdecl.} =
    return niupc.imFileOpen(cstring(file_name), error)

proc imFileOpenAs*(file_name: string; format: string; error: ptr imErrorCodes): ptr imFile {.cdecl.} =
    return niupc.imFileOpenAs(cstring(file_name), cstring(format), error)

proc imFileNew*(file_name: string; format: string; error: ptr imErrorCodes): ptr imFile {.cdecl.} =
    return niupc.imFileNew(cstring(file_name), cstring(format), error)

proc imFileClose*(ifile: ptr imFile) {.cdecl.} =
    niupc.imFileClose(ifile)

proc imFileHandle*(ifile: ptr imFile; index: cint): pointer {.cdecl.} =
    return niupc.imFileHandle(ifile, index)

proc imFileGetInfo*(ifile: ptr imFile; format: string; compression: string; image_count: ptr cint) {.cdecl.} =
    niupc.imFileGetInfo(ifile, cstring(format), cstring(compression), image_count)

proc imFileSetInfo*(ifile: ptr imFile; compression: string) {.cdecl.} =
    niupc.imFileSetInfo(ifile, cstring(compression))

proc imFileSetAttribute*(ifile: ptr imFile; attrib: string; data_type: imDataType; count: cint; data: pointer) {.cdecl.} =
    niupc.imFileSetAttribute(ifile, cstring(attrib), data_type, count, data)

proc imFileSetAttribInteger*(ifile: ptr imFile; attrib: string; data_type: imDataType; value: cint) {.cdecl.} =
    niupc.imFileSetAttribInteger(ifile, cstring(attrib), data_type, value)

proc imFileSetAttribReal*(ifile: ptr imFile; attrib: string; data_type: imDataType; value: cdouble) {.cdecl.} =
    niupc.imFileSetAttribReal(ifile, cstring(attrib), data_type, value)

proc imFileSetAttribString*(ifile: ptr imFile; attrib: string; value: string) {.cdecl.} =
    niupc.imFileSetAttribString(ifile, cstring(attrib), cstring(value))

proc imFileGetAttribute*(ifile: ptr imFile; attrib: string; data_type: ptr cint; count: ptr cint): pointer {.cdecl.} =
    return niupc.imFileGetAttribute(ifile, cstring(attrib), data_type, count)

proc imFileGetAttribInteger*(ifile: ptr imFile; attrib: string; index: cint): cint {.cdecl.} =
    return niupc.imFileGetAttribInteger(ifile, cstring(attrib), index)

proc imFileGetAttribReal*(ifile: ptr imFile; attrib: string; index: cint): cdouble {.cdecl.} =
    return niupc.imFileGetAttribReal(ifile, cstring(attrib), index)

proc imFileGetAttribString*(ifile: ptr imFile; attrib: string): string {.cdecl.} =
    return $niupc.imFileGetAttribString(ifile, cstring(attrib))

proc imFileGetAttributeList*(ifile: ptr imFile; attrib: cstringArray; attrib_count: ptr cint) {.cdecl.} =
    niupc.imFileGetAttributeList(ifile, attrib, attrib_count)

proc imFileGetPalette*(ifile: ptr imFile; palette: ptr clong; palette_count: ptr cint) {.cdecl.} =
    niupc.imFileGetPalette(ifile, palette, palette_count)

proc imFileSetPalette*(ifile: ptr imFile; palette: ptr clong; palette_count: cint) {.cdecl.} =
    niupc.imFileSetPalette(ifile, palette, palette_count)

proc imFileReadImageInfo*(ifile: ptr imFile; index: cint; width: ptr cint; height: ptr cint; file_color_mode: ptr cint; file_data_type: ptr cint): cint {.cdecl.} =
    return niupc.imFileReadImageInfo(ifile, index, width, height, file_color_mode, file_data_type)

proc imFileWriteImageInfo*(ifile: ptr imFile; width: cint; height: cint; user_color_mode: cint; user_data_type: cint): cint {.cdecl.} =
    return niupc.imFileWriteImageInfo(ifile, width, height, user_color_mode, user_data_type)

proc imFileReadImageData*(ifile: ptr imFile; data: pointer; convert2bitmap: cint; color_mode_flags: cint): cint {.cdecl.} =
    return niupc.imFileReadImageData(ifile, data, convert2bitmap, color_mode_flags)

proc imFileWriteImageData*(ifile: ptr imFile; data: pointer): cint {.cdecl.} =
    return niupc.imFileWriteImageData(ifile, data)

proc imFormatRegisterInternal*() {.cdecl.} =
    niupc.imFormatRegisterInternal()

proc imFormatRemoveAll*() {.cdecl.} =
    niupc.imFormatRemoveAll()

proc imFormatList*(format_list: cstringArray; format_count: ptr cint) {.cdecl.} =
    niupc.imFormatList(format_list, format_count)

proc imFormatInfo*(format: string; desc: string; ext: string; can_sequence: ptr cint): cint {.cdecl.} =
    return niupc.imFormatInfo(cstring(format), cstring(desc), cstring(ext), can_sequence)

proc imFormatInfoExtra*(format: string; extra: string): cint {.cdecl.} =
    return niupc.imFormatInfoExtra(cstring(format), cstring(extra))

proc imFormatCompressions*(format: string; comp: cstringArray; comp_count: ptr cint; color_mode: cint; data_type: imDataType): cint {.cdecl.} =
    return niupc.imFormatCompressions(cstring(format), comp, comp_count, color_mode, data_type)

proc imFormatCanWriteImage*(format: string; compression: string; color_mode: cint; data_type: imDataType): cint {.cdecl.} =
    return niupc.imFormatCanWriteImage(cstring(format), cstring(compression), color_mode, data_type)

proc imImageCreate*(width: cint; height: cint; color_space: imColorSpace; data_type: imDataType): ptr imImage {.cdecl.} =
    return niupc.imImageCreate(width, height, color_space, data_type)

proc imImageInit*(width: cint; height: cint; color_mode: cint; data_type: imDataType; data_buffer: pointer; palette: ptr clong; palette_count: cint): ptr imImage {.cdecl.} =
    return niupc.imImageInit(width, height, color_mode, data_type, data_buffer, palette, palette_count)

proc imImageCreateBased*(image: ptr imImage; width: cint; height: cint; color_space: imColorSpace; data_type: imDataType): ptr imImage {.cdecl.} =
    return niupc.imImageCreateBased(image, width, height, color_space, data_type)

proc imImageDestroy*(image: ptr imImage) {.cdecl.} =
    niupc.imImageDestroy(image)

proc imImageAddAlpha*(image: ptr imImage) {.cdecl.} =
    niupc.imImageAddAlpha(image)

proc imImageSetAlpha*(image: ptr imImage; alpha: cdouble) {.cdecl.} =
    niupc.imImageSetAlpha(image, alpha)

proc imImageRemoveAlpha*(image: ptr imImage) {.cdecl.} =
    niupc.imImageRemoveAlpha(image)

proc imImageReshape*(image: ptr imImage; width: cint; height: cint) {.cdecl.} =
    niupc.imImageReshape(image, width, height)

proc imImageCopy*(src_image: ptr imImage; dst_image: ptr imImage) {.cdecl.} =
    niupc.imImageCopy(src_image, dst_image)

proc imImageCopyData*(src_image: ptr imImage; dst_image: ptr imImage) {.cdecl.} =
    niupc.imImageCopyData(src_image, dst_image)

proc imImageCopyAttributes*(src_image: ptr imImage; dst_image: ptr imImage) {.cdecl.} =
    niupc.imImageCopyAttributes(src_image, dst_image)

proc imImageMergeAttributes*(src_image: ptr imImage; dst_image: ptr imImage) {.cdecl.} =
    niupc.imImageMergeAttributes(src_image, dst_image)

proc imImageCopyPlane*(src_image: ptr imImage; src_plane: cint; dst_image: ptr imImage; dst_plane: cint) {.cdecl.} =
    niupc.imImageCopyPlane(src_image, src_plane, dst_image, dst_plane)

proc imImageDuplicate*(image: ptr imImage): ptr imImage {.cdecl.} =
    return niupc.imImageDuplicate(image)

proc imImageClone*(image: ptr imImage): ptr imImage {.cdecl.} =
    return niupc.imImageClone(image)

proc imImageSetAttribute*(image: ptr imImage; attrib: string; data_type: imDataType; count: cint; data: pointer) {.cdecl.} =
    niupc.imImageSetAttribute(image, cstring(attrib), data_type, count, data)

proc imImageSetAttribInteger*(image: ptr imImage; attrib: string; data_type: imDataType; value: cint) {.cdecl.} =
    niupc.imImageSetAttribInteger(image, cstring(attrib), data_type, value)

proc imImageSetAttribReal*(image: ptr imImage; attrib: string; data_type: imDataType; value: cdouble) {.cdecl.} =
    niupc.imImageSetAttribReal(image, cstring(attrib), data_type, value)

proc imImageSetAttribString*(image: ptr imImage; attrib: string; value: string) {.cdecl.} =
    niupc.imImageSetAttribString(image, cstring(attrib), cstring(value))

proc imImageGetAttribute*(image: ptr imImage; attrib: string; data_type: ptr cint; count: ptr cint): pointer {.cdecl.} =
    return niupc.imImageGetAttribute(image, cstring(attrib), data_type, count)

proc imImageGetAttribInteger*(image: ptr imImage; attrib: string; index: cint): cint {.cdecl.} =
    return niupc.imImageGetAttribInteger(image, cstring(attrib), index)

proc imImageGetAttribReal*(image: ptr imImage; attrib: string; index: cint): cdouble {.cdecl.} =
    return niupc.imImageGetAttribReal(image, cstring(attrib), index)

proc imImageGetAttribString*(image: ptr imImage; attrib: string): string {.cdecl.} =
    return $niupc.imImageGetAttribString(image, cstring(attrib))

proc imImageGetAttributeList*(image: ptr imImage; attrib: cstringArray; attrib_count: ptr cint) {.cdecl.} =
    niupc.imImageGetAttributeList(image, attrib, attrib_count)

proc imImageClear*(image: ptr imImage) {.cdecl.} =
    niupc.imImageClear(image)

proc imImageIsBitmap*(image: ptr imImage): cint {.cdecl.} =
    return niupc.imImageIsBitmap(image)

proc imImageSetPalette*(image: ptr imImage; palette: ptr clong; palette_count: cint) {.cdecl.} =
    niupc.imImageSetPalette(image, palette, palette_count)

proc imImageMatchSize*(image1: ptr imImage; image2: ptr imImage): cint {.cdecl.} =
    return niupc.imImageMatchSize(image1, image2)

proc imImageMatchColor*(image1: ptr imImage; image2: ptr imImage): cint {.cdecl.} =
    return niupc.imImageMatchColor(image1, image2)

proc imImageMatchDataType*(image1: ptr imImage; image2: ptr imImage): cint {.cdecl.} =
    return niupc.imImageMatchDataType(image1, image2)

proc imImageMatchColorSpace*(image1: ptr imImage; image2: ptr imImage): cint {.cdecl.} =
    return niupc.imImageMatchColorSpace(image1, image2)

proc imImageMatch*(image1: ptr imImage; image2: ptr imImage): cint {.cdecl.} =
    return niupc.imImageMatch(image1, image2)

proc imImageSetMap*(image: ptr imImage) {.cdecl.} =
    niupc.imImageSetMap(image)

proc imImageSetBinary*(image: ptr imImage) {.cdecl.} =
    niupc.imImageSetBinary(image)

proc imImageSetGray*(image: ptr imImage) {.cdecl.} =
    niupc.imImageSetGray(image)

proc imImageMakeBinary*(image: ptr imImage) {.cdecl.} =
    niupc.imImageMakeBinary(image)

proc imImageMakeGray*(image: ptr imImage) {.cdecl.} =
    niupc.imImageMakeGray(image)

proc imFileLoadImage*(ifile: ptr imFile; index: cint; error: ptr imErrorCodes): ptr imImage {.cdecl.} =
    return niupc.imFileLoadImage(ifile, index, error)

proc imFileLoadImageFrame*(ifile: ptr imFile; index: cint; image: ptr imImage; error: ptr imErrorCodes) {.cdecl.} =
    niupc.imFileLoadImageFrame(ifile, index, image, error)

proc imFileLoadBitmap*(ifile: ptr imFile; index: cint; error: ptr imErrorCodes): ptr imImage {.cdecl.} =
    return niupc.imFileLoadBitmap(ifile, index, error)

proc imFileLoadImageRegion*(ifile: ptr imFile; index: cint; bitmap: cint; error: ptr imErrorCodes; xmin: cint; xmax: cint; ymin: cint; ymax: cint; width: cint; height: cint): ptr imImage {.cdecl.} =
    return niupc.imFileLoadImageRegion(ifile, index, bitmap, error, xmin, xmax, ymin, ymax, width, height)

proc imFileLoadBitmapFrame*(ifile: ptr imFile; index: cint; image: ptr imImage; error: ptr imErrorCodes) {.cdecl.} =
    niupc.imFileLoadBitmapFrame(ifile, index, image, error)

proc imFileSaveImage*(ifile: ptr imFile; image: ptr imImage): cint {.cdecl.} =
    return niupc.imFileSaveImage(ifile, image)

proc imFileImageLoad*(file_name: string; index: cint; error: ptr imErrorCodes): ptr imImage {.cdecl.} =
    return niupc.imFileImageLoad(cstring(file_name), index, error)

proc imFileImageLoadBitmap*(file_name: string; index: cint; error: ptr imErrorCodes): ptr imImage {.cdecl.} =
    return niupc.imFileImageLoadBitmap(cstring(file_name), index, error)

proc imFileImageLoadRegion*(file_name: string; index: cint; bitmap: cint; error: ptr imErrorCodes; xmin: cint; xmax: cint; ymin: cint; ymax: cint; width: cint; height: cint): ptr imImage {.cdecl.} =
    return niupc.imFileImageLoadRegion(cstring(file_name), index, bitmap, error, xmin, xmax, ymin, ymax, width, height)

proc imFileImageSave*(file_name: string; format: string; image: ptr imImage): imErrorCodes {.cdecl.} =
    return niupc.imFileImageSave(cstring(file_name), cstring(format), image)

proc imConvertDataType*(src_image: ptr imImage; dst_image: ptr imImage; cpx2real: cint; gamma: cdouble; absolute: cint; cast_mode: cint): cint {.cdecl.} =
    return niupc.imConvertDataType(src_image, dst_image, cpx2real, gamma, absolute, cast_mode)

proc imConvertColorSpace*(src_image: ptr imImage; dst_image: ptr imImage): cint {.cdecl.} =
    return niupc.imConvertColorSpace(src_image, dst_image)

proc imConvertToBitmap*(src_image: ptr imImage; dst_image: ptr imImage; cpx2real: cint; gamma: cdouble; absolute: cint; cast_mode: cint): cint {.cdecl.} =
    return niupc.imConvertToBitmap(src_image, dst_image, cpx2real, gamma, absolute, cast_mode)

proc imImageGetOpenGLData*(image: ptr imImage; glformat: ptr cint): pointer {.cdecl.} =
    return niupc.imImageGetOpenGLData(image, glformat)

proc imImageCreateFromOpenGLData*(width: cint; height: cint; glformat: cint; gldata: pointer): ptr imImage {.cdecl.} =
    return niupc.imImageCreateFromOpenGLData(width, height, glformat, gldata)

proc imConvertPacking*(src_data: pointer; dst_data: pointer; width: cint; height: cint; src_depth: cint; dst_depth: cint; data_type: imDataType; src_is_packed: cint) {.cdecl.} =
    niupc.imConvertPacking(src_data, dst_data, width, height, src_depth, dst_depth, data_type, src_is_packed)

proc imConvertMapToRGB*(data: openArray[uint8]; count: cint; depth: cint; packed: cint; palette: ptr clong; palette_count: cint) {.cdecl.} =
    niupc.imConvertMapToRGB(cast[ptr uint8](data), count, depth, packed, palette, palette_count)

proc imConvertRGB2Map*(width: cint; height: cint; red: openArray[uint8]; green: openArray[uint8]; blue: openArray[uint8]; map: openArray[uint8]; palette: ptr clong; palette_count: ptr cint): cint {.cdecl.} =
    return niupc.imConvertRGB2Map(width, height, cast[ptr uint8](red), cast[ptr uint8](green), cast[ptr uint8](blue), cast[ptr uint8](map), palette, palette_count)

proc imConvertRGB2MapCounter*(width: cint; height: cint; red: openArray[uint8]; green: openArray[uint8]; blue: openArray[uint8]; map: openArray[uint8]; palette: ptr clong; palette_count: ptr cint; counter: cint): cint {.cdecl.} =
    return niupc.imConvertRGB2MapCounter(width, height, cast[ptr uint8](red), cast[ptr uint8](green), cast[ptr uint8](blue), cast[ptr uint8](map), palette, palette_count, counter)

proc Open*(argc: var cint; argv: ptr cstringArray): cint {.cdecl, discardable.} =
    return niupc.Open(argc, argv)

proc Close*() {.cdecl.} =
    niupc.Close()

proc IsOpened*(): cint {.cdecl.} =
    return niupc.IsOpened()

proc ImageLibOpen*() {.cdecl.} =
    niupc.ImageLibOpen()

proc MainLoop*(): cint {.cdecl, discardable.} =
    return niupc.MainLoop()

proc LoopStep*(): cint {.cdecl.} =
    return niupc.LoopStep()

proc LoopStepWait*(): cint {.cdecl.} =
    return niupc.LoopStepWait()

proc MainLoopLevel*(): cint {.cdecl.} =
    return niupc.MainLoopLevel()

proc Flush*() {.cdecl.} =
    niupc.Flush()

proc ExitLoop*() {.cdecl.} =
    niupc.ExitLoop()

proc PostMessage*(ih: IUPhandle_t; s: string; i: cint; d: cdouble; p: pointer) {.cdecl.} =
    niupc.PostMessage(cast[PIhandle](ih), cstring(s), i, d, p)

proc RecordInput*(filename: string; mode: cint): cint {.cdecl.} =
    return niupc.RecordInput(cstring(filename), mode)

proc PlayInput*(filename: string): cint {.cdecl.} =
    return niupc.PlayInput(cstring(filename))

proc Update*(ih: IUPhandle_t) {.cdecl.} =
    niupc.Update(cast[PIhandle](ih))

proc UpdateChildren*(ih: IUPhandle_t) {.cdecl.} =
    niupc.UpdateChildren(cast[PIhandle](ih))

proc Redraw*(ih: IUPhandle_t; children: cint) {.cdecl.} =
    niupc.Redraw(cast[PIhandle](ih), children)

proc Refresh*(ih: IUPhandle_t) {.cdecl.} =
    niupc.Refresh(cast[PIhandle](ih))

proc RefreshChildren*(ih: IUPhandle_t) {.cdecl.} =
    niupc.RefreshChildren(cast[PIhandle](ih))

proc Execute*(filename: string; parameters: string): cint {.cdecl.} =
    return niupc.Execute(cstring(filename), cstring(parameters))

proc ExecuteWait*(filename: string; parameters: string): cint {.cdecl.} =
    return niupc.ExecuteWait(cstring(filename), cstring(parameters))

proc Help*(url: string): cint {.cdecl.} =
    return niupc.Help(cstring(url))

proc Load*(filename: string): string {.cdecl.} =
    return $niupc.Load(cstring(filename))

proc LoadBuffer*(buffer: string): string {.cdecl.} =
    return $niupc.LoadBuffer(cstring(buffer))

proc Version*(): string {.cdecl.} =
    return $niupc.Version()

proc VersionDate*(): string {.cdecl.} =
    return $niupc.VersionDate()

proc VersionNumber*(): cint {.cdecl.} =
    return niupc.VersionNumber()

proc VersionShow*() {.cdecl.} =
    niupc.VersionShow()

proc SetLanguage*(lng: string) {.cdecl.} =
    niupc.SetLanguage(cstring(lng))

proc GetLanguage*(): string {.cdecl.} =
    return $niupc.GetLanguage()

proc SetLanguageString*(name: string; str: string) {.cdecl.} =
    niupc.SetLanguageString(cstring(name), cstring(str))

proc StoreLanguageString*(name: string; str: string) {.cdecl.} =
    niupc.StoreLanguageString(cstring(name), cstring(str))

proc GetLanguageString*(name: string): string {.cdecl.} =
    return $niupc.GetLanguageString(cstring(name))

proc SetLanguagePack*(ih: IUPhandle_t) {.cdecl.} =
    niupc.SetLanguagePack(cast[PIhandle](ih))

proc Destroy*(ih: IUPhandle_t) {.cdecl.} =
    niupc.Destroy(cast[PIhandle](ih))

proc Detach*(child: IUPhandle_t) {.cdecl.} =
    niupc.Detach(cast[PIhandle](child))

proc Append*(ih: IUPhandle_t; child: IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.Append(cast[PIhandle](ih), cast[PIhandle](child))

proc Insert*(ih: IUPhandle_t; ref_child: IUPhandle_t; child: IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.Insert(cast[PIhandle](ih), cast[PIhandle](ref_child), cast[PIhandle](child))

proc GetChild*(ih: IUPhandle_t; pos: cint): PIhandle {.cdecl.} =
    return niupc.GetChild(cast[PIhandle](ih), pos)

proc GetChildPos*(ih: IUPhandle_t; child: IUPhandle_t): cint {.cdecl.} =
    return niupc.GetChildPos(cast[PIhandle](ih), cast[PIhandle](child))

proc GetChildCount*(ih: IUPhandle_t): cint {.cdecl.} =
    return niupc.GetChildCount(cast[PIhandle](ih))

proc GetNextChild*(ih: IUPhandle_t; child: IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.GetNextChild(cast[PIhandle](ih), cast[PIhandle](child))

proc GetBrother*(ih: IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.GetBrother(cast[PIhandle](ih))

proc GetParent*(ih: IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.GetParent(cast[PIhandle](ih))

proc GetDialog*(ih: IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.GetDialog(cast[PIhandle](ih))

proc GetDialogChild*(ih: IUPhandle_t; name: string): PIhandle {.cdecl.} =
    return niupc.GetDialogChild(cast[PIhandle](ih), cstring(name))

proc Reparent*(ih: IUPhandle_t; new_parent: IUPhandle_t; ref_child: IUPhandle_t): cint {.cdecl.} =
    return niupc.Reparent(cast[PIhandle](ih), cast[PIhandle](new_parent), cast[PIhandle](ref_child))

proc Popup*(ih: IUPhandle_t; x: cint; y: cint): cint {.cdecl.} =
    return niupc.Popup(cast[PIhandle](ih), x, y)

proc Show*(ih: IUPhandle_t): cint {.cdecl, discardable.} =
    return niupc.Show(cast[PIhandle](ih))

proc ShowXY*(ih: IUPhandle_t; x: cint; y: cint): cint {.cdecl, discardable.} =
    return niupc.ShowXY(cast[PIhandle](ih), x, y)

proc Hide*(ih: IUPhandle_t): cint {.cdecl.} =
    return niupc.Hide(cast[PIhandle](ih))

proc Map*(ih: IUPhandle_t): cint {.cdecl, discardable.} =
    return niupc.Map(cast[PIhandle](ih))

proc Unmap*(ih: IUPhandle_t) {.cdecl.} =
    niupc.Unmap(cast[PIhandle](ih))

proc ResetAttribute*(ih: IUPhandle_t; name: string) {.cdecl.} =
    niupc.ResetAttribute(cast[PIhandle](ih), cstring(name))

proc GetAllAttributes*(ih: IUPhandle_t; names: cstringArray; n: cint): cint {.cdecl.} =
    return niupc.GetAllAttributes(cast[PIhandle](ih), names, n)

proc CopyAttributes*(src_ih: IUPhandle_t; dst_ih: IUPhandle_t) {.cdecl.} =
    niupc.CopyAttributes(cast[PIhandle](src_ih), cast[PIhandle](dst_ih))

proc SetAttributes*(ih: IUPhandle_t; str: string): PIhandle {.cdecl, discardable.} =
    return niupc.SetAttributes(cast[PIhandle](ih), cstring(str))

proc GetAttributes*(ih: IUPhandle_t): string {.cdecl.} =
    return $niupc.GetAttributes(cast[PIhandle](ih))

proc SetAttribute*(ih: IUPhandle_t; name: string; value: string) {.cdecl.} =
    niupc.SetAttribute(cast[PIhandle](ih), cstring(name), cstring(value))

proc SetStrAttribute*(ih: IUPhandle_t; name: string; value: string) {.cdecl.} =
    niupc.SetStrAttribute(cast[PIhandle](ih), cstring(name), cstring(value))

proc SetInt*(ih: IUPhandle_t; name: string; value: cint) {.cdecl.} =
    niupc.SetInt(cast[PIhandle](ih), cstring(name), value)

proc SetFloat*(ih: IUPhandle_t; name: string; value: cfloat) {.cdecl.} =
    niupc.SetFloat(cast[PIhandle](ih), cstring(name), value)

proc SetDouble*(ih: IUPhandle_t; name: string; value: cdouble) {.cdecl.} =
    niupc.SetDouble(cast[PIhandle](ih), cstring(name), value)

proc SetRGB*(ih: IUPhandle_t; name: string; r: uint8; g: uint8; b: uint8) {.cdecl.} =
    niupc.SetRGB(cast[PIhandle](ih), cstring(name), r, g, b)

proc SetRGBA*(ih: IUPhandle_t; name: string; r: uint8; g: uint8; b: uint8; a: uint8) {.cdecl.} =
    niupc.SetRGBA(cast[PIhandle](ih), cstring(name), r, g, b, a)

proc GetAttribute*(ih: IUPhandle_t; name: string): string {.cdecl.} =
    return $niupc.GetAttribute(cast[PIhandle](ih), cstring(name))

proc GetInt*(ih: IUPhandle_t; name: string): cint {.cdecl.} =
    return niupc.GetInt(cast[PIhandle](ih), cstring(name))

proc GetInt2*(ih: IUPhandle_t; name: string): cint {.cdecl.} =
    return niupc.GetInt2(cast[PIhandle](ih), cstring(name))

proc GetIntInt*(ih: IUPhandle_t; name: string; i1: var cint; i2: var cint): cint {.cdecl.} =
    return niupc.GetIntInt(cast[PIhandle](ih), cstring(name), i1, i2)

proc GetFloat*(ih: IUPhandle_t; name: string): cfloat {.cdecl.} =
    return niupc.GetFloat(cast[PIhandle](ih), cstring(name))

proc GetDouble*(ih: IUPhandle_t; name: string): cdouble {.cdecl.} =
    return niupc.GetDouble(cast[PIhandle](ih), cstring(name))

proc GetRGB*(ih: IUPhandle_t; name: string; r: openArray[uint8]; g: openArray[uint8]; b: openArray[uint8]) {.cdecl.} =
    niupc.GetRGB(cast[PIhandle](ih), cstring(name), cast[ptr uint8](r), cast[ptr uint8](g), cast[ptr uint8](b))

proc GetRGBA*(ih: IUPhandle_t; name: string; r: openArray[uint8]; g: openArray[uint8]; b: openArray[uint8]; a: openArray[uint8]) {.cdecl.} =
    niupc.GetRGBA(cast[PIhandle](ih), cstring(name), cast[ptr uint8](r), cast[ptr uint8](g), cast[ptr uint8](b), cast[ptr uint8](a))

proc SetAttributeId*(ih: IUPhandle_t; name: string; id: cint; value: string) {.cdecl.} =
    niupc.SetAttributeId(cast[PIhandle](ih), cstring(name), id, cstring(value))

proc SetStrAttributeId*(ih: IUPhandle_t; name: string; id: cint; value: string) {.cdecl.} =
    niupc.SetStrAttributeId(cast[PIhandle](ih), cstring(name), id, cstring(value))

proc SetIntId*(ih: IUPhandle_t; name: string; id: cint; value: cint) {.cdecl.} =
    niupc.SetIntId(cast[PIhandle](ih), cstring(name), id, value)

proc SetFloatId*(ih: IUPhandle_t; name: string; id: cint; value: cfloat) {.cdecl.} =
    niupc.SetFloatId(cast[PIhandle](ih), cstring(name), id, value)

proc SetDoubleId*(ih: IUPhandle_t; name: string; id: cint; value: cdouble) {.cdecl.} =
    niupc.SetDoubleId(cast[PIhandle](ih), cstring(name), id, value)

proc SetRGBId*(ih: IUPhandle_t; name: string; id: cint; r: uint8; g: uint8; b: uint8) {.cdecl.} =
    niupc.SetRGBId(cast[PIhandle](ih), cstring(name), id, r, g, b)

proc GetAttributeId*(ih: IUPhandle_t; name: string; id: cint): string {.cdecl.} =
    return $niupc.GetAttributeId(cast[PIhandle](ih), cstring(name), id)

proc GetIntId*(ih: IUPhandle_t; name: string; id: cint): cint {.cdecl.} =
    return niupc.GetIntId(cast[PIhandle](ih), cstring(name), id)

proc GetFloatId*(ih: IUPhandle_t; name: string; id: cint): cfloat {.cdecl.} =
    return niupc.GetFloatId(cast[PIhandle](ih), cstring(name), id)

proc GetDoubleId*(ih: IUPhandle_t; name: string; id: cint): cdouble {.cdecl.} =
    return niupc.GetDoubleId(cast[PIhandle](ih), cstring(name), id)

proc GetRGBId*(ih: IUPhandle_t; name: string; id: cint; r: openArray[uint8]; g: openArray[uint8]; b: openArray[uint8]) {.cdecl.} =
    niupc.GetRGBId(cast[PIhandle](ih), cstring(name), id, cast[ptr uint8](r), cast[ptr uint8](g), cast[ptr uint8](b))

proc SetAttributeId2*(ih: IUPhandle_t; name: string; lin: cint; col: cint; value: string) {.cdecl.} =
    niupc.SetAttributeId2(cast[PIhandle](ih), cstring(name), lin, col, cstring(value))

proc SetStrAttributeId2*(ih: IUPhandle_t; name: string; lin: cint; col: cint; value: string) {.cdecl.} =
    niupc.SetStrAttributeId2(cast[PIhandle](ih), cstring(name), lin, col, cstring(value))

proc SetIntId2*(ih: IUPhandle_t; name: string; lin: cint; col: cint; value: cint) {.cdecl.} =
    niupc.SetIntId2(cast[PIhandle](ih), cstring(name), lin, col, value)

proc SetFloatId2*(ih: IUPhandle_t; name: string; lin: cint; col: cint; value: cfloat) {.cdecl.} =
    niupc.SetFloatId2(cast[PIhandle](ih), cstring(name), lin, col, value)

proc SetDoubleId2*(ih: IUPhandle_t; name: string; lin: cint; col: cint; value: cdouble) {.cdecl.} =
    niupc.SetDoubleId2(cast[PIhandle](ih), cstring(name), lin, col, value)

proc SetRGBId2*(ih: IUPhandle_t; name: string; lin: cint; col: cint; r: uint8; g: uint8; b: uint8) {.cdecl.} =
    niupc.SetRGBId2(cast[PIhandle](ih), cstring(name), lin, col, r, g, b)

proc GetAttributeId2*(ih: IUPhandle_t; name: string; lin: cint; col: cint): string {.cdecl.} =
    return $niupc.GetAttributeId2(cast[PIhandle](ih), cstring(name), lin, col)

proc GetIntId2*(ih: IUPhandle_t; name: string; lin: cint; col: cint): cint {.cdecl.} =
    return niupc.GetIntId2(cast[PIhandle](ih), cstring(name), lin, col)

proc GetFloatId2*(ih: IUPhandle_t; name: string; lin: cint; col: cint): cfloat {.cdecl.} =
    return niupc.GetFloatId2(cast[PIhandle](ih), cstring(name), lin, col)

proc GetDoubleId2*(ih: IUPhandle_t; name: string; lin: cint; col: cint): cdouble {.cdecl.} =
    return niupc.GetDoubleId2(cast[PIhandle](ih), cstring(name), lin, col)

proc GetRGBId2*(ih: IUPhandle_t; name: string; lin: cint; col: cint; r: openArray[uint8]; g: openArray[uint8]; b: openArray[uint8]) {.cdecl.} =
    niupc.GetRGBId2(cast[PIhandle](ih), cstring(name), lin, col, cast[ptr uint8](r), cast[ptr uint8](g), cast[ptr uint8](b))

proc SetGlobal*(name: string; value: string) {.cdecl.} =
    niupc.SetGlobal(cstring(name), cstring(value))

proc SetStrGlobal*(name: string; value: string) {.cdecl.} =
    niupc.SetStrGlobal(cstring(name), cstring(value))

proc GetGlobal*(name: string): string {.cdecl.} =
    return $niupc.GetGlobal(cstring(name))

proc SetFocus*(ih: IUPhandle_t): PIhandle {.cdecl, discardable.} =
    return niupc.SetFocus(cast[PIhandle](ih))

proc GetFocus*(): PIhandle {.cdecl.} =
    return niupc.GetFocus()

proc PreviousField*(ih: IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.PreviousField(cast[PIhandle](ih))

proc NextField*(ih: IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.NextField(cast[PIhandle](ih))

proc GetCallback*(ih: IUPhandle_t; name: string): Icallback {.cdecl.} =
    return niupc.GetCallback(cast[PIhandle](ih), cstring(name))

proc SetCallback*(ih: IUPhandle_t; name: string; `func`: Icallback): Icallback {.cdecl.} =
    return niupc.SetCallback(cast[PIhandle](ih), cstring(name), cast[Icallback](`func`))

proc GetFunction*(name: string): Icallback {.cdecl.} =
    return niupc.GetFunction(cstring(name))

proc SetFunction*(name: string; `func`: Icallback): Icallback {.cdecl.} =
    return niupc.SetFunction(cstring(name), cast[Icallback](`func`))

proc GetHandle*(name: string): PIhandle {.cdecl.} =
    return niupc.GetHandle(cstring(name))

proc SetHandle*(name: string; ih: IUPhandle_t): PIhandle {.cdecl, discardable.} =
    return niupc.SetHandle(cstring(name), cast[PIhandle](ih))

proc GetAllNames*(names: cstringArray; n: cint): cint {.cdecl.} =
    return niupc.GetAllNames(names, n)

proc GetAllDialogs*(names: cstringArray; n: cint): cint {.cdecl.} =
    return niupc.GetAllDialogs(names, n)

proc GetName*(ih: IUPhandle_t): string {.cdecl.} =
    return $niupc.GetName(cast[PIhandle](ih))

proc SetAttributeHandle*(ih: IUPhandle_t; name: string; ih_named: IUPhandle_t) {.cdecl.} =
    niupc.SetAttributeHandle(cast[PIhandle](ih), cstring(name), cast[PIhandle](ih_named))

proc GetAttributeHandle*(ih: IUPhandle_t; name: string): PIhandle {.cdecl.} =
    return niupc.GetAttributeHandle(cast[PIhandle](ih), cstring(name))

proc SetAttributeHandleId*(ih: IUPhandle_t; name: string; id: cint; ih_named: IUPhandle_t) {.cdecl.} =
    niupc.SetAttributeHandleId(cast[PIhandle](ih), cstring(name), id, cast[PIhandle](ih_named))

proc GetAttributeHandleId*(ih: IUPhandle_t; name: string; id: cint): PIhandle {.cdecl.} =
    return niupc.GetAttributeHandleId(cast[PIhandle](ih), cstring(name), id)

proc SetAttributeHandleId2*(ih: IUPhandle_t; name: string; lin: cint; col: cint; ih_named: IUPhandle_t) {.cdecl.} =
    niupc.SetAttributeHandleId2(cast[PIhandle](ih), cstring(name), lin, col, cast[PIhandle](ih_named))

proc GetAttributeHandleId2*(ih: IUPhandle_t; name: string; lin: cint; col: cint): PIhandle {.cdecl.} =
    return niupc.GetAttributeHandleId2(cast[PIhandle](ih), cstring(name), lin, col)

proc GetClassName*(ih: IUPhandle_t): string {.cdecl.} =
    return $niupc.GetClassName(cast[PIhandle](ih))

proc GetClassType*(ih: IUPhandle_t): string {.cdecl.} =
    return $niupc.GetClassType(cast[PIhandle](ih))

proc GetAllClasses*(names: cstringArray; n: cint): cint {.cdecl.} =
    return niupc.GetAllClasses(names, n)

proc GetClassAttributes*(classname: string; names: cstringArray; n: cint): cint {.cdecl.} =
    return niupc.GetClassAttributes(cstring(classname), names, n)

proc GetClassCallbacks*(classname: string; names: cstringArray; n: cint): cint {.cdecl.} =
    return niupc.GetClassCallbacks(cstring(classname), names, n)

proc SaveClassAttributes*(ih: IUPhandle_t) {.cdecl.} =
    niupc.SaveClassAttributes(cast[PIhandle](ih))

proc CopyClassAttributes*(src_ih: IUPhandle_t; dst_ih: IUPhandle_t) {.cdecl.} =
    niupc.CopyClassAttributes(cast[PIhandle](src_ih), cast[PIhandle](dst_ih))

proc SetClassDefaultAttribute*(classname: string; name: string; value: string) {.cdecl.} =
    niupc.SetClassDefaultAttribute(cstring(classname), cstring(name), cstring(value))

proc ClassMatch*(ih: IUPhandle_t; classname: string): cint {.cdecl.} =
    return niupc.ClassMatch(cast[PIhandle](ih), cstring(classname))

proc Create*(classname: string): PIhandle {.cdecl.} =
    return niupc.Create(cstring(classname))

proc Createv*(classname: string; params: ptr pointer): PIhandle {.cdecl.} =
    return niupc.Createv(cstring(classname), params)

proc Vboxv*(children: ptr IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.Vboxv(cast[ptr PIhandle](children))

proc Zboxv*(children: ptr IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.Zboxv(cast[ptr PIhandle](children))

proc Hboxv*(children: ptr IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.Hboxv(cast[ptr PIhandle](children))

proc Normalizerv*(ih_list: ptr IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.Normalizerv(cast[ptr PIhandle](ih_list))

proc Cboxv*(children: ptr IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.Cboxv(cast[ptr PIhandle](children))

proc GridBoxv*(children: ptr IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.GridBoxv(cast[ptr PIhandle](children))

proc MultiBoxv*(children: ptr IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.MultiBoxv(cast[ptr PIhandle](children))

proc Menuv*(children: ptr IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.Menuv(cast[ptr PIhandle](children))

proc Tabsv*(children: ptr IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.Tabsv(cast[ptr PIhandle](children))

proc FlatTabsv*(children: ptr IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.FlatTabsv(cast[ptr PIhandle](children))

proc StringCompare*(str1: string; str2: string; casesensitive: cint; lexicographic: cint): cint {.cdecl.} =
    return niupc.StringCompare(cstring(str1), cstring(str2), casesensitive, lexicographic)

proc SaveImageAsText*(ih: IUPhandle_t; filename: string; format: string; name: string): cint {.cdecl.} =
    return niupc.SaveImageAsText(cast[PIhandle](ih), cstring(filename), cstring(format), cstring(name))

proc ImageGetHandle*(name: string): PIhandle {.cdecl.} =
    return niupc.ImageGetHandle(cstring(name))

proc TextConvertLinColToPos*(ih: IUPhandle_t; lin: cint; col: cint; pos: var cint) {.cdecl.} =
    niupc.TextConvertLinColToPos(cast[PIhandle](ih), lin, col, pos)

proc TextConvertPosToLinCol*(ih: IUPhandle_t; pos: cint; lin: var cint; col: var cint) {.cdecl.} =
    niupc.TextConvertPosToLinCol(cast[PIhandle](ih), pos, lin, col)

proc ConvertXYToPos*(ih: IUPhandle_t; x: cint; y: cint): cint {.cdecl.} =
    return niupc.ConvertXYToPos(cast[PIhandle](ih), x, y)

proc StoreGlobal*(name: string; value: string) {.cdecl.} =
    niupc.StoreGlobal(cstring(name), cstring(value))

proc StoreAttribute*(ih: IUPhandle_t; name: string; value: string) {.cdecl.} =
    niupc.StoreAttribute(cast[PIhandle](ih), cstring(name), cstring(value))

proc StoreAttributeId*(ih: IUPhandle_t; name: string; id: cint; value: string) {.cdecl.} =
    niupc.StoreAttributeId(cast[PIhandle](ih), cstring(name), id, cstring(value))

proc StoreAttributeId2*(ih: IUPhandle_t; name: string; lin: cint; col: cint; value: string) {.cdecl.} =
    niupc.StoreAttributeId2(cast[PIhandle](ih), cstring(name), lin, col, cstring(value))

proc TreeSetUserId*(ih: IUPhandle_t; id: cint; userid: pointer): cint {.cdecl.} =
    return niupc.TreeSetUserId(cast[PIhandle](ih), id, userid)

proc TreeGetUserId*(ih: IUPhandle_t; id: cint): pointer {.cdecl.} =
    return niupc.TreeGetUserId(cast[PIhandle](ih), id)

proc TreeGetId*(ih: IUPhandle_t; userid: pointer): cint {.cdecl.} =
    return niupc.TreeGetId(cast[PIhandle](ih), userid)

proc TreeSetAttributeHandle*(ih: IUPhandle_t; name: string; id: cint; ih_named: IUPhandle_t) {.cdecl.} =
    niupc.TreeSetAttributeHandle(cast[PIhandle](ih), cstring(name), id, cast[PIhandle](ih_named))

proc GetFile*(arq: string): cint {.cdecl, discardable.} =
    return niupc.GetFile(cstring(arq))

proc Message*(title: string; msg: string) {.cdecl.} =
    niupc.Message(cstring(title), cstring(msg))

proc MessageError*(parent: IUPhandle_t; message: string) {.cdecl.} =
    niupc.MessageError(cast[PIhandle](parent), cstring(message))

proc MessageAlarm*(parent: IUPhandle_t; title: string; message: string; buttons: string): cint {.cdecl.} =
    return niupc.MessageAlarm(cast[PIhandle](parent), cstring(title), cstring(message), cstring(buttons))

proc Alarm*(title: string; msg: string; b1: string; b2: string; b3: string): cint {.cdecl.} =
    return niupc.Alarm(cstring(title), cstring(msg), cstring(b1), cstring(b2), cstring(b3))

proc ListDialog*(`type`: cint; title: string; size: cint; list: cstringArray; op: cint; max_col: cint; max_lin: cint; marks: var cint): cint {.cdecl.} =
    return niupc.ListDialog(`type`, cstring(title), size, list, op, max_col, max_lin, marks)

proc GetText*(title: string; text: string; maxsize: cint): cint {.cdecl.} =
    return niupc.GetText(cstring(title), cstring(text), maxsize)

proc GetColor*(x: cint; y: cint; r: openArray[uint8]; g: openArray[uint8]; b: openArray[uint8]): cint {.cdecl.} =
    return niupc.GetColor(x, y, cast[ptr uint8](r), cast[ptr uint8](g), cast[ptr uint8](b))

proc GetParamv*(title: string; action: Iparamcb; user_data: pointer; format: string; param_count: cint; param_extra: cint; param_data: ptr pointer): cint {.cdecl.} =
    return niupc.GetParamv(cstring(title), action, user_data, cstring(format), param_count, param_extra, param_data)

proc ParamBoxv*(param_array: ptr IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.ParamBoxv(cast[ptr PIhandle](param_array))

proc LayoutDialog*(dialog: IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.LayoutDialog(cast[PIhandle](dialog))

proc ElementPropertiesDialog*(parent: IUPhandle_t; elem: IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.ElementPropertiesDialog(cast[PIhandle](parent), cast[PIhandle](elem))

proc GlobalsDialog*(): PIhandle {.cdecl.} =
    return niupc.GlobalsDialog()

proc ClassInfoDialog*(parent: IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.ClassInfoDialog(cast[PIhandle](parent))

proc Config*(): PIhandle {.cdecl.} =
    return niupc.Config()

proc ConfigLoad*(ih: IUPhandle_t): cint {.cdecl.} =
    return niupc.ConfigLoad(cast[PIhandle](ih))

proc ConfigSave*(ih: IUPhandle_t): cint {.cdecl.} =
    return niupc.ConfigSave(cast[PIhandle](ih))

proc ConfigSetVariableStr*(ih: IUPhandle_t; group: string; key: string; value: string) {.cdecl.} =
    niupc.ConfigSetVariableStr(cast[PIhandle](ih), cstring(group), cstring(key), cstring(value))

proc ConfigSetVariableStrId*(ih: IUPhandle_t; group: string; key: string; id: cint; value: string) {.cdecl.} =
    niupc.ConfigSetVariableStrId(cast[PIhandle](ih), cstring(group), cstring(key), id, cstring(value))

proc ConfigSetVariableInt*(ih: IUPhandle_t; group: string; key: string; value: cint) {.cdecl.} =
    niupc.ConfigSetVariableInt(cast[PIhandle](ih), cstring(group), cstring(key), value)

proc ConfigSetVariableIntId*(ih: IUPhandle_t; group: string; key: string; id: cint; value: cint) {.cdecl.} =
    niupc.ConfigSetVariableIntId(cast[PIhandle](ih), cstring(group), cstring(key), id, value)

proc ConfigSetVariableDouble*(ih: IUPhandle_t; group: string; key: string; value: cdouble) {.cdecl.} =
    niupc.ConfigSetVariableDouble(cast[PIhandle](ih), cstring(group), cstring(key), value)

proc ConfigSetVariableDoubleId*(ih: IUPhandle_t; group: string; key: string; id: cint; value: cdouble) {.cdecl.} =
    niupc.ConfigSetVariableDoubleId(cast[PIhandle](ih), cstring(group), cstring(key), id, value)

proc ConfigGetVariableStr*(ih: IUPhandle_t; group: string; key: string): string {.cdecl.} =
    return $niupc.ConfigGetVariableStr(cast[PIhandle](ih), cstring(group), cstring(key))

proc ConfigGetVariableStrId*(ih: IUPhandle_t; group: string; key: string; id: cint): string {.cdecl.} =
    return $niupc.ConfigGetVariableStrId(cast[PIhandle](ih), cstring(group), cstring(key), id)

proc ConfigGetVariableInt*(ih: IUPhandle_t; group: string; key: string): cint {.cdecl.} =
    return niupc.ConfigGetVariableInt(cast[PIhandle](ih), cstring(group), cstring(key))

proc ConfigGetVariableIntId*(ih: IUPhandle_t; group: string; key: string; id: cint): cint {.cdecl.} =
    return niupc.ConfigGetVariableIntId(cast[PIhandle](ih), cstring(group), cstring(key), id)

proc ConfigGetVariableDouble*(ih: IUPhandle_t; group: string; key: string): cdouble {.cdecl.} =
    return niupc.ConfigGetVariableDouble(cast[PIhandle](ih), cstring(group), cstring(key))

proc ConfigGetVariableDoubleId*(ih: IUPhandle_t; group: string; key: string; id: cint): cdouble {.cdecl.} =
    return niupc.ConfigGetVariableDoubleId(cast[PIhandle](ih), cstring(group), cstring(key), id)

proc ConfigGetVariableStrDef*(ih: IUPhandle_t; group: string; key: string; def: string): string {.cdecl.} =
    return $niupc.ConfigGetVariableStrDef(cast[PIhandle](ih), cstring(group), cstring(key), cstring(def))

proc ConfigGetVariableStrIdDef*(ih: IUPhandle_t; group: string; key: string; id: cint; def: string): string {.cdecl.} =
    return $niupc.ConfigGetVariableStrIdDef(cast[PIhandle](ih), cstring(group), cstring(key), id, cstring(def))

proc ConfigGetVariableIntDef*(ih: IUPhandle_t; group: string; key: string; def: cint): cint {.cdecl.} =
    return niupc.ConfigGetVariableIntDef(cast[PIhandle](ih), cstring(group), cstring(key), def)

proc ConfigGetVariableIntIdDef*(ih: IUPhandle_t; group: string; key: string; id: cint; def: cint): cint {.cdecl.} =
    return niupc.ConfigGetVariableIntIdDef(cast[PIhandle](ih), cstring(group), cstring(key), id, def)

proc ConfigGetVariableDoubleDef*(ih: IUPhandle_t; group: string; key: string; def: cdouble): cdouble {.cdecl.} =
    return niupc.ConfigGetVariableDoubleDef(cast[PIhandle](ih), cstring(group), cstring(key), def)

proc ConfigGetVariableDoubleIdDef*(ih: IUPhandle_t; group: string; key: string; id: cint; def: cdouble): cdouble {.cdecl.} =
    return niupc.ConfigGetVariableDoubleIdDef(cast[PIhandle](ih), cstring(group), cstring(key), id, def)

proc ConfigCopy*(ih1: IUPhandle_t; ih2: IUPhandle_t; exclude_prefix: string) {.cdecl.} =
    niupc.ConfigCopy(cast[PIhandle](ih1), cast[PIhandle](ih2), cstring(exclude_prefix))

proc ConfigSetListVariable*(ih: IUPhandle_t; group: string; key: string; value: string; add: cint) {.cdecl.} =
    niupc.ConfigSetListVariable(cast[PIhandle](ih), cstring(group), cstring(key), cstring(value), add)

proc ConfigRecentInit*(ih: IUPhandle_t; menu: IUPhandle_t; recent_cb: Icallback; max_recent: cint) {.cdecl.} =
    niupc.ConfigRecentInit(cast[PIhandle](ih), cast[PIhandle](menu), cast[Icallback](recent_cb), max_recent)

proc ConfigRecentUpdate*(ih: IUPhandle_t; filename: string) {.cdecl.} =
    niupc.ConfigRecentUpdate(cast[PIhandle](ih), cstring(filename))

proc ConfigDialogShow*(ih: IUPhandle_t; dialog: IUPhandle_t; name: string) {.cdecl.} =
    niupc.ConfigDialogShow(cast[PIhandle](ih), cast[PIhandle](dialog), cstring(name))

proc ConfigDialogClosed*(ih: IUPhandle_t; dialog: IUPhandle_t; name: string) {.cdecl.} =
    niupc.ConfigDialogClosed(cast[PIhandle](ih), cast[PIhandle](dialog), cstring(name))

proc ControlsOpen*(): cint {.cdecl.} =
    return niupc.ControlsOpen()

proc Cells*(): PIhandle {.cdecl.} =
    return niupc.Cells()

proc Matrix*(action: string): PIhandle {.cdecl.} =
    return niupc.Matrix(cstring(action))

proc MatrixList*(): PIhandle {.cdecl.} =
    return niupc.MatrixList()

proc MatrixEx*(): PIhandle {.cdecl.} =
    return niupc.MatrixEx()

proc MatrixSetFormula*(ih: IUPhandle_t; col: cint; formula: string; init: string) {.cdecl.} =
    niupc.MatrixSetFormula(cast[PIhandle](ih), col, cstring(formula), cstring(init))

proc MatrixSetDynamic*(ih: IUPhandle_t; init: string) {.cdecl.} =
    niupc.MatrixSetDynamic(cast[PIhandle](ih), cstring(init))

proc cdContextIupDraw*(): ptr cdContext {.cdecl.} =
    return niupc.cdContextIupDraw()

proc DrawBegin*(ih: IUPhandle_t) {.cdecl.} =
    niupc.DrawBegin(cast[PIhandle](ih))

proc DrawEnd*(ih: IUPhandle_t) {.cdecl.} =
    niupc.DrawEnd(cast[PIhandle](ih))

proc DrawSetClipRect*(ih: IUPhandle_t; x1: cint; y1: cint; x2: cint; y2: cint) {.cdecl.} =
    niupc.DrawSetClipRect(cast[PIhandle](ih), x1, y1, x2, y2)

proc DrawGetClipRect*(ih: IUPhandle_t; x1: var cint; y1: var cint; x2: var cint; y2: var cint) {.cdecl.} =
    niupc.DrawGetClipRect(cast[PIhandle](ih), x1, y1, x2, y2)

proc DrawResetClip*(ih: IUPhandle_t) {.cdecl.} =
    niupc.DrawResetClip(cast[PIhandle](ih))

proc DrawParentBackground*(ih: IUPhandle_t) {.cdecl.} =
    niupc.DrawParentBackground(cast[PIhandle](ih))

proc DrawLine*(ih: IUPhandle_t; x1: cint; y1: cint; x2: cint; y2: cint) {.cdecl.} =
    niupc.DrawLine(cast[PIhandle](ih), x1, y1, x2, y2)

proc DrawRectangle*(ih: IUPhandle_t; x1: cint; y1: cint; x2: cint; y2: cint) {.cdecl.} =
    niupc.DrawRectangle(cast[PIhandle](ih), x1, y1, x2, y2)

proc DrawArc*(ih: IUPhandle_t; x1: cint; y1: cint; x2: cint; y2: cint; a1: cdouble; a2: cdouble) {.cdecl.} =
    niupc.DrawArc(cast[PIhandle](ih), x1, y1, x2, y2, a1, a2)

proc DrawPolygon*(ih: IUPhandle_t; points: var cint; count: cint) {.cdecl.} =
    niupc.DrawPolygon(cast[PIhandle](ih), points, count)

proc DrawText*(ih: IUPhandle_t; text: string; len: cint; x: cint; y: cint; w: cint; h: cint) {.cdecl.} =
    niupc.DrawText(cast[PIhandle](ih), cstring(text), len, x, y, w, h)

proc DrawImage*(ih: IUPhandle_t; name: string; x: cint; y: cint; w: cint; h: cint) {.cdecl.} =
    niupc.DrawImage(cast[PIhandle](ih), cstring(name), x, y, w, h)

proc DrawSelectRect*(ih: IUPhandle_t; x1: cint; y1: cint; x2: cint; y2: cint) {.cdecl.} =
    niupc.DrawSelectRect(cast[PIhandle](ih), x1, y1, x2, y2)

proc DrawFocusRect*(ih: IUPhandle_t; x1: cint; y1: cint; x2: cint; y2: cint) {.cdecl.} =
    niupc.DrawFocusRect(cast[PIhandle](ih), x1, y1, x2, y2)

proc DrawGetSize*(ih: IUPhandle_t; w: var cint; h: var cint) {.cdecl.} =
    niupc.DrawGetSize(cast[PIhandle](ih), w, h)

proc DrawGetTextSize*(ih: IUPhandle_t; text: string; len: cint; w: var cint; h: var cint) {.cdecl.} =
    niupc.DrawGetTextSize(cast[PIhandle](ih), cstring(text), len, w, h)

proc DrawGetImageInfo*(name: string; w: var cint; h: var cint; bpp: var cint) {.cdecl.} =
    niupc.DrawGetImageInfo(cstring(name), w, h, bpp)

proc NewFileDlgOpen*(): cint {.cdecl.} =
    return niupc.NewFileDlgOpen()

proc GLControlsOpen*(): cint {.cdecl.} =
    return niupc.GLControlsOpen()

proc GLCanvasBoxv*(children: ptr IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.GLCanvasBoxv(cast[ptr PIhandle](children))

proc GLSubCanvas*(): PIhandle {.cdecl.} =
    return niupc.GLSubCanvas()

proc GLLabel*(title: string): PIhandle {.cdecl.} =
    return niupc.GLLabel(cstring(title))

proc GLSeparator*(): PIhandle {.cdecl.} =
    return niupc.GLSeparator()

proc GLButton*(title: string): PIhandle {.cdecl.} =
    return niupc.GLButton(cstring(title))

proc GLToggle*(title: string): PIhandle {.cdecl.} =
    return niupc.GLToggle(cstring(title))

proc GLLink*(url: string; title: string): PIhandle {.cdecl.} =
    return niupc.GLLink(cstring(url), cstring(title))

proc GLProgressBar*(): PIhandle {.cdecl.} =
    return niupc.GLProgressBar()

proc GLVal*(): PIhandle {.cdecl.} =
    return niupc.GLVal()

proc GLFrame*(child: IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.GLFrame(cast[PIhandle](child))

proc GLExpander*(child: IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.GLExpander(cast[PIhandle](child))

proc GLScrollBox*(child: IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.GLScrollBox(cast[PIhandle](child))

proc GLSizeBox*(child: IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.GLSizeBox(cast[PIhandle](child))

proc GLText*(): PIhandle {.cdecl.} =
    return niupc.GLText()

proc GLDrawImage*(ih: IUPhandle_t; name: string; x: cint; y: cint; active: cint) {.cdecl.} =
    niupc.GLDrawImage(cast[PIhandle](ih), cstring(name), x, y, active)

proc GLDrawText*(ih: IUPhandle_t; str: string; len: cint; x: cint; y: cint) {.cdecl.} =
    niupc.GLDrawText(cast[PIhandle](ih), cstring(str), len, x, y)

proc GLDrawGetTextSize*(ih: IUPhandle_t; str: string; w: var cint; h: var cint) {.cdecl.} =
    niupc.GLDrawGetTextSize(cast[PIhandle](ih), cstring(str), w, h)

proc GLDrawGetImageInfo*(name: string; w: var cint; h: var cint; bpp: var cint) {.cdecl.} =
    niupc.GLDrawGetImageInfo(cstring(name), w, h, bpp)

proc GLCanvasOpen*() {.cdecl.} =
    niupc.GLCanvasOpen()

proc GLCanvas*(action: string): PIhandle {.cdecl.} =
    return niupc.GLCanvas(cstring(action))

proc GLBackgroundBox*(child: IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.GLBackgroundBox(cast[PIhandle](child))

proc GLMakeCurrent*(ih: IUPhandle_t) {.cdecl.} =
    niupc.GLMakeCurrent(cast[PIhandle](ih))

proc GLIsCurrent*(ih: IUPhandle_t): cint {.cdecl.} =
    return niupc.GLIsCurrent(cast[PIhandle](ih))

proc GLSwapBuffers*(ih: IUPhandle_t) {.cdecl.} =
    niupc.GLSwapBuffers(cast[PIhandle](ih))

proc GLPalette*(ih: IUPhandle_t; index: cint; r: cfloat; g: cfloat; b: cfloat) {.cdecl.} =
    niupc.GLPalette(cast[PIhandle](ih), index, r, g, b)

proc GLUseFont*(ih: IUPhandle_t; first: cint; count: cint; list_base: cint) {.cdecl.} =
    niupc.GLUseFont(cast[PIhandle](ih), first, count, list_base)

proc GLWait*(gl: cint) {.cdecl.} =
    niupc.GLWait(gl)

proc ImOpen*() {.cdecl.} =
    niupc.ImOpen()

proc LoadImage*(filename: string): PIhandle {.cdecl.} =
    return niupc.LoadImage(cstring(filename))

proc SaveImage*(ih: IUPhandle_t; filename: string; format: string): cint {.cdecl.} =
    return niupc.SaveImage(cast[PIhandle](ih), cstring(filename), cstring(format))

proc LoadAnimation*(filename: string): PIhandle {.cdecl.} =
    return niupc.LoadAnimation(cstring(filename))

proc LoadAnimationFrames*(filename_list: cstringArray; file_count: cint): PIhandle {.cdecl.} =
    return niupc.LoadAnimationFrames(filename_list, file_count)

proc GetNativeHandleImage*(handle: pointer): ptr imImage {.cdecl.} =
    return niupc.GetNativeHandleImage(handle)

proc GetImageNativeHandle*(image: ptr imImage): pointer {.cdecl.} =
    return niupc.GetImageNativeHandle(image)

proc ImageFromImImage*(image: ptr imImage): PIhandle {.cdecl.} =
    return niupc.ImageFromImImage(image)

proc ImageToImImage*(iup_image: IUPhandle_t): ptr imImage {.cdecl.} =
    return niupc.ImageToImImage(cast[PIhandle](iup_image))

proc MglPlotOpen*() {.cdecl.} =
    niupc.MglPlotOpen()

proc MglPlot*(): PIhandle {.cdecl.} =
    return niupc.MglPlot()

proc MglPlotBegin*(ih: IUPhandle_t; dim: cint) {.cdecl.} =
    niupc.MglPlotBegin(cast[PIhandle](ih), dim)

proc MglPlotAdd1D*(ih: IUPhandle_t; name: string; y: cdouble) {.cdecl.} =
    niupc.MglPlotAdd1D(cast[PIhandle](ih), cstring(name), y)

proc MglPlotAdd2D*(ih: IUPhandle_t; x: cdouble; y: cdouble) {.cdecl.} =
    niupc.MglPlotAdd2D(cast[PIhandle](ih), x, y)

proc MglPlotAdd3D*(ih: IUPhandle_t; x: cdouble; y: cdouble; z: cdouble) {.cdecl.} =
    niupc.MglPlotAdd3D(cast[PIhandle](ih), x, y, z)

proc MglPlotEnd*(ih: IUPhandle_t): cint {.cdecl.} =
    return niupc.MglPlotEnd(cast[PIhandle](ih))

proc MglPlotNewDataSet*(ih: IUPhandle_t; dim: cint): cint {.cdecl.} =
    return niupc.MglPlotNewDataSet(cast[PIhandle](ih), dim)

proc MglPlotInsert1D*(ih: IUPhandle_t; ds_index: cint; sample_index: cint; names: cstringArray; y: ptr cdouble; count: cint) {.cdecl.} =
    niupc.MglPlotInsert1D(cast[PIhandle](ih), ds_index, sample_index, names, y, count)

proc MglPlotInsert2D*(ih: IUPhandle_t; ds_index: cint; sample_index: cint; x: ptr cdouble; y: ptr cdouble; count: cint) {.cdecl.} =
    niupc.MglPlotInsert2D(cast[PIhandle](ih), ds_index, sample_index, x, y, count)

proc MglPlotInsert3D*(ih: IUPhandle_t; ds_index: cint; sample_index: cint; x: ptr cdouble; y: ptr cdouble; z: ptr cdouble; count: cint) {.cdecl.} =
    niupc.MglPlotInsert3D(cast[PIhandle](ih), ds_index, sample_index, x, y, z, count)

proc MglPlotSet1D*(ih: IUPhandle_t; ds_index: cint; names: cstringArray; y: ptr cdouble; count: cint) {.cdecl.} =
    niupc.MglPlotSet1D(cast[PIhandle](ih), ds_index, names, y, count)

proc MglPlotSet2D*(ih: IUPhandle_t; ds_index: cint; x: ptr cdouble; y: ptr cdouble; count: cint) {.cdecl.} =
    niupc.MglPlotSet2D(cast[PIhandle](ih), ds_index, x, y, count)

proc MglPlotSet3D*(ih: IUPhandle_t; ds_index: cint; x: ptr cdouble; y: ptr cdouble; z: ptr cdouble; count: cint) {.cdecl.} =
    niupc.MglPlotSet3D(cast[PIhandle](ih), ds_index, x, y, z, count)

proc MglPlotSetFormula*(ih: IUPhandle_t; ds_index: cint; formulaX: string; formulaY: string; formulaZ: string; count: cint) {.cdecl.} =
    niupc.MglPlotSetFormula(cast[PIhandle](ih), ds_index, cstring(formulaX), cstring(formulaY), cstring(formulaZ), count)

proc MglPlotSetData*(ih: IUPhandle_t; ds_index: cint; data: ptr cdouble; count_x: cint; count_y: cint; count_z: cint) {.cdecl.} =
    niupc.MglPlotSetData(cast[PIhandle](ih), ds_index, data, count_x, count_y, count_z)

proc MglPlotLoadData*(ih: IUPhandle_t; ds_index: cint; filename: string; count_x: cint; count_y: cint; count_z: cint) {.cdecl.} =
    niupc.MglPlotLoadData(cast[PIhandle](ih), ds_index, cstring(filename), count_x, count_y, count_z)

proc MglPlotSetFromFormula*(ih: IUPhandle_t; ds_index: cint; formula: string; count_x: cint; count_y: cint; count_z: cint) {.cdecl.} =
    niupc.MglPlotSetFromFormula(cast[PIhandle](ih), ds_index, cstring(formula), count_x, count_y, count_z)

proc MglPlotTransform*(ih: IUPhandle_t; x: cdouble; y: cdouble; z: cdouble; ix: var cint; iy: var cint) {.cdecl.} =
    niupc.MglPlotTransform(cast[PIhandle](ih), x, y, z, ix, iy)

proc MglPlotTransformTo*(ih: IUPhandle_t; ix: cint; iy: cint; x: ptr cdouble; y: ptr cdouble; z: ptr cdouble) {.cdecl.} =
    niupc.MglPlotTransformTo(cast[PIhandle](ih), ix, iy, x, y, z)

proc MglPlotDrawMark*(ih: IUPhandle_t; x: cdouble; y: cdouble; z: cdouble) {.cdecl.} =
    niupc.MglPlotDrawMark(cast[PIhandle](ih), x, y, z)

proc MglPlotDrawLine*(ih: IUPhandle_t; x1: cdouble; y1: cdouble; z1: cdouble; x2: cdouble; y2: cdouble; z2: cdouble) {.cdecl.} =
    niupc.MglPlotDrawLine(cast[PIhandle](ih), x1, y1, z1, x2, y2, z2)

proc MglPlotDrawText*(ih: IUPhandle_t; text: string; x: cdouble; y: cdouble; z: cdouble) {.cdecl.} =
    niupc.MglPlotDrawText(cast[PIhandle](ih), cstring(text), x, y, z)

proc MglPlotPaintTo*(ih: IUPhandle_t; format: string; w: cint; h: cint; dpi: cdouble; data: pointer) {.cdecl.} =
    niupc.MglPlotPaintTo(cast[PIhandle](ih), cstring(format), w, h, dpi, data)

proc MglLabel*(title: string): PIhandle {.cdecl.} =
    return niupc.MglLabel(cstring(title))

proc PlotOpen*() {.cdecl.} =
    niupc.PlotOpen()

proc Plot*(): PIhandle {.cdecl.} =
    return niupc.Plot()

proc PlotBegin*(ih: IUPhandle_t; strXdata: cint) {.cdecl.} =
    niupc.PlotBegin(cast[PIhandle](ih), strXdata)

proc PlotAdd*(ih: IUPhandle_t; x: cdouble; y: cdouble) {.cdecl.} =
    niupc.PlotAdd(cast[PIhandle](ih), x, y)

proc PlotAddStr*(ih: IUPhandle_t; x: string; y: cdouble) {.cdecl.} =
    niupc.PlotAddStr(cast[PIhandle](ih), cstring(x), y)

proc PlotAddSegment*(ih: IUPhandle_t; x: cdouble; y: cdouble) {.cdecl.} =
    niupc.PlotAddSegment(cast[PIhandle](ih), x, y)

proc PlotEnd*(ih: IUPhandle_t): cint {.cdecl.} =
    return niupc.PlotEnd(cast[PIhandle](ih))

proc PlotLoadData*(ih: IUPhandle_t; filename: string; strXdata: cint): cint {.cdecl.} =
    return niupc.PlotLoadData(cast[PIhandle](ih), cstring(filename), strXdata)

proc PlotSetFormula*(ih: IUPhandle_t; sample_count: cint; formula: string; init: string): cint {.cdecl.} =
    return niupc.PlotSetFormula(cast[PIhandle](ih), sample_count, cstring(formula), cstring(init))

proc PlotInsert*(ih: IUPhandle_t; ds_index: cint; sample_index: cint; x: cdouble; y: cdouble) {.cdecl.} =
    niupc.PlotInsert(cast[PIhandle](ih), ds_index, sample_index, x, y)

proc PlotInsertStr*(ih: IUPhandle_t; ds_index: cint; sample_index: cint; x: string; y: cdouble) {.cdecl.} =
    niupc.PlotInsertStr(cast[PIhandle](ih), ds_index, sample_index, cstring(x), y)

proc PlotInsertSegment*(ih: IUPhandle_t; ds_index: cint; sample_index: cint; x: cdouble; y: cdouble) {.cdecl.} =
    niupc.PlotInsertSegment(cast[PIhandle](ih), ds_index, sample_index, x, y)

proc PlotInsertStrSamples*(ih: IUPhandle_t; ds_index: cint; sample_index: cint; x: cstringArray; y: ptr cdouble; count: cint) {.cdecl.} =
    niupc.PlotInsertStrSamples(cast[PIhandle](ih), ds_index, sample_index, x, y, count)

proc PlotInsertSamples*(ih: IUPhandle_t; ds_index: cint; sample_index: cint; x: ptr cdouble; y: ptr cdouble; count: cint) {.cdecl.} =
    niupc.PlotInsertSamples(cast[PIhandle](ih), ds_index, sample_index, x, y, count)

proc PlotAddSamples*(ih: IUPhandle_t; ds_index: cint; x: ptr cdouble; y: ptr cdouble; count: cint) {.cdecl.} =
    niupc.PlotAddSamples(cast[PIhandle](ih), ds_index, x, y, count)

proc PlotAddStrSamples*(ih: IUPhandle_t; ds_index: cint; x: cstringArray; y: ptr cdouble; count: cint) {.cdecl.} =
    niupc.PlotAddStrSamples(cast[PIhandle](ih), ds_index, x, y, count)

proc PlotGetSample*(ih: IUPhandle_t; ds_index: cint; sample_index: cint; x: ptr cdouble; y: ptr cdouble) {.cdecl.} =
    niupc.PlotGetSample(cast[PIhandle](ih), ds_index, sample_index, x, y)

proc PlotGetSampleStr*(ih: IUPhandle_t; ds_index: cint; sample_index: cint; x: cstringArray; y: ptr cdouble) {.cdecl.} =
    niupc.PlotGetSampleStr(cast[PIhandle](ih), ds_index, sample_index, x, y)

proc PlotGetSampleSelection*(ih: IUPhandle_t; ds_index: cint; sample_index: cint): cint {.cdecl.} =
    return niupc.PlotGetSampleSelection(cast[PIhandle](ih), ds_index, sample_index)

proc PlotGetSampleExtra*(ih: IUPhandle_t; ds_index: cint; sample_index: cint): cdouble {.cdecl.} =
    return niupc.PlotGetSampleExtra(cast[PIhandle](ih), ds_index, sample_index)

proc PlotSetSample*(ih: IUPhandle_t; ds_index: cint; sample_index: cint; x: cdouble; y: cdouble) {.cdecl.} =
    niupc.PlotSetSample(cast[PIhandle](ih), ds_index, sample_index, x, y)

proc PlotSetSampleStr*(ih: IUPhandle_t; ds_index: cint; sample_index: cint; x: string; y: cdouble) {.cdecl.} =
    niupc.PlotSetSampleStr(cast[PIhandle](ih), ds_index, sample_index, cstring(x), y)

proc PlotSetSampleSelection*(ih: IUPhandle_t; ds_index: cint; sample_index: cint; selected: cint) {.cdecl.} =
    niupc.PlotSetSampleSelection(cast[PIhandle](ih), ds_index, sample_index, selected)

proc PlotSetSampleExtra*(ih: IUPhandle_t; ds_index: cint; sample_index: cint; extra: cdouble) {.cdecl.} =
    niupc.PlotSetSampleExtra(cast[PIhandle](ih), ds_index, sample_index, extra)

proc PlotTransform*(ih: IUPhandle_t; x: cdouble; y: cdouble; cnv_x: ptr cdouble; cnv_y: ptr cdouble) {.cdecl.} =
    niupc.PlotTransform(cast[PIhandle](ih), x, y, cnv_x, cnv_y)

proc PlotTransformTo*(ih: IUPhandle_t; cnv_x: cdouble; cnv_y: cdouble; x: ptr cdouble; y: ptr cdouble) {.cdecl.} =
    niupc.PlotTransformTo(cast[PIhandle](ih), cnv_x, cnv_y, x, y)

proc PlotFindSample*(ih: IUPhandle_t; cnv_x: cdouble; cnv_y: cdouble; ds_index: var cint; sample_index: var cint): cint {.cdecl.} =
    return niupc.PlotFindSample(cast[PIhandle](ih), cnv_x, cnv_y, ds_index, sample_index)

proc PlotFindSegment*(ih: IUPhandle_t; cnv_x: cdouble; cnv_y: cdouble; ds_index: var cint; sample_index1: var cint; sample_index2: var cint): cint {.cdecl.} =
    return niupc.PlotFindSegment(cast[PIhandle](ih), cnv_x, cnv_y, ds_index, sample_index1, sample_index2)

proc PlotPaintTo*(ih: IUPhandle_t; cnv: ptr cdCanvas) {.cdecl.} =
    niupc.PlotPaintTo(cast[PIhandle](ih), cnv)

proc ScintillaOpen*() {.cdecl.} =
    niupc.ScintillaOpen()

proc Scintilla*(): PIhandle {.cdecl.} =
    return niupc.Scintilla()

proc ScintillaDlg*(): PIhandle {.cdecl.} =
    return niupc.ScintillaDlg()

proc ScintillaSendMessage*(ih: IUPhandle_t; iMessage: cuint; wParam: clong; lParam: clong): clong {.cdecl.} =
    return niupc.ScintillaSendMessage(cast[PIhandle](ih), iMessage, wParam, lParam)

proc TuioOpen*(): cint {.cdecl.} =
    return niupc.TuioOpen()

proc TuioClient*(port: cint): PIhandle {.cdecl.} =
    return niupc.TuioClient(port)

proc WebBrowserOpen*(): cint {.cdecl.} =
    return niupc.WebBrowserOpen()

proc WebBrowser*(): PIhandle {.cdecl.} =
    return niupc.WebBrowser()

proc Open*(utf8Mode: bool = false, imageLib: bool = false) {.cdecl.} =
  var argc:cint=0
  var argv:cstringArray=nil
  Open(argc, addr argv)

  if utf8Mode:
    SetGlobal("UTF8MODE", "Yes")

  if imageLib:
    ImageLibOpen()

# Attributes
proc `[]`*(ih: IUPhandle_t, attribute: string): string {.cdecl.} =
  return $GetAttribute(cast[PIhandle](ih), attribute)

proc `[]=`*(ih: IUPhandle_t, attribute, value: string or typeof(nil)) {.cdecl.} =
  SetAttribute(cast[PIhandle](ih), cstring(attribute), cstring(value))

# List utility functions
proc image*(ih: List_t , n: int, img: Image_t | ImageRGB_t | ImageRGBA_t) {.cdecl.} =
   SetAttributeHandle(cast[PIhandle](ih), cstring(&"IMAGE{n}"), cast[PIhandle](img))

proc insertitem*(ih: List_t , n: int, value: string) {.cdecl.} =
   SetAttribute(cast[PIhandle](ih), cstring(&"INSERTITEM{n}"), cstring(value))

# functions using PIhandle, usefull in callbacks to avoid casting
proc PostMessage*(ih: PIhandle; s: string; i: cint; d: cdouble; p: pointer) {.cdecl.} =
    niupc.PostMessage(ih, cstring(s), i, d, p)

proc Update*(ih: PIhandle) {.cdecl.} =
    niupc.Update(ih)

proc UpdateChildren*(ih: PIhandle) {.cdecl.} =
    niupc.UpdateChildren(ih)

proc Redraw*(ih: PIhandle; children: cint) {.cdecl.} =
    niupc.Redraw(ih, children)

proc Refresh*(ih: PIhandle) {.cdecl.} =
    niupc.Refresh(ih)

proc RefreshChildren*(ih: PIhandle) {.cdecl.} =
    niupc.RefreshChildren(ih)

proc SetLanguagePack*(ih: PIhandle) {.cdecl.} =
    niupc.SetLanguagePack(ih)

proc Destroy*(ih: PIhandle) {.cdecl.} =
    niupc.Destroy(ih)

proc Detach*(child: PIhandle) {.cdecl.} =
    niupc.Detach(cast[PIhandle](child))

proc Append*(ih: PIhandle; child: IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.Append(ih, cast[PIhandle](child))

proc Insert*(ih: PIhandle; ref_child: IUPhandle_t; child: IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.Insert(ih, cast[PIhandle](ref_child), cast[PIhandle](child))

proc GetChild*(ih: PIhandle; pos: cint): PIhandle {.cdecl.} =
    return niupc.GetChild(ih, pos)

proc GetChildPos*(ih: PIhandle; child: IUPhandle_t): cint {.cdecl.} =
    return niupc.GetChildPos(ih, cast[PIhandle](child))

proc GetChildCount*(ih: PIhandle): cint {.cdecl.} =
    return niupc.GetChildCount(ih)

proc GetNextChild*(ih: PIhandle; child: IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.GetNextChild(ih, cast[PIhandle](child))

proc GetBrother*(ih: PIhandle): PIhandle {.cdecl.} =
    return niupc.GetBrother(ih)

proc GetParent*(ih: PIhandle): PIhandle {.cdecl.} =
    return niupc.GetParent(ih)

proc GetDialog*(ih: PIhandle): PIhandle {.cdecl.} =
    return niupc.GetDialog(ih)

proc GetDialogChild*(ih: PIhandle; name: string): PIhandle {.cdecl.} =
    return niupc.GetDialogChild(ih, cstring(name))

proc Reparent*(ih: PIhandle; new_parent: IUPhandle_t; ref_child: IUPhandle_t): cint {.cdecl.} =
    return niupc.Reparent(ih, cast[PIhandle](new_parent), cast[PIhandle](ref_child))

proc Popup*(ih: PIhandle; x: cint; y: cint): cint {.cdecl.} =
    return niupc.Popup(ih, x, y)

proc Show*(ih: PIhandle): cint {.cdecl, discardable.} =
    return niupc.Show(ih)

proc ShowXY*(ih: PIhandle; x: cint; y: cint): cint {.cdecl, discardable.} =
    return niupc.ShowXY(ih, x, y)

proc Hide*(ih: PIhandle): cint {.cdecl.} =
    return niupc.Hide(ih)

proc Map*(ih: PIhandle): cint {.cdecl, discardable.} =
    return niupc.Map(ih)

proc Unmap*(ih: PIhandle) {.cdecl.} =
    niupc.Unmap(ih)

proc ResetAttribute*(ih: PIhandle; name: string) {.cdecl.} =
    niupc.ResetAttribute(ih, cstring(name))

proc GetAllAttributes*(ih: PIhandle; names: cstringArray; n: cint): cint {.cdecl.} =
    return niupc.GetAllAttributes(ih, names, n)

proc CopyAttributes*(src_ih: PIhandle; dst_ih: IUPhandle_t) {.cdecl.} =
    niupc.CopyAttributes(cast[PIhandle](src_ih), cast[PIhandle](dst_ih))

proc SetAttributes*(ih: PIhandle; str: string): PIhandle {.cdecl, discardable.} =
    return niupc.SetAttributes(ih, cstring(str))

proc GetAttributes*(ih: PIhandle): string {.cdecl.} =
    return $niupc.GetAttributes(ih)

proc SetAttribute*(ih: PIhandle; name: string; value: string) {.cdecl.} =
    niupc.SetAttribute(ih, cstring(name), cstring(value))

proc SetStrAttribute*(ih: PIhandle; name: string; value: string) {.cdecl.} =
    niupc.SetStrAttribute(ih, cstring(name), cstring(value))

proc SetInt*(ih: PIhandle; name: string; value: cint) {.cdecl.} =
    niupc.SetInt(ih, cstring(name), value)

proc SetFloat*(ih: PIhandle; name: string; value: cfloat) {.cdecl.} =
    niupc.SetFloat(ih, cstring(name), value)

proc SetDouble*(ih: PIhandle; name: string; value: cdouble) {.cdecl.} =
    niupc.SetDouble(ih, cstring(name), value)

proc SetRGB*(ih: PIhandle; name: string; r: uint8; g: uint8; b: uint8) {.cdecl.} =
    niupc.SetRGB(ih, cstring(name), r, g, b)

proc SetRGBA*(ih: PIhandle; name: string; r: uint8; g: uint8; b: uint8; a: uint8) {.cdecl.} =
    niupc.SetRGBA(ih, cstring(name), r, g, b, a)

proc GetAttribute*(ih: PIhandle; name: string): string {.cdecl.} =
    return $niupc.GetAttribute(ih, cstring(name))

proc GetInt*(ih: PIhandle; name: string): cint {.cdecl.} =
    return niupc.GetInt(ih, cstring(name))

proc GetInt2*(ih: PIhandle; name: string): cint {.cdecl.} =
    return niupc.GetInt2(ih, cstring(name))

proc GetIntInt*(ih: PIhandle; name: string; i1: var cint; i2: var cint): cint {.cdecl.} =
    return niupc.GetIntInt(ih, cstring(name), i1, i2)

proc GetFloat*(ih: PIhandle; name: string): cfloat {.cdecl.} =
    return niupc.GetFloat(ih, cstring(name))

proc GetDouble*(ih: PIhandle; name: string): cdouble {.cdecl.} =
    return niupc.GetDouble(ih, cstring(name))

proc GetFile*(arq: cstring): cint {.cdecl, discardable.} =
    return niupc.GetFile(arq)

proc GetRGB*(ih: PIhandle; name: string; r: openArray[uint8]; g: openArray[uint8]; b: openArray[uint8]) {.cdecl.} =
    niupc.GetRGB(ih, cstring(name), cast[ptr uint8](r), cast[ptr uint8](g), cast[ptr uint8](b))

proc GetRGBA*(ih: PIhandle; name: string; r: openArray[uint8]; g: openArray[uint8]; b: openArray[uint8]; a: openArray[uint8]) {.cdecl.} =
    niupc.GetRGBA(ih, cstring(name), cast[ptr uint8](r), cast[ptr uint8](g), cast[ptr uint8](b), cast[ptr uint8](a))

proc SetAttributeId*(ih: PIhandle; name: string; id: cint; value: string) {.cdecl.} =
    niupc.SetAttributeId(ih, cstring(name), id, cstring(value))

proc SetStrAttributeId*(ih: PIhandle; name: string; id: cint; value: string) {.cdecl.} =
    niupc.SetStrAttributeId(ih, cstring(name), id, cstring(value))

proc SetIntId*(ih: PIhandle; name: string; id: cint; value: cint) {.cdecl.} =
    niupc.SetIntId(ih, cstring(name), id, value)

proc SetFloatId*(ih: PIhandle; name: string; id: cint; value: cfloat) {.cdecl.} =
    niupc.SetFloatId(ih, cstring(name), id, value)

proc SetDoubleId*(ih: PIhandle; name: string; id: cint; value: cdouble) {.cdecl.} =
    niupc.SetDoubleId(ih, cstring(name), id, value)

proc SetRGBId*(ih: PIhandle; name: string; id: cint; r: uint8; g: uint8; b: uint8) {.cdecl.} =
    niupc.SetRGBId(ih, cstring(name), id, r, g, b)

proc GetAttributeId*(ih: PIhandle; name: string; id: cint): string {.cdecl.} =
    return $niupc.GetAttributeId(ih, cstring(name), id)

proc GetIntId*(ih: PIhandle; name: string; id: cint): cint {.cdecl.} =
    return niupc.GetIntId(ih, cstring(name), id)

proc GetFloatId*(ih: PIhandle; name: string; id: cint): cfloat {.cdecl.} =
    return niupc.GetFloatId(ih, cstring(name), id)

proc GetDoubleId*(ih: PIhandle; name: string; id: cint): cdouble {.cdecl.} =
    return niupc.GetDoubleId(ih, cstring(name), id)

proc GetRGBId*(ih: PIhandle; name: string; id: cint; r: openArray[uint8]; g: openArray[uint8]; b: openArray[uint8]) {.cdecl.} =
    niupc.GetRGBId(ih, cstring(name), id, cast[ptr uint8](r), cast[ptr uint8](g), cast[ptr uint8](b))

proc SetAttributeId2*(ih: PIhandle; name: string; lin: cint; col: cint; value: string) {.cdecl.} =
    niupc.SetAttributeId2(ih, cstring(name), lin, col, cstring(value))

proc SetStrAttributeId2*(ih: PIhandle; name: string; lin: cint; col: cint; value: string) {.cdecl.} =
    niupc.SetStrAttributeId2(ih, cstring(name), lin, col, cstring(value))

proc SetIntId2*(ih: PIhandle; name: string; lin: cint; col: cint; value: cint) {.cdecl.} =
    niupc.SetIntId2(ih, cstring(name), lin, col, value)

proc SetFloatId2*(ih: PIhandle; name: string; lin: cint; col: cint; value: cfloat) {.cdecl.} =
    niupc.SetFloatId2(ih, cstring(name), lin, col, value)

proc SetDoubleId2*(ih: PIhandle; name: string; lin: cint; col: cint; value: cdouble) {.cdecl.} =
    niupc.SetDoubleId2(ih, cstring(name), lin, col, value)

proc SetRGBId2*(ih: PIhandle; name: string; lin: cint; col: cint; r: uint8; g: uint8; b: uint8) {.cdecl.} =
    niupc.SetRGBId2(ih, cstring(name), lin, col, r, g, b)

proc GetAttributeId2*(ih: PIhandle; name: string; lin: cint; col: cint): string {.cdecl.} =
    return $niupc.GetAttributeId2(ih, cstring(name), lin, col)

proc GetIntId2*(ih: PIhandle; name: string; lin: cint; col: cint): cint {.cdecl.} =
    return niupc.GetIntId2(ih, cstring(name), lin, col)

proc GetFloatId2*(ih: PIhandle; name: string; lin: cint; col: cint): cfloat {.cdecl.} =
    return niupc.GetFloatId2(ih, cstring(name), lin, col)

proc GetDoubleId2*(ih: PIhandle; name: string; lin: cint; col: cint): cdouble {.cdecl.} =
    return niupc.GetDoubleId2(ih, cstring(name), lin, col)

proc GetRGBId2*(ih: PIhandle; name: string; lin: cint; col: cint; r: openArray[uint8]; g: openArray[uint8]; b: openArray[uint8]) {.cdecl.} =
    niupc.GetRGBId2(ih, cstring(name), lin, col, cast[ptr uint8](r), cast[ptr uint8](g), cast[ptr uint8](b))

proc SetFocus*(ih: PIhandle): PIhandle {.cdecl, discardable.} =
    return niupc.SetFocus(ih)

proc PreviousField*(ih: PIhandle): PIhandle {.cdecl.} =
    return niupc.PreviousField(ih)

proc NextField*(ih: PIhandle): PIhandle {.cdecl.} =
    return niupc.NextField(ih)

proc GetCallback*(ih: PIhandle; name: string): Icallback {.cdecl.} =
    return niupc.GetCallback(ih, cstring(name))

proc SetCallback*(ih: PIhandle; name: string; `func`: Icallback): Icallback {.cdecl.} =
    return niupc.SetCallback(ih, cstring(name), cast[Icallback](`func`))

proc SetHandle*(name: string; ih: PIhandle): PIhandle {.cdecl, discardable.} =
    return niupc.SetHandle(cstring(name), ih)

proc GetName*(ih: PIhandle): string {.cdecl.} =
    return $niupc.GetName(ih)

proc SetAttributeHandle*(ih: PIhandle; name: string; ih_named: IUPhandle_t) {.cdecl.} =
    niupc.SetAttributeHandle(ih, cstring(name), cast[PIhandle](ih_named))

proc GetAttributeHandle*(ih: PIhandle; name: string): PIhandle {.cdecl.} =
    return niupc.GetAttributeHandle(ih, cstring(name))

proc SetAttributeHandleId*(ih: PIhandle; name: string; id: cint; ih_named: IUPhandle_t) {.cdecl.} =
    niupc.SetAttributeHandleId(ih, cstring(name), id, cast[PIhandle](ih_named))

proc GetAttributeHandleId*(ih: PIhandle; name: string; id: cint): PIhandle {.cdecl.} =
    return niupc.GetAttributeHandleId(ih, cstring(name), id)

proc SetAttributeHandleId2*(ih: PIhandle; name: string; lin: cint; col: cint; ih_named: IUPhandle_t) {.cdecl.} =
    niupc.SetAttributeHandleId2(ih, cstring(name), lin, col, cast[PIhandle](ih_named))

proc GetAttributeHandleId2*(ih: PIhandle; name: string; lin: cint; col: cint): PIhandle {.cdecl.} =
    return niupc.GetAttributeHandleId2(ih, cstring(name), lin, col)

proc GetClassName*(ih: PIhandle): string {.cdecl.} =
    return $niupc.GetClassName(ih)

proc GetClassType*(ih: PIhandle): string {.cdecl.} =
    return $niupc.GetClassType(ih)

proc SaveClassAttributes*(ih: PIhandle) {.cdecl.} =
    niupc.SaveClassAttributes(ih)

proc CopyClassAttributes*(src_ih: PIhandle; dst_ih: IUPhandle_t) {.cdecl.} =
    niupc.CopyClassAttributes(cast[PIhandle](src_ih), cast[PIhandle](dst_ih))

proc ClassMatch*(ih: PIhandle; classname: string): cint {.cdecl.} =
    return niupc.ClassMatch(ih, cstring(classname))

proc Vboxv*(children: ptr PIhandle): PIhandle {.cdecl.} =
    return niupc.Vboxv(cast[ptr PIhandle](children))

proc Zboxv*(children: ptr PIhandle): PIhandle {.cdecl.} =
    return niupc.Zboxv(cast[ptr PIhandle](children))

proc Hboxv*(children: ptr PIhandle): PIhandle {.cdecl.} =
    return niupc.Hboxv(cast[ptr PIhandle](children))

proc Normalizerv*(ih_list: ptr PIhandle): PIhandle {.cdecl.} =
    return niupc.Normalizerv(cast[ptr PIhandle](ih_list))

proc Cboxv*(children: ptr PIhandle): PIhandle {.cdecl.} =
    return niupc.Cboxv(cast[ptr PIhandle](children))

proc GridBoxv*(children: ptr PIhandle): PIhandle {.cdecl.} =
    return niupc.GridBoxv(cast[ptr PIhandle](children))

proc MultiBoxv*(children: ptr PIhandle): PIhandle {.cdecl.} =
    return niupc.MultiBoxv(cast[ptr PIhandle](children))

proc Menuv*(children: ptr PIhandle): PIhandle {.cdecl.} =
    return niupc.Menuv(cast[ptr PIhandle](children))

proc Tabsv*(children: ptr PIhandle): PIhandle {.cdecl.} =
    return niupc.Tabsv(cast[ptr PIhandle](children))

proc FlatTabsv*(children: ptr PIhandle): PIhandle {.cdecl.} =
    return niupc.FlatTabsv(cast[ptr PIhandle](children))

proc SaveImageAsText*(ih: PIhandle; filename: string; format: string; name: string): cint {.cdecl.} =
    return niupc.SaveImageAsText(ih, cstring(filename), cstring(format), cstring(name))

proc TextConvertLinColToPos*(ih: PIhandle; lin: cint; col: cint; pos: var cint) {.cdecl.} =
    niupc.TextConvertLinColToPos(ih, lin, col, pos)

proc TextConvertPosToLinCol*(ih: PIhandle; pos: cint; lin: var cint; col: var cint) {.cdecl.} =
    niupc.TextConvertPosToLinCol(ih, pos, lin, col)

proc ConvertXYToPos*(ih: PIhandle; x: cint; y: cint): cint {.cdecl.} =
    return niupc.ConvertXYToPos(ih, x, y)

proc StoreAttribute*(ih: PIhandle; name: string; value: string) {.cdecl.} =
    niupc.StoreAttribute(ih, cstring(name), cstring(value))

proc StoreAttributeId*(ih: PIhandle; name: string; id: cint; value: string) {.cdecl.} =
    niupc.StoreAttributeId(ih, cstring(name), id, cstring(value))

proc StoreAttributeId2*(ih: PIhandle; name: string; lin: cint; col: cint; value: string) {.cdecl.} =
    niupc.StoreAttributeId2(ih, cstring(name), lin, col, cstring(value))

proc TreeSetUserId*(ih: PIhandle; id: cint; userid: pointer): cint {.cdecl.} =
    return niupc.TreeSetUserId(ih, id, userid)

proc TreeGetUserId*(ih: PIhandle; id: cint): pointer {.cdecl.} =
    return niupc.TreeGetUserId(ih, id)

proc TreeGetId*(ih: PIhandle; userid: pointer): cint {.cdecl.} =
    return niupc.TreeGetId(ih, userid)

proc TreeSetAttributeHandle*(ih: PIhandle; name: string; id: cint; ih_named: IUPhandle_t) {.cdecl.} =
    niupc.TreeSetAttributeHandle(ih, cstring(name), id, cast[PIhandle](ih_named))

proc MessageError*(parent: PIhandle; message: string) {.cdecl.} =
    niupc.MessageError(cast[PIhandle](parent), cstring(message))

proc MessageAlarm*(parent: PIhandle; title: string; message: string; buttons: string): cint {.cdecl.} =
    return niupc.MessageAlarm(cast[PIhandle](parent), cstring(title), cstring(message), cstring(buttons))

proc ParamBoxv*(param_array: ptr PIhandle): PIhandle {.cdecl.} =
    return niupc.ParamBoxv(cast[ptr PIhandle](param_array))

proc LayoutDialog*(dialog: PIhandle): PIhandle {.cdecl.} =
    return niupc.LayoutDialog(cast[PIhandle](dialog))

proc ElementPropertiesDialog*(parent: PIhandle; elem: IUPhandle_t): PIhandle {.cdecl.} =
    return niupc.ElementPropertiesDialog(cast[PIhandle](parent), cast[PIhandle](elem))

proc ClassInfoDialog*(parent: PIhandle): PIhandle {.cdecl.} =
    return niupc.ClassInfoDialog(cast[PIhandle](parent))

proc ConfigLoad*(ih: PIhandle): cint {.cdecl.} =
    return niupc.ConfigLoad(ih)

proc ConfigSave*(ih: PIhandle): cint {.cdecl.} =
    return niupc.ConfigSave(ih)

proc ConfigSetVariableStr*(ih: PIhandle; group: string; key: string; value: string) {.cdecl.} =
    niupc.ConfigSetVariableStr(ih, cstring(group), cstring(key), cstring(value))

proc ConfigSetVariableStrId*(ih: PIhandle; group: string; key: string; id: cint; value: string) {.cdecl.} =
    niupc.ConfigSetVariableStrId(ih, cstring(group), cstring(key), id, cstring(value))

proc ConfigSetVariableInt*(ih: PIhandle; group: string; key: string; value: cint) {.cdecl.} =
    niupc.ConfigSetVariableInt(ih, cstring(group), cstring(key), value)

proc ConfigSetVariableIntId*(ih: PIhandle; group: string; key: string; id: cint; value: cint) {.cdecl.} =
    niupc.ConfigSetVariableIntId(ih, cstring(group), cstring(key), id, value)

proc ConfigSetVariableDouble*(ih: PIhandle; group: string; key: string; value: cdouble) {.cdecl.} =
    niupc.ConfigSetVariableDouble(ih, cstring(group), cstring(key), value)

proc ConfigSetVariableDoubleId*(ih: PIhandle; group: string; key: string; id: cint; value: cdouble) {.cdecl.} =
    niupc.ConfigSetVariableDoubleId(ih, cstring(group), cstring(key), id, value)

proc ConfigGetVariableStr*(ih: PIhandle; group: string; key: string): string {.cdecl.} =
    return $niupc.ConfigGetVariableStr(ih, cstring(group), cstring(key))

proc ConfigGetVariableStrId*(ih: PIhandle; group: string; key: string; id: cint): string {.cdecl.} =
    return $niupc.ConfigGetVariableStrId(ih, cstring(group), cstring(key), id)

proc ConfigGetVariableInt*(ih: PIhandle; group: string; key: string): cint {.cdecl.} =
    return niupc.ConfigGetVariableInt(ih, cstring(group), cstring(key))

proc ConfigGetVariableIntId*(ih: PIhandle; group: string; key: string; id: cint): cint {.cdecl.} =
    return niupc.ConfigGetVariableIntId(ih, cstring(group), cstring(key), id)

proc ConfigGetVariableDouble*(ih: PIhandle; group: string; key: string): cdouble {.cdecl.} =
    return niupc.ConfigGetVariableDouble(ih, cstring(group), cstring(key))

proc ConfigGetVariableDoubleId*(ih: PIhandle; group: string; key: string; id: cint): cdouble {.cdecl.} =
    return niupc.ConfigGetVariableDoubleId(ih, cstring(group), cstring(key), id)

proc ConfigGetVariableStrDef*(ih: PIhandle; group: string; key: string; def: string): string {.cdecl.} =
    return $niupc.ConfigGetVariableStrDef(ih, cstring(group), cstring(key), cstring(def))

proc ConfigGetVariableStrIdDef*(ih: PIhandle; group: string; key: string; id: cint; def: string): string {.cdecl.} =
    return $niupc.ConfigGetVariableStrIdDef(ih, cstring(group), cstring(key), id, cstring(def))

proc ConfigGetVariableIntDef*(ih: PIhandle; group: string; key: string; def: cint): cint {.cdecl.} =
    return niupc.ConfigGetVariableIntDef(ih, cstring(group), cstring(key), def)

proc ConfigGetVariableIntIdDef*(ih: PIhandle; group: string; key: string; id: cint; def: cint): cint {.cdecl.} =
    return niupc.ConfigGetVariableIntIdDef(ih, cstring(group), cstring(key), id, def)

proc ConfigGetVariableDoubleDef*(ih: PIhandle; group: string; key: string; def: cdouble): cdouble {.cdecl.} =
    return niupc.ConfigGetVariableDoubleDef(ih, cstring(group), cstring(key), def)

proc ConfigGetVariableDoubleIdDef*(ih: PIhandle; group: string; key: string; id: cint; def: cdouble): cdouble {.cdecl.} =
    return niupc.ConfigGetVariableDoubleIdDef(ih, cstring(group), cstring(key), id, def)

proc ConfigCopy*(ih1: PIhandle; ih2: IUPhandle_t; exclude_prefix: string) {.cdecl.} =
    niupc.ConfigCopy(cast[PIhandle](ih1), cast[PIhandle](ih2), cstring(exclude_prefix))

proc ConfigSetListVariable*(ih: PIhandle; group: string; key: string; value: string; add: cint) {.cdecl.} =
    niupc.ConfigSetListVariable(ih, cstring(group), cstring(key), cstring(value), add)

proc ConfigRecentInit*(ih: PIhandle; menu: IUPhandle_t; recent_cb: Icallback; max_recent: cint) {.cdecl.} =
    niupc.ConfigRecentInit(ih, cast[PIhandle](menu), cast[Icallback](recent_cb), max_recent)

proc ConfigRecentUpdate*(ih: PIhandle; filename: string) {.cdecl.} =
    niupc.ConfigRecentUpdate(ih, cstring(filename))

proc ConfigDialogShow*(ih: PIhandle; dialog: IUPhandle_t; name: string) {.cdecl.} =
    niupc.ConfigDialogShow(ih, cast[PIhandle](dialog), cstring(name))

proc ConfigDialogClosed*(ih: PIhandle; dialog: IUPhandle_t; name: string) {.cdecl.} =
    niupc.ConfigDialogClosed(ih, cast[PIhandle](dialog), cstring(name))

proc MatrixSetFormula*(ih: PIhandle; col: cint; formula: string; init: string) {.cdecl.} =
    niupc.MatrixSetFormula(ih, col, cstring(formula), cstring(init))

proc MatrixSetDynamic*(ih: PIhandle; init: string) {.cdecl.} =
    niupc.MatrixSetDynamic(ih, cstring(init))

proc DrawBegin*(ih: PIhandle) {.cdecl.} =
    niupc.DrawBegin(ih)

proc DrawEnd*(ih: PIhandle) {.cdecl.} =
    niupc.DrawEnd(ih)

proc DrawSetClipRect*(ih: PIhandle; x1: cint; y1: cint; x2: cint; y2: cint) {.cdecl.} =
    niupc.DrawSetClipRect(ih, x1, y1, x2, y2)

proc DrawGetClipRect*(ih: PIhandle; x1: var cint; y1: var cint; x2: var cint; y2: var cint) {.cdecl.} =
    niupc.DrawGetClipRect(ih, x1, y1, x2, y2)

proc DrawResetClip*(ih: PIhandle) {.cdecl.} =
    niupc.DrawResetClip(ih)

proc DrawParentBackground*(ih: PIhandle) {.cdecl.} =
    niupc.DrawParentBackground(ih)

proc DrawLine*(ih: PIhandle; x1: cint; y1: cint; x2: cint; y2: cint) {.cdecl.} =
    niupc.DrawLine(ih, x1, y1, x2, y2)

proc DrawRectangle*(ih: PIhandle; x1: cint; y1: cint; x2: cint; y2: cint) {.cdecl.} =
    niupc.DrawRectangle(ih, x1, y1, x2, y2)

proc DrawArc*(ih: PIhandle; x1: cint; y1: cint; x2: cint; y2: cint; a1: cdouble; a2: cdouble) {.cdecl.} =
    niupc.DrawArc(ih, x1, y1, x2, y2, a1, a2)

proc DrawPolygon*(ih: PIhandle; points: var cint; count: cint) {.cdecl.} =
    niupc.DrawPolygon(ih, points, count)

proc DrawText*(ih: PIhandle; text: string; len: cint; x: cint; y: cint; w: cint; h: cint) {.cdecl.} =
    niupc.DrawText(ih, cstring(text), len, x, y, w, h)

proc DrawImage*(ih: PIhandle; name: string; x: cint; y: cint; w: cint; h: cint) {.cdecl.} =
    niupc.DrawImage(ih, cstring(name), x, y, w, h)

proc DrawSelectRect*(ih: PIhandle; x1: cint; y1: cint; x2: cint; y2: cint) {.cdecl.} =
    niupc.DrawSelectRect(ih, x1, y1, x2, y2)

proc DrawFocusRect*(ih: PIhandle; x1: cint; y1: cint; x2: cint; y2: cint) {.cdecl.} =
    niupc.DrawFocusRect(ih, x1, y1, x2, y2)

proc DrawGetSize*(ih: PIhandle; w: var cint; h: var cint) {.cdecl.} =
    niupc.DrawGetSize(ih, w, h)

proc DrawGetTextSize*(ih: PIhandle; text: string; len: cint; w: var cint; h: var cint) {.cdecl.} =
    niupc.DrawGetTextSize(ih, cstring(text), len, w, h)

proc GLCanvasBoxv*(children: ptr PIhandle): PIhandle {.cdecl.} =
    return niupc.GLCanvasBoxv(cast[ptr PIhandle](children))

proc GLFrame*(child: PIhandle): PIhandle {.cdecl.} =
    return niupc.GLFrame(cast[PIhandle](child))

proc GLExpander*(child: PIhandle): PIhandle {.cdecl.} =
    return niupc.GLExpander(cast[PIhandle](child))

proc GLScrollBox*(child: PIhandle): PIhandle {.cdecl.} =
    return niupc.GLScrollBox(cast[PIhandle](child))

proc GLSizeBox*(child: PIhandle): PIhandle {.cdecl.} =
    return niupc.GLSizeBox(cast[PIhandle](child))

proc GLDrawImage*(ih: PIhandle; name: string; x: cint; y: cint; active: cint) {.cdecl.} =
    niupc.GLDrawImage(ih, cstring(name), x, y, active)

proc GLDrawText*(ih: PIhandle; str: string; len: cint; x: cint; y: cint) {.cdecl.} =
    niupc.GLDrawText(ih, cstring(str), len, x, y)

proc GLDrawGetTextSize*(ih: PIhandle; str: string; w: var cint; h: var cint) {.cdecl.} =
    niupc.GLDrawGetTextSize(ih, cstring(str), w, h)

proc GLBackgroundBox*(child: PIhandle): PIhandle {.cdecl.} =
    return niupc.GLBackgroundBox(cast[PIhandle](child))

proc GLMakeCurrent*(ih: PIhandle) {.cdecl.} =
    niupc.GLMakeCurrent(ih)

proc GLIsCurrent*(ih: PIhandle): cint {.cdecl.} =
    return niupc.GLIsCurrent(ih)

proc GLSwapBuffers*(ih: PIhandle) {.cdecl.} =
    niupc.GLSwapBuffers(ih)

proc GLPalette*(ih: PIhandle; index: cint; r: cfloat; g: cfloat; b: cfloat) {.cdecl.} =
    niupc.GLPalette(ih, index, r, g, b)

proc GLUseFont*(ih: PIhandle; first: cint; count: cint; list_base: cint) {.cdecl.} =
    niupc.GLUseFont(ih, first, count, list_base)

proc SaveImage*(ih: PIhandle; filename: string; format: string): cint {.cdecl.} =
    return niupc.SaveImage(ih, cstring(filename), cstring(format))

proc ImageToImImage*(iup_image: PIhandle): ptr imImage {.cdecl.} =
    return niupc.ImageToImImage(cast[PIhandle](iup_image))

proc MglPlotBegin*(ih: PIhandle; dim: cint) {.cdecl.} =
    niupc.MglPlotBegin(ih, dim)

proc MglPlotAdd1D*(ih: PIhandle; name: string; y: cdouble) {.cdecl.} =
    niupc.MglPlotAdd1D(ih, cstring(name), y)

proc MglPlotAdd2D*(ih: PIhandle; x: cdouble; y: cdouble) {.cdecl.} =
    niupc.MglPlotAdd2D(ih, x, y)

proc MglPlotAdd3D*(ih: PIhandle; x: cdouble; y: cdouble; z: cdouble) {.cdecl.} =
    niupc.MglPlotAdd3D(ih, x, y, z)

proc MglPlotEnd*(ih: PIhandle): cint {.cdecl.} =
    return niupc.MglPlotEnd(ih)

proc MglPlotNewDataSet*(ih: PIhandle; dim: cint): cint {.cdecl.} =
    return niupc.MglPlotNewDataSet(ih, dim)

proc MglPlotInsert1D*(ih: PIhandle; ds_index: cint; sample_index: cint; names: cstringArray; y: ptr cdouble; count: cint) {.cdecl.} =
    niupc.MglPlotInsert1D(ih, ds_index, sample_index, names, y, count)

proc MglPlotInsert2D*(ih: PIhandle; ds_index: cint; sample_index: cint; x: ptr cdouble; y: ptr cdouble; count: cint) {.cdecl.} =
    niupc.MglPlotInsert2D(ih, ds_index, sample_index, x, y, count)

proc MglPlotInsert3D*(ih: PIhandle; ds_index: cint; sample_index: cint; x: ptr cdouble; y: ptr cdouble; z: ptr cdouble; count: cint) {.cdecl.} =
    niupc.MglPlotInsert3D(ih, ds_index, sample_index, x, y, z, count)

proc MglPlotSet1D*(ih: PIhandle; ds_index: cint; names: cstringArray; y: ptr cdouble; count: cint) {.cdecl.} =
    niupc.MglPlotSet1D(ih, ds_index, names, y, count)

proc MglPlotSet2D*(ih: PIhandle; ds_index: cint; x: ptr cdouble; y: ptr cdouble; count: cint) {.cdecl.} =
    niupc.MglPlotSet2D(ih, ds_index, x, y, count)

proc MglPlotSet3D*(ih: PIhandle; ds_index: cint; x: ptr cdouble; y: ptr cdouble; z: ptr cdouble; count: cint) {.cdecl.} =
    niupc.MglPlotSet3D(ih, ds_index, x, y, z, count)

proc MglPlotSetFormula*(ih: PIhandle; ds_index: cint; formulaX: string; formulaY: string; formulaZ: string; count: cint) {.cdecl.} =
    niupc.MglPlotSetFormula(ih, ds_index, cstring(formulaX), cstring(formulaY), cstring(formulaZ), count)

proc MglPlotSetData*(ih: PIhandle; ds_index: cint; data: ptr cdouble; count_x: cint; count_y: cint; count_z: cint) {.cdecl.} =
    niupc.MglPlotSetData(ih, ds_index, data, count_x, count_y, count_z)

proc MglPlotLoadData*(ih: PIhandle; ds_index: cint; filename: string; count_x: cint; count_y: cint; count_z: cint) {.cdecl.} =
    niupc.MglPlotLoadData(ih, ds_index, cstring(filename), count_x, count_y, count_z)

proc MglPlotSetFromFormula*(ih: PIhandle; ds_index: cint; formula: string; count_x: cint; count_y: cint; count_z: cint) {.cdecl.} =
    niupc.MglPlotSetFromFormula(ih, ds_index, cstring(formula), count_x, count_y, count_z)

proc MglPlotTransform*(ih: PIhandle; x: cdouble; y: cdouble; z: cdouble; ix: var cint; iy: var cint) {.cdecl.} =
    niupc.MglPlotTransform(ih, x, y, z, ix, iy)

proc MglPlotTransformTo*(ih: PIhandle; ix: cint; iy: cint; x: ptr cdouble; y: ptr cdouble; z: ptr cdouble) {.cdecl.} =
    niupc.MglPlotTransformTo(ih, ix, iy, x, y, z)

proc MglPlotDrawMark*(ih: PIhandle; x: cdouble; y: cdouble; z: cdouble) {.cdecl.} =
    niupc.MglPlotDrawMark(ih, x, y, z)

proc MglPlotDrawLine*(ih: PIhandle; x1: cdouble; y1: cdouble; z1: cdouble; x2: cdouble; y2: cdouble; z2: cdouble) {.cdecl.} =
    niupc.MglPlotDrawLine(ih, x1, y1, z1, x2, y2, z2)

proc MglPlotDrawText*(ih: PIhandle; text: string; x: cdouble; y: cdouble; z: cdouble) {.cdecl.} =
    niupc.MglPlotDrawText(ih, cstring(text), x, y, z)

proc MglPlotPaintTo*(ih: PIhandle; format: string; w: cint; h: cint; dpi: cdouble; data: pointer) {.cdecl.} =
    niupc.MglPlotPaintTo(ih, cstring(format), w, h, dpi, data)

proc PlotBegin*(ih: PIhandle; strXdata: cint) {.cdecl.} =
    niupc.PlotBegin(ih, strXdata)

proc PlotAdd*(ih: PIhandle; x: cdouble; y: cdouble) {.cdecl.} =
    niupc.PlotAdd(ih, x, y)

proc PlotAddStr*(ih: PIhandle; x: string; y: cdouble) {.cdecl.} =
    niupc.PlotAddStr(ih, cstring(x), y)

proc PlotAddSegment*(ih: PIhandle; x: cdouble; y: cdouble) {.cdecl.} =
    niupc.PlotAddSegment(ih, x, y)

proc PlotEnd*(ih: PIhandle): cint {.cdecl.} =
    return niupc.PlotEnd(ih)

proc PlotLoadData*(ih: PIhandle; filename: string; strXdata: cint): cint {.cdecl.} =
    return niupc.PlotLoadData(ih, cstring(filename), strXdata)

proc PlotSetFormula*(ih: PIhandle; sample_count: cint; formula: string; init: string): cint {.cdecl.} =
    return niupc.PlotSetFormula(ih, sample_count, cstring(formula), cstring(init))

proc PlotInsert*(ih: PIhandle; ds_index: cint; sample_index: cint; x: cdouble; y: cdouble) {.cdecl.} =
    niupc.PlotInsert(ih, ds_index, sample_index, x, y)

proc PlotInsertStr*(ih: PIhandle; ds_index: cint; sample_index: cint; x: string; y: cdouble) {.cdecl.} =
    niupc.PlotInsertStr(ih, ds_index, sample_index, cstring(x), y)

proc PlotInsertSegment*(ih: PIhandle; ds_index: cint; sample_index: cint; x: cdouble; y: cdouble) {.cdecl.} =
    niupc.PlotInsertSegment(ih, ds_index, sample_index, x, y)

proc PlotInsertStrSamples*(ih: PIhandle; ds_index: cint; sample_index: cint; x: cstringArray; y: ptr cdouble; count: cint) {.cdecl.} =
    niupc.PlotInsertStrSamples(ih, ds_index, sample_index, x, y, count)

proc PlotInsertSamples*(ih: PIhandle; ds_index: cint; sample_index: cint; x: ptr cdouble; y: ptr cdouble; count: cint) {.cdecl.} =
    niupc.PlotInsertSamples(ih, ds_index, sample_index, x, y, count)

proc PlotAddSamples*(ih: PIhandle; ds_index: cint; x: ptr cdouble; y: ptr cdouble; count: cint) {.cdecl.} =
    niupc.PlotAddSamples(ih, ds_index, x, y, count)

proc PlotAddStrSamples*(ih: PIhandle; ds_index: cint; x: cstringArray; y: ptr cdouble; count: cint) {.cdecl.} =
    niupc.PlotAddStrSamples(ih, ds_index, x, y, count)

proc PlotGetSample*(ih: PIhandle; ds_index: cint; sample_index: cint; x: ptr cdouble; y: ptr cdouble) {.cdecl.} =
    niupc.PlotGetSample(ih, ds_index, sample_index, x, y)

proc PlotGetSampleStr*(ih: PIhandle; ds_index: cint; sample_index: cint; x: cstringArray; y: ptr cdouble) {.cdecl.} =
    niupc.PlotGetSampleStr(ih, ds_index, sample_index, x, y)

proc PlotGetSampleSelection*(ih: PIhandle; ds_index: cint; sample_index: cint): cint {.cdecl.} =
    return niupc.PlotGetSampleSelection(ih, ds_index, sample_index)

proc PlotGetSampleExtra*(ih: PIhandle; ds_index: cint; sample_index: cint): cdouble {.cdecl.} =
    return niupc.PlotGetSampleExtra(ih, ds_index, sample_index)

proc PlotSetSample*(ih: PIhandle; ds_index: cint; sample_index: cint; x: cdouble; y: cdouble) {.cdecl.} =
    niupc.PlotSetSample(ih, ds_index, sample_index, x, y)

proc PlotSetSampleStr*(ih: PIhandle; ds_index: cint; sample_index: cint; x: string; y: cdouble) {.cdecl.} =
    niupc.PlotSetSampleStr(ih, ds_index, sample_index, cstring(x), y)

proc PlotSetSampleSelection*(ih: PIhandle; ds_index: cint; sample_index: cint; selected: cint) {.cdecl.} =
    niupc.PlotSetSampleSelection(ih, ds_index, sample_index, selected)

proc PlotSetSampleExtra*(ih: PIhandle; ds_index: cint; sample_index: cint; extra: cdouble) {.cdecl.} =
    niupc.PlotSetSampleExtra(ih, ds_index, sample_index, extra)

proc PlotTransform*(ih: PIhandle; x: cdouble; y: cdouble; cnv_x: ptr cdouble; cnv_y: ptr cdouble) {.cdecl.} =
    niupc.PlotTransform(ih, x, y, cnv_x, cnv_y)

proc PlotTransformTo*(ih: PIhandle; cnv_x: cdouble; cnv_y: cdouble; x: ptr cdouble; y: ptr cdouble) {.cdecl.} =
    niupc.PlotTransformTo(ih, cnv_x, cnv_y, x, y)

proc PlotFindSample*(ih: PIhandle; cnv_x: cdouble; cnv_y: cdouble; ds_index: var cint; sample_index: var cint): cint {.cdecl.} =
    return niupc.PlotFindSample(ih, cnv_x, cnv_y, ds_index, sample_index)

proc PlotFindSegment*(ih: PIhandle; cnv_x: cdouble; cnv_y: cdouble; ds_index: var cint; sample_index1: var cint; sample_index2: var cint): cint {.cdecl.} =
    return niupc.PlotFindSegment(ih, cnv_x, cnv_y, ds_index, sample_index1, sample_index2)

proc PlotPaintTo*(ih: PIhandle; cnv: ptr cdCanvas) {.cdecl.} =
    niupc.PlotPaintTo(ih, cnv)

proc ScintillaSendMessage*(ih: PIhandle; iMessage: cuint; wParam: clong; lParam: clong): clong {.cdecl.} =
    return niupc.ScintillaSendMessage(ih, iMessage, wParam, lParam)



# K_* callbacks
proc `k_sp=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_SP", cast[Icallback](cb))
proc `k_sp`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_SP"))
proc `k_exclam=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_exclam", cast[Icallback](cb))
proc `k_exclam`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_exclam"))
proc `k_quotedbl=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_quotedbl", cast[Icallback](cb))
proc `k_quotedbl`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_quotedbl"))
proc `k_numbersign=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_numbersign", cast[Icallback](cb))
proc `k_numbersign`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_numbersign"))
proc `k_dollar=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_dollar", cast[Icallback](cb))
proc `k_dollar`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_dollar"))
proc `k_percent=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_percent", cast[Icallback](cb))
proc `k_percent`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_percent"))
proc `k_ampersand=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_ampersand", cast[Icallback](cb))
proc `k_ampersand`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_ampersand"))
proc `k_apostrophe=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_apostrophe", cast[Icallback](cb))
proc `k_apostrophe`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_apostrophe"))
proc `k_parentleft=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_parentleft", cast[Icallback](cb))
proc `k_parentleft`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_parentleft"))
proc `k_parentright=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_parentright", cast[Icallback](cb))
proc `k_parentright`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_parentright"))
proc `k_asterisk=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_asterisk", cast[Icallback](cb))
proc `k_asterisk`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_asterisk"))
proc `k_plus=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_plus", cast[Icallback](cb))
proc `k_plus`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_plus"))
proc `k_comma=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_comma", cast[Icallback](cb))
proc `k_comma`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_comma"))
proc `k_minus=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_minus", cast[Icallback](cb))
proc `k_minus`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_minus"))
proc `k_period=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_period", cast[Icallback](cb))
proc `k_period`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_period"))
proc `k_slash=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_slash", cast[Icallback](cb))
proc `k_slash`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_slash"))
proc `k_0=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_0", cast[Icallback](cb))
proc `k_0`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_0"))
proc `k_1=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_1", cast[Icallback](cb))
proc `k_1`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_1"))
proc `k_2=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_2", cast[Icallback](cb))
proc `k_2`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_2"))
proc `k_3=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_3", cast[Icallback](cb))
proc `k_3`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_3"))
proc `k_4=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_4", cast[Icallback](cb))
proc `k_4`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_4"))
proc `k_5=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_5", cast[Icallback](cb))
proc `k_5`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_5"))
proc `k_6=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_6", cast[Icallback](cb))
proc `k_6`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_6"))
proc `k_7=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_7", cast[Icallback](cb))
proc `k_7`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_7"))
proc `k_8=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_8", cast[Icallback](cb))
proc `k_8`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_8"))
proc `k_9=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_9", cast[Icallback](cb))
proc `k_9`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_9"))
proc `k_colon=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_colon", cast[Icallback](cb))
proc `k_colon`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_colon"))
proc `k_semicolon=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_semicolon", cast[Icallback](cb))
proc `k_semicolon`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_semicolon"))
proc `k_less=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_less", cast[Icallback](cb))
proc `k_less`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_less"))
proc `k_equal=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_equal", cast[Icallback](cb))
proc `k_equal`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_equal"))
proc `k_greater=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_greater", cast[Icallback](cb))
proc `k_greater`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_greater"))
proc `k_question=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_question", cast[Icallback](cb))
proc `k_question`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_question"))
proc `k_at=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_at", cast[Icallback](cb))
proc `k_at`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_at"))
proc `k_uppera=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperA", cast[Icallback](cb))
proc `k_uppera`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperA"))
proc `k_upperb=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperB", cast[Icallback](cb))
proc `k_upperb`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperB"))
proc `k_upperc=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperC", cast[Icallback](cb))
proc `k_upperc`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperC"))
proc `k_upperd=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperD", cast[Icallback](cb))
proc `k_upperd`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperD"))
proc `k_uppere=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperE", cast[Icallback](cb))
proc `k_uppere`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperE"))
proc `k_upperf=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperF", cast[Icallback](cb))
proc `k_upperf`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperF"))
proc `k_upperg=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperG", cast[Icallback](cb))
proc `k_upperg`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperG"))
proc `k_upperh=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperH", cast[Icallback](cb))
proc `k_upperh`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperH"))
proc `k_upperi=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperI", cast[Icallback](cb))
proc `k_upperi`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperI"))
proc `k_upperj=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperJ", cast[Icallback](cb))
proc `k_upperj`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperJ"))
proc `k_upperk=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperK", cast[Icallback](cb))
proc `k_upperk`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperK"))
proc `k_upperl=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperL", cast[Icallback](cb))
proc `k_upperl`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperL"))
proc `k_upperm=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperM", cast[Icallback](cb))
proc `k_upperm`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperM"))
proc `k_uppern=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperN", cast[Icallback](cb))
proc `k_uppern`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperN"))
proc `k_uppero=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperO", cast[Icallback](cb))
proc `k_uppero`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperO"))
proc `k_upperp=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperP", cast[Icallback](cb))
proc `k_upperp`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperP"))
proc `k_upperq=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperQ", cast[Icallback](cb))
proc `k_upperq`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperQ"))
proc `k_upperr=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperR", cast[Icallback](cb))
proc `k_upperr`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperR"))
proc `k_uppers=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperS", cast[Icallback](cb))
proc `k_uppers`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperS"))
proc `k_uppert=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperT", cast[Icallback](cb))
proc `k_uppert`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperT"))
proc `k_upperu=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperU", cast[Icallback](cb))
proc `k_upperu`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperU"))
proc `k_upperv=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperV", cast[Icallback](cb))
proc `k_upperv`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperV"))
proc `k_upperw=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperW", cast[Icallback](cb))
proc `k_upperw`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperW"))
proc `k_upperx=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperX", cast[Icallback](cb))
proc `k_upperx`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperX"))
proc `k_uppery=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperY", cast[Icallback](cb))
proc `k_uppery`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperY"))
proc `k_upperz=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_upperZ", cast[Icallback](cb))
proc `k_upperz`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_upperZ"))
proc `k_bracketleft=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_bracketleft", cast[Icallback](cb))
proc `k_bracketleft`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_bracketleft"))
proc `k_backslash=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_backslash", cast[Icallback](cb))
proc `k_backslash`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_backslash"))
proc `k_bracketright=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_bracketright", cast[Icallback](cb))
proc `k_bracketright`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_bracketright"))
proc `k_circum=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_circum", cast[Icallback](cb))
proc `k_circum`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_circum"))
proc `k_underscore=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_underscore", cast[Icallback](cb))
proc `k_underscore`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_underscore"))
proc `k_grave=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_grave", cast[Icallback](cb))
proc `k_grave`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_grave"))
proc `k_lowera=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowera", cast[Icallback](cb))
proc `k_lowera`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowera"))
proc `k_lowerb=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowerb", cast[Icallback](cb))
proc `k_lowerb`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowerb"))
proc `k_lowerc=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowerc", cast[Icallback](cb))
proc `k_lowerc`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowerc"))
proc `k_lowerd=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowerd", cast[Icallback](cb))
proc `k_lowerd`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowerd"))
proc `k_lowere=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowere", cast[Icallback](cb))
proc `k_lowere`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowere"))
proc `k_lowerf=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowerf", cast[Icallback](cb))
proc `k_lowerf`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowerf"))
proc `k_lowerg=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowerg", cast[Icallback](cb))
proc `k_lowerg`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowerg"))
proc `k_lowerh=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowerh", cast[Icallback](cb))
proc `k_lowerh`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowerh"))
proc `k_loweri=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_loweri", cast[Icallback](cb))
proc `k_loweri`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_loweri"))
proc `k_lowerj=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowerj", cast[Icallback](cb))
proc `k_lowerj`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowerj"))
proc `k_lowerk=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowerk", cast[Icallback](cb))
proc `k_lowerk`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowerk"))
proc `k_lowerl=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowerl", cast[Icallback](cb))
proc `k_lowerl`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowerl"))
proc `k_lowerm=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowerm", cast[Icallback](cb))
proc `k_lowerm`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowerm"))
proc `k_lowern=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowern", cast[Icallback](cb))
proc `k_lowern`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowern"))
proc `k_lowero=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowero", cast[Icallback](cb))
proc `k_lowero`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowero"))
proc `k_lowerp=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowerp", cast[Icallback](cb))
proc `k_lowerp`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowerp"))
proc `k_lowerq=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowerq", cast[Icallback](cb))
proc `k_lowerq`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowerq"))
proc `k_lowerr=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowerr", cast[Icallback](cb))
proc `k_lowerr`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowerr"))
proc `k_lowers=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowers", cast[Icallback](cb))
proc `k_lowers`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowers"))
proc `k_lowert=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowert", cast[Icallback](cb))
proc `k_lowert`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowert"))
proc `k_loweru=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_loweru", cast[Icallback](cb))
proc `k_loweru`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_loweru"))
proc `k_lowerv=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowerv", cast[Icallback](cb))
proc `k_lowerv`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowerv"))
proc `k_lowerw=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowerw", cast[Icallback](cb))
proc `k_lowerw`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowerw"))
proc `k_lowerx=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowerx", cast[Icallback](cb))
proc `k_lowerx`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowerx"))
proc `k_lowery=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowery", cast[Icallback](cb))
proc `k_lowery`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowery"))
proc `k_lowerz=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowerz", cast[Icallback](cb))
proc `k_lowerz`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowerz"))
proc `k_braceleft=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_braceleft", cast[Icallback](cb))
proc `k_braceleft`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_braceleft"))
proc `k_bar=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_bar", cast[Icallback](cb))
proc `k_bar`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_bar"))
proc `k_braceright=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_braceright", cast[Icallback](cb))
proc `k_braceright`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_braceright"))
proc `k_tilde=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_tilde", cast[Icallback](cb))
proc `k_tilde`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_tilde"))
proc `k_bs=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_BS", cast[Icallback](cb))
proc `k_bs`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_BS"))
proc `k_tab=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_TAB", cast[Icallback](cb))
proc `k_tab`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_TAB"))
proc `k_lf=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_LF", cast[Icallback](cb))
proc `k_lf`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_LF"))
proc `k_cr=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_CR", cast[Icallback](cb))
proc `k_cr`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_CR"))
proc `k_quoteleft=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_quoteleft", cast[Icallback](cb))
proc `k_quoteleft`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_quoteleft"))
proc `k_quoteright=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_quoteright", cast[Icallback](cb))
proc `k_quoteright`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_quoteright"))
proc `k_pause=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_PAUSE", cast[Icallback](cb))
proc `k_pause`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_PAUSE"))
proc `k_esc=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_ESC", cast[Icallback](cb))
proc `k_esc`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_ESC"))
proc `k_home=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_HOME", cast[Icallback](cb))
proc `k_home`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_HOME"))
proc `k_left=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_LEFT", cast[Icallback](cb))
proc `k_left`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_LEFT"))
proc `k_up=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_UP", cast[Icallback](cb))
proc `k_up`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_UP"))
proc `k_right=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_RIGHT", cast[Icallback](cb))
proc `k_right`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_RIGHT"))
proc `k_down=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_DOWN", cast[Icallback](cb))
proc `k_down`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_DOWN"))
proc `k_pgup=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_PGUP", cast[Icallback](cb))
proc `k_pgup`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_PGUP"))
proc `k_pgdn=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_PGDN", cast[Icallback](cb))
proc `k_pgdn`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_PGDN"))
proc `k_end=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_END", cast[Icallback](cb))
proc `k_end`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_END"))
proc `k_middle=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_MIDDLE", cast[Icallback](cb))
proc `k_middle`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_MIDDLE"))
proc `k_print=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_Print", cast[Icallback](cb))
proc `k_print`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_Print"))
proc `k_ins=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_INS", cast[Icallback](cb))
proc `k_ins`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_INS"))
proc `k_menu=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_Menu", cast[Icallback](cb))
proc `k_menu`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_Menu"))
proc `k_del=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_DEL", cast[Icallback](cb))
proc `k_del`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_DEL"))
proc `k_f1=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_F1", cast[Icallback](cb))
proc `k_f1`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_F1"))
proc `k_f2=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_F2", cast[Icallback](cb))
proc `k_f2`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_F2"))
proc `k_f3=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_F3", cast[Icallback](cb))
proc `k_f3`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_F3"))
proc `k_f4=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_F4", cast[Icallback](cb))
proc `k_f4`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_F4"))
proc `k_f5=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_F5", cast[Icallback](cb))
proc `k_f5`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_F5"))
proc `k_f6=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_F6", cast[Icallback](cb))
proc `k_f6`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_F6"))
proc `k_f7=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_F7", cast[Icallback](cb))
proc `k_f7`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_F7"))
proc `k_f8=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_F8", cast[Icallback](cb))
proc `k_f8`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_F8"))
proc `k_f9=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_F9", cast[Icallback](cb))
proc `k_f9`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_F9"))
proc `k_f10=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_F10", cast[Icallback](cb))
proc `k_f10`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_F10"))
proc `k_f11=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_F11", cast[Icallback](cb))
proc `k_f11`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_F11"))
proc `k_f12=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_F12", cast[Icallback](cb))
proc `k_f12`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_F12"))
proc `k_f13=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_F13", cast[Icallback](cb))
proc `k_f13`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_F13"))
proc `k_f14=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_F14", cast[Icallback](cb))
proc `k_f14`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_F14"))
proc `k_f15=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_F15", cast[Icallback](cb))
proc `k_f15`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_F15"))
proc `k_f16=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_F16", cast[Icallback](cb))
proc `k_f16`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_F16"))
proc `k_f17=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_F17", cast[Icallback](cb))
proc `k_f17`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_F17"))
proc `k_f18=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_F18", cast[Icallback](cb))
proc `k_f18`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_F18"))
proc `k_f19=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_F19", cast[Icallback](cb))
proc `k_f19`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_F19"))
proc `k_f20=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_F20", cast[Icallback](cb))
proc `k_f20`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_F20"))
proc `k_lshift=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_LSHIFT", cast[Icallback](cb))
proc `k_lshift`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_LSHIFT"))
proc `k_rshift=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_RSHIFT", cast[Icallback](cb))
proc `k_rshift`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_RSHIFT"))
proc `k_lctrl=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_LCTRL", cast[Icallback](cb))
proc `k_lctrl`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_LCTRL"))
proc `k_rctrl=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_RCTRL", cast[Icallback](cb))
proc `k_rctrl`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_RCTRL"))
proc `k_lalt=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_LALT", cast[Icallback](cb))
proc `k_lalt`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_LALT"))
proc `k_ralt=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_RALT", cast[Icallback](cb))
proc `k_ralt`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_RALT"))
proc `k_num=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_NUM", cast[Icallback](cb))
proc `k_num`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_NUM"))
proc `k_scroll=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_SCROLL", cast[Icallback](cb))
proc `k_scroll`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_SCROLL"))
proc `k_caps=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_CAPS", cast[Icallback](cb))
proc `k_caps`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_CAPS"))
proc `k_clear=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_CLEAR", cast[Icallback](cb))
proc `k_clear`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_CLEAR"))
proc `k_help=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_HELP", cast[Icallback](cb))
proc `k_help`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_HELP"))
proc `k_lowerccedilla=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_lowerccedilla", cast[Icallback](cb))
proc `k_lowerccedilla`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_lowerccedilla"))
proc `k_ccedilla=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_Ccedilla", cast[Icallback](cb))
proc `k_ccedilla`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_Ccedilla"))
proc `k_acute=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_acute", cast[Icallback](cb))
proc `k_acute`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_acute"))
proc `k_diaeresis=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_diaeresis", cast[Icallback](cb))
proc `k_diaeresis`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_diaeresis"))
proc `k_shome=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sHOME", cast[Icallback](cb))
proc `k_shome`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sHOME"))
proc `k_sup=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sUP", cast[Icallback](cb))
proc `k_sup`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sUP"))
proc `k_spgup=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sPGUP", cast[Icallback](cb))
proc `k_spgup`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sPGUP"))
proc `k_sleft=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sLEFT", cast[Icallback](cb))
proc `k_sleft`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sLEFT"))
proc `k_smiddle=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sMIDDLE", cast[Icallback](cb))
proc `k_smiddle`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sMIDDLE"))
proc `k_sright=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sRIGHT", cast[Icallback](cb))
proc `k_sright`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sRIGHT"))
proc `k_send=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sEND", cast[Icallback](cb))
proc `k_send`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sEND"))
proc `k_sdown=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sDOWN", cast[Icallback](cb))
proc `k_sdown`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sDOWN"))
proc `k_spgdn=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sPGDN", cast[Icallback](cb))
proc `k_spgdn`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sPGDN"))
proc `k_sins=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sINS", cast[Icallback](cb))
proc `k_sins`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sINS"))
proc `k_sdel=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sDEL", cast[Icallback](cb))
proc `k_sdel`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sDEL"))
proc `k_ssp=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sSP", cast[Icallback](cb))
proc `k_ssp`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sSP"))
proc `k_stab=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sTAB", cast[Icallback](cb))
proc `k_stab`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sTAB"))
proc `k_scr=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sCR", cast[Icallback](cb))
proc `k_scr`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sCR"))
proc `k_sbs=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sBS", cast[Icallback](cb))
proc `k_sbs`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sBS"))
proc `k_spause=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sPAUSE", cast[Icallback](cb))
proc `k_spause`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sPAUSE"))
proc `k_sesc=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sESC", cast[Icallback](cb))
proc `k_sesc`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sESC"))
proc `k_sclear=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sCLEAR", cast[Icallback](cb))
proc `k_sclear`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sCLEAR"))
proc `k_sf1=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sF1", cast[Icallback](cb))
proc `k_sf1`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sF1"))
proc `k_sf2=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sF2", cast[Icallback](cb))
proc `k_sf2`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sF2"))
proc `k_sf3=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sF3", cast[Icallback](cb))
proc `k_sf3`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sF3"))
proc `k_sf4=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sF4", cast[Icallback](cb))
proc `k_sf4`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sF4"))
proc `k_sf5=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sF5", cast[Icallback](cb))
proc `k_sf5`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sF5"))
proc `k_sf6=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sF6", cast[Icallback](cb))
proc `k_sf6`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sF6"))
proc `k_sf7=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sF7", cast[Icallback](cb))
proc `k_sf7`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sF7"))
proc `k_sf8=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sF8", cast[Icallback](cb))
proc `k_sf8`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sF8"))
proc `k_sf9=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sF9", cast[Icallback](cb))
proc `k_sf9`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sF9"))
proc `k_sf10=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sF10", cast[Icallback](cb))
proc `k_sf10`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sF10"))
proc `k_sf11=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sF11", cast[Icallback](cb))
proc `k_sf11`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sF11"))
proc `k_sf12=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sF12", cast[Icallback](cb))
proc `k_sf12`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sF12"))
proc `k_sf13=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sF13", cast[Icallback](cb))
proc `k_sf13`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sF13"))
proc `k_sf14=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sF14", cast[Icallback](cb))
proc `k_sf14`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sF14"))
proc `k_sf15=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sF15", cast[Icallback](cb))
proc `k_sf15`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sF15"))
proc `k_sf16=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sF16", cast[Icallback](cb))
proc `k_sf16`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sF16"))
proc `k_sf17=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sF17", cast[Icallback](cb))
proc `k_sf17`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sF17"))
proc `k_sf18=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sF18", cast[Icallback](cb))
proc `k_sf18`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sF18"))
proc `k_sf19=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sF19", cast[Icallback](cb))
proc `k_sf19`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sF19"))
proc `k_sf20=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sF20", cast[Icallback](cb))
proc `k_sf20`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sF20"))
proc `k_sprint=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sPrint", cast[Icallback](cb))
proc `k_sprint`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sPrint"))
proc `k_smenu=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sMenu", cast[Icallback](cb))
proc `k_smenu`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sMenu"))
proc `k_chome=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cHOME", cast[Icallback](cb))
proc `k_chome`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cHOME"))
proc `k_cup=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cUP", cast[Icallback](cb))
proc `k_cup`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cUP"))
proc `k_cpgup=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cPGUP", cast[Icallback](cb))
proc `k_cpgup`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cPGUP"))
proc `k_cleft=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cLEFT", cast[Icallback](cb))
proc `k_cleft`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cLEFT"))
proc `k_cmiddle=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cMIDDLE", cast[Icallback](cb))
proc `k_cmiddle`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cMIDDLE"))
proc `k_cright=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cRIGHT", cast[Icallback](cb))
proc `k_cright`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cRIGHT"))
proc `k_cend=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cEND", cast[Icallback](cb))
proc `k_cend`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cEND"))
proc `k_cdown=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cDOWN", cast[Icallback](cb))
proc `k_cdown`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cDOWN"))
proc `k_cpgdn=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cPGDN", cast[Icallback](cb))
proc `k_cpgdn`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cPGDN"))
proc `k_cins=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cINS", cast[Icallback](cb))
proc `k_cins`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cINS"))
proc `k_cdel=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cDEL", cast[Icallback](cb))
proc `k_cdel`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cDEL"))
proc `k_csp=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cSP", cast[Icallback](cb))
proc `k_csp`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cSP"))
proc `k_ctab=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cTAB", cast[Icallback](cb))
proc `k_ctab`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cTAB"))
proc `k_ccr=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cCR", cast[Icallback](cb))
proc `k_ccr`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cCR"))
proc `k_cbs=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cBS", cast[Icallback](cb))
proc `k_cbs`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cBS"))
proc `k_cpause=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cPAUSE", cast[Icallback](cb))
proc `k_cpause`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cPAUSE"))
proc `k_cesc=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cESC", cast[Icallback](cb))
proc `k_cesc`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cESC"))
proc `k_cclear=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cCLEAR", cast[Icallback](cb))
proc `k_cclear`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cCLEAR"))
proc `k_cccedilla=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cCcedilla", cast[Icallback](cb))
proc `k_cccedilla`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cCcedilla"))
proc `k_cf1=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cF1", cast[Icallback](cb))
proc `k_cf1`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cF1"))
proc `k_cf2=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cF2", cast[Icallback](cb))
proc `k_cf2`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cF2"))
proc `k_cf3=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cF3", cast[Icallback](cb))
proc `k_cf3`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cF3"))
proc `k_cf4=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cF4", cast[Icallback](cb))
proc `k_cf4`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cF4"))
proc `k_cf5=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cF5", cast[Icallback](cb))
proc `k_cf5`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cF5"))
proc `k_cf6=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cF6", cast[Icallback](cb))
proc `k_cf6`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cF6"))
proc `k_cf7=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cF7", cast[Icallback](cb))
proc `k_cf7`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cF7"))
proc `k_cf8=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cF8", cast[Icallback](cb))
proc `k_cf8`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cF8"))
proc `k_cf9=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cF9", cast[Icallback](cb))
proc `k_cf9`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cF9"))
proc `k_cf10=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cF10", cast[Icallback](cb))
proc `k_cf10`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cF10"))
proc `k_cf11=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cF11", cast[Icallback](cb))
proc `k_cf11`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cF11"))
proc `k_cf12=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cF12", cast[Icallback](cb))
proc `k_cf12`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cF12"))
proc `k_cf13=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cF13", cast[Icallback](cb))
proc `k_cf13`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cF13"))
proc `k_cf14=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cF14", cast[Icallback](cb))
proc `k_cf14`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cF14"))
proc `k_cf15=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cF15", cast[Icallback](cb))
proc `k_cf15`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cF15"))
proc `k_cf16=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cF16", cast[Icallback](cb))
proc `k_cf16`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cF16"))
proc `k_cf17=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cF17", cast[Icallback](cb))
proc `k_cf17`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cF17"))
proc `k_cf18=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cF18", cast[Icallback](cb))
proc `k_cf18`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cF18"))
proc `k_cf19=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cF19", cast[Icallback](cb))
proc `k_cf19`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cF19"))
proc `k_cf20=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cF20", cast[Icallback](cb))
proc `k_cf20`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cF20"))
proc `k_cprint=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cPrint", cast[Icallback](cb))
proc `k_cprint`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cPrint"))
proc `k_cmenu=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cMenu", cast[Icallback](cb))
proc `k_cmenu`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cMenu"))
proc `k_mhome=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mHOME", cast[Icallback](cb))
proc `k_mhome`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mHOME"))
proc `k_mup=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mUP", cast[Icallback](cb))
proc `k_mup`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mUP"))
proc `k_mpgup=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mPGUP", cast[Icallback](cb))
proc `k_mpgup`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mPGUP"))
proc `k_mleft=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mLEFT", cast[Icallback](cb))
proc `k_mleft`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mLEFT"))
proc `k_mmiddle=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mMIDDLE", cast[Icallback](cb))
proc `k_mmiddle`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mMIDDLE"))
proc `k_mright=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mRIGHT", cast[Icallback](cb))
proc `k_mright`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mRIGHT"))
proc `k_mend=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mEND", cast[Icallback](cb))
proc `k_mend`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mEND"))
proc `k_mdown=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mDOWN", cast[Icallback](cb))
proc `k_mdown`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mDOWN"))
proc `k_mpgdn=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mPGDN", cast[Icallback](cb))
proc `k_mpgdn`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mPGDN"))
proc `k_mins=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mINS", cast[Icallback](cb))
proc `k_mins`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mINS"))
proc `k_mdel=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mDEL", cast[Icallback](cb))
proc `k_mdel`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mDEL"))
proc `k_msp=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mSP", cast[Icallback](cb))
proc `k_msp`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mSP"))
proc `k_mtab=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mTAB", cast[Icallback](cb))
proc `k_mtab`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mTAB"))
proc `k_mcr=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mCR", cast[Icallback](cb))
proc `k_mcr`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mCR"))
proc `k_mbs=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mBS", cast[Icallback](cb))
proc `k_mbs`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mBS"))
proc `k_mpause=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mPAUSE", cast[Icallback](cb))
proc `k_mpause`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mPAUSE"))
proc `k_mesc=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mESC", cast[Icallback](cb))
proc `k_mesc`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mESC"))
proc `k_mclear=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mCLEAR", cast[Icallback](cb))
proc `k_mclear`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mCLEAR"))
proc `k_mccedilla=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mCcedilla", cast[Icallback](cb))
proc `k_mccedilla`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mCcedilla"))
proc `k_mf1=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mF1", cast[Icallback](cb))
proc `k_mf1`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mF1"))
proc `k_mf2=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mF2", cast[Icallback](cb))
proc `k_mf2`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mF2"))
proc `k_mf3=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mF3", cast[Icallback](cb))
proc `k_mf3`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mF3"))
proc `k_mf4=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mF4", cast[Icallback](cb))
proc `k_mf4`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mF4"))
proc `k_mf5=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mF5", cast[Icallback](cb))
proc `k_mf5`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mF5"))
proc `k_mf6=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mF6", cast[Icallback](cb))
proc `k_mf6`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mF6"))
proc `k_mf7=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mF7", cast[Icallback](cb))
proc `k_mf7`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mF7"))
proc `k_mf8=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mF8", cast[Icallback](cb))
proc `k_mf8`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mF8"))
proc `k_mf9=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mF9", cast[Icallback](cb))
proc `k_mf9`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mF9"))
proc `k_mf10=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mF10", cast[Icallback](cb))
proc `k_mf10`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mF10"))
proc `k_mf11=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mF11", cast[Icallback](cb))
proc `k_mf11`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mF11"))
proc `k_mf12=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mF12", cast[Icallback](cb))
proc `k_mf12`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mF12"))
proc `k_mf13=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mF13", cast[Icallback](cb))
proc `k_mf13`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mF13"))
proc `k_mf14=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mF14", cast[Icallback](cb))
proc `k_mf14`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mF14"))
proc `k_mf15=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mF15", cast[Icallback](cb))
proc `k_mf15`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mF15"))
proc `k_mf16=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mF16", cast[Icallback](cb))
proc `k_mf16`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mF16"))
proc `k_mf17=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mF17", cast[Icallback](cb))
proc `k_mf17`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mF17"))
proc `k_mf18=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mF18", cast[Icallback](cb))
proc `k_mf18`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mF18"))
proc `k_mf19=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mF19", cast[Icallback](cb))
proc `k_mf19`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mF19"))
proc `k_mf20=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mF20", cast[Icallback](cb))
proc `k_mf20`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mF20"))
proc `k_mprint=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mPrint", cast[Icallback](cb))
proc `k_mprint`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mPrint"))
proc `k_mmenu=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mMenu", cast[Icallback](cb))
proc `k_mmenu`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mMenu"))
proc `k_yhome=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yHOME", cast[Icallback](cb))
proc `k_yhome`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yHOME"))
proc `k_yup=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yUP", cast[Icallback](cb))
proc `k_yup`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yUP"))
proc `k_ypgup=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yPGUP", cast[Icallback](cb))
proc `k_ypgup`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yPGUP"))
proc `k_yleft=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yLEFT", cast[Icallback](cb))
proc `k_yleft`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yLEFT"))
proc `k_ymiddle=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yMIDDLE", cast[Icallback](cb))
proc `k_ymiddle`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yMIDDLE"))
proc `k_yright=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yRIGHT", cast[Icallback](cb))
proc `k_yright`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yRIGHT"))
proc `k_yend=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yEND", cast[Icallback](cb))
proc `k_yend`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yEND"))
proc `k_ydown=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yDOWN", cast[Icallback](cb))
proc `k_ydown`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yDOWN"))
proc `k_ypgdn=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yPGDN", cast[Icallback](cb))
proc `k_ypgdn`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yPGDN"))
proc `k_yins=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yINS", cast[Icallback](cb))
proc `k_yins`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yINS"))
proc `k_ydel=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yDEL", cast[Icallback](cb))
proc `k_ydel`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yDEL"))
proc `k_ysp=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_ySP", cast[Icallback](cb))
proc `k_ysp`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_ySP"))
proc `k_ytab=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yTAB", cast[Icallback](cb))
proc `k_ytab`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yTAB"))
proc `k_ycr=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yCR", cast[Icallback](cb))
proc `k_ycr`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yCR"))
proc `k_ybs=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yBS", cast[Icallback](cb))
proc `k_ybs`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yBS"))
proc `k_ypause=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yPAUSE", cast[Icallback](cb))
proc `k_ypause`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yPAUSE"))
proc `k_yesc=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yESC", cast[Icallback](cb))
proc `k_yesc`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yESC"))
proc `k_yclear=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yCLEAR", cast[Icallback](cb))
proc `k_yclear`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yCLEAR"))
proc `k_yccedilla=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yCcedilla", cast[Icallback](cb))
proc `k_yccedilla`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yCcedilla"))
proc `k_yf1=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yF1", cast[Icallback](cb))
proc `k_yf1`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yF1"))
proc `k_yf2=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yF2", cast[Icallback](cb))
proc `k_yf2`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yF2"))
proc `k_yf3=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yF3", cast[Icallback](cb))
proc `k_yf3`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yF3"))
proc `k_yf4=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yF4", cast[Icallback](cb))
proc `k_yf4`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yF4"))
proc `k_yf5=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yF5", cast[Icallback](cb))
proc `k_yf5`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yF5"))
proc `k_yf6=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yF6", cast[Icallback](cb))
proc `k_yf6`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yF6"))
proc `k_yf7=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yF7", cast[Icallback](cb))
proc `k_yf7`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yF7"))
proc `k_yf8=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yF8", cast[Icallback](cb))
proc `k_yf8`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yF8"))
proc `k_yf9=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yF9", cast[Icallback](cb))
proc `k_yf9`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yF9"))
proc `k_yf10=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yF10", cast[Icallback](cb))
proc `k_yf10`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yF10"))
proc `k_yf11=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yF11", cast[Icallback](cb))
proc `k_yf11`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yF11"))
proc `k_yf12=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yF12", cast[Icallback](cb))
proc `k_yf12`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yF12"))
proc `k_yf13=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yF13", cast[Icallback](cb))
proc `k_yf13`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yF13"))
proc `k_yf14=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yF14", cast[Icallback](cb))
proc `k_yf14`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yF14"))
proc `k_yf15=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yF15", cast[Icallback](cb))
proc `k_yf15`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yF15"))
proc `k_yf16=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yF16", cast[Icallback](cb))
proc `k_yf16`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yF16"))
proc `k_yf17=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yF17", cast[Icallback](cb))
proc `k_yf17`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yF17"))
proc `k_yf18=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yF18", cast[Icallback](cb))
proc `k_yf18`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yF18"))
proc `k_yf19=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yF19", cast[Icallback](cb))
proc `k_yf19`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yF19"))
proc `k_yf20=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yF20", cast[Icallback](cb))
proc `k_yf20`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yF20"))
proc `k_yprint=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yPrint", cast[Icallback](cb))
proc `k_yprint`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yPrint"))
proc `k_ymenu=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yMenu", cast[Icallback](cb))
proc `k_ymenu`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yMenu"))
proc `k_splus=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sPlus", cast[Icallback](cb))
proc `k_splus`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sPlus"))
proc `k_scomma=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sComma", cast[Icallback](cb))
proc `k_scomma`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sComma"))
proc `k_sminus=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sMinus", cast[Icallback](cb))
proc `k_sminus`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sMinus"))
proc `k_speriod=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sPeriod", cast[Icallback](cb))
proc `k_speriod`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sPeriod"))
proc `k_sslash=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sSlash", cast[Icallback](cb))
proc `k_sslash`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sSlash"))
proc `k_sasterisk=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_sAsterisk", cast[Icallback](cb))
proc `k_sasterisk`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_sAsterisk"))
proc `k_cuppera=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperA", cast[Icallback](cb))
proc `k_cuppera`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperA"))
proc `k_cupperb=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperB", cast[Icallback](cb))
proc `k_cupperb`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperB"))
proc `k_cupperc=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperC", cast[Icallback](cb))
proc `k_cupperc`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperC"))
proc `k_cupperd=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperD", cast[Icallback](cb))
proc `k_cupperd`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperD"))
proc `k_cuppere=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperE", cast[Icallback](cb))
proc `k_cuppere`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperE"))
proc `k_cupperf=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperF", cast[Icallback](cb))
proc `k_cupperf`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperF"))
proc `k_cupperg=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperG", cast[Icallback](cb))
proc `k_cupperg`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperG"))
proc `k_cupperh=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperH", cast[Icallback](cb))
proc `k_cupperh`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperH"))
proc `k_cupperi=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperI", cast[Icallback](cb))
proc `k_cupperi`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperI"))
proc `k_cupperj=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperJ", cast[Icallback](cb))
proc `k_cupperj`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperJ"))
proc `k_cupperk=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperK", cast[Icallback](cb))
proc `k_cupperk`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperK"))
proc `k_cupperl=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperL", cast[Icallback](cb))
proc `k_cupperl`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperL"))
proc `k_cupperm=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperM", cast[Icallback](cb))
proc `k_cupperm`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperM"))
proc `k_cuppern=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperN", cast[Icallback](cb))
proc `k_cuppern`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperN"))
proc `k_cuppero=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperO", cast[Icallback](cb))
proc `k_cuppero`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperO"))
proc `k_cupperp=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperP", cast[Icallback](cb))
proc `k_cupperp`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperP"))
proc `k_cupperq=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperQ", cast[Icallback](cb))
proc `k_cupperq`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperQ"))
proc `k_cupperr=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperR", cast[Icallback](cb))
proc `k_cupperr`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperR"))
proc `k_cuppers=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperS", cast[Icallback](cb))
proc `k_cuppers`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperS"))
proc `k_cuppert=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperT", cast[Icallback](cb))
proc `k_cuppert`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperT"))
proc `k_cupperu=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperU", cast[Icallback](cb))
proc `k_cupperu`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperU"))
proc `k_cupperv=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperV", cast[Icallback](cb))
proc `k_cupperv`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperV"))
proc `k_cupperw=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperW", cast[Icallback](cb))
proc `k_cupperw`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperW"))
proc `k_cupperx=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperX", cast[Icallback](cb))
proc `k_cupperx`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperX"))
proc `k_cuppery=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperY", cast[Icallback](cb))
proc `k_cuppery`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperY"))
proc `k_cupperz=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cupperZ", cast[Icallback](cb))
proc `k_cupperz`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cupperZ"))
proc `k_c1=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_c1", cast[Icallback](cb))
proc `k_c1`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_c1"))
proc `k_c2=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_c2", cast[Icallback](cb))
proc `k_c2`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_c2"))
proc `k_c3=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_c3", cast[Icallback](cb))
proc `k_c3`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_c3"))
proc `k_c4=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_c4", cast[Icallback](cb))
proc `k_c4`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_c4"))
proc `k_c5=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_c5", cast[Icallback](cb))
proc `k_c5`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_c5"))
proc `k_c6=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_c6", cast[Icallback](cb))
proc `k_c6`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_c6"))
proc `k_c7=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_c7", cast[Icallback](cb))
proc `k_c7`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_c7"))
proc `k_c8=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_c8", cast[Icallback](cb))
proc `k_c8`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_c8"))
proc `k_c9=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_c9", cast[Icallback](cb))
proc `k_c9`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_c9"))
proc `k_c0=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_c0", cast[Icallback](cb))
proc `k_c0`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_c0"))
proc `k_cplus=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cPlus", cast[Icallback](cb))
proc `k_cplus`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cPlus"))
proc `k_ccomma=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cComma", cast[Icallback](cb))
proc `k_ccomma`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cComma"))
proc `k_cminus=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cMinus", cast[Icallback](cb))
proc `k_cminus`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cMinus"))
proc `k_cperiod=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cPeriod", cast[Icallback](cb))
proc `k_cperiod`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cPeriod"))
proc `k_cslash=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cSlash", cast[Icallback](cb))
proc `k_cslash`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cSlash"))
proc `k_csemicolon=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cSemicolon", cast[Icallback](cb))
proc `k_csemicolon`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cSemicolon"))
proc `k_cequal=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cEqual", cast[Icallback](cb))
proc `k_cequal`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cEqual"))
proc `k_cbracketleft=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cBracketleft", cast[Icallback](cb))
proc `k_cbracketleft`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cBracketleft"))
proc `k_cbracketright=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cBracketright", cast[Icallback](cb))
proc `k_cbracketright`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cBracketright"))
proc `k_cbackslash=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cBackslash", cast[Icallback](cb))
proc `k_cbackslash`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cBackslash"))
proc `k_casterisk=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_cAsterisk", cast[Icallback](cb))
proc `k_casterisk`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_cAsterisk"))
proc `k_ma=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mA", cast[Icallback](cb))
proc `k_ma`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mA"))
proc `k_mb=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mB", cast[Icallback](cb))
proc `k_mb`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mB"))
proc `k_mc=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mC", cast[Icallback](cb))
proc `k_mc`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mC"))
proc `k_md=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mD", cast[Icallback](cb))
proc `k_md`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mD"))
proc `k_me=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mE", cast[Icallback](cb))
proc `k_me`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mE"))
proc `k_mf=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mF", cast[Icallback](cb))
proc `k_mf`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mF"))
proc `k_mg=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mG", cast[Icallback](cb))
proc `k_mg`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mG"))
proc `k_mh=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mH", cast[Icallback](cb))
proc `k_mh`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mH"))
proc `k_mi=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mI", cast[Icallback](cb))
proc `k_mi`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mI"))
proc `k_mj=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mJ", cast[Icallback](cb))
proc `k_mj`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mJ"))
proc `k_mk=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mK", cast[Icallback](cb))
proc `k_mk`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mK"))
proc `k_ml=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mL", cast[Icallback](cb))
proc `k_ml`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mL"))
proc `k_mm=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mM", cast[Icallback](cb))
proc `k_mm`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mM"))
proc `k_mn=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mN", cast[Icallback](cb))
proc `k_mn`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mN"))
proc `k_mo=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mO", cast[Icallback](cb))
proc `k_mo`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mO"))
proc `k_mp=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mP", cast[Icallback](cb))
proc `k_mp`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mP"))
proc `k_mq=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mQ", cast[Icallback](cb))
proc `k_mq`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mQ"))
proc `k_mr=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mR", cast[Icallback](cb))
proc `k_mr`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mR"))
proc `k_ms=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mS", cast[Icallback](cb))
proc `k_ms`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mS"))
proc `k_mt=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mT", cast[Icallback](cb))
proc `k_mt`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mT"))
proc `k_mu=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mU", cast[Icallback](cb))
proc `k_mu`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mU"))
proc `k_mv=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mV", cast[Icallback](cb))
proc `k_mv`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mV"))
proc `k_mw=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mW", cast[Icallback](cb))
proc `k_mw`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mW"))
proc `k_mx=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mX", cast[Icallback](cb))
proc `k_mx`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mX"))
proc `k_my=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mY", cast[Icallback](cb))
proc `k_my`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mY"))
proc `k_mz=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mZ", cast[Icallback](cb))
proc `k_mz`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mZ"))
proc `k_m1=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_m1", cast[Icallback](cb))
proc `k_m1`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_m1"))
proc `k_m2=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_m2", cast[Icallback](cb))
proc `k_m2`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_m2"))
proc `k_m3=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_m3", cast[Icallback](cb))
proc `k_m3`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_m3"))
proc `k_m4=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_m4", cast[Icallback](cb))
proc `k_m4`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_m4"))
proc `k_m5=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_m5", cast[Icallback](cb))
proc `k_m5`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_m5"))
proc `k_m6=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_m6", cast[Icallback](cb))
proc `k_m6`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_m6"))
proc `k_m7=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_m7", cast[Icallback](cb))
proc `k_m7`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_m7"))
proc `k_m8=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_m8", cast[Icallback](cb))
proc `k_m8`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_m8"))
proc `k_m9=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_m9", cast[Icallback](cb))
proc `k_m9`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_m9"))
proc `k_m0=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_m0", cast[Icallback](cb))
proc `k_m0`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_m0"))
proc `k_mplus=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mPlus", cast[Icallback](cb))
proc `k_mplus`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mPlus"))
proc `k_mcomma=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mComma", cast[Icallback](cb))
proc `k_mcomma`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mComma"))
proc `k_mminus=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mMinus", cast[Icallback](cb))
proc `k_mminus`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mMinus"))
proc `k_mperiod=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mPeriod", cast[Icallback](cb))
proc `k_mperiod`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mPeriod"))
proc `k_mslash=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mSlash", cast[Icallback](cb))
proc `k_mslash`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mSlash"))
proc `k_msemicolon=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mSemicolon", cast[Icallback](cb))
proc `k_msemicolon`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mSemicolon"))
proc `k_mequal=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mEqual", cast[Icallback](cb))
proc `k_mequal`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mEqual"))
proc `k_mbracketleft=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mBracketleft", cast[Icallback](cb))
proc `k_mbracketleft`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mBracketleft"))
proc `k_mbracketright=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mBracketright", cast[Icallback](cb))
proc `k_mbracketright`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mBracketright"))
proc `k_mbackslash=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mBackslash", cast[Icallback](cb))
proc `k_mbackslash`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mBackslash"))
proc `k_masterisk=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_mAsterisk", cast[Icallback](cb))
proc `k_masterisk`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_mAsterisk"))
proc `k_ya=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yA", cast[Icallback](cb))
proc `k_ya`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yA"))
proc `k_yb=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yB", cast[Icallback](cb))
proc `k_yb`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yB"))
proc `k_yc=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yC", cast[Icallback](cb))
proc `k_yc`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yC"))
proc `k_yd=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yD", cast[Icallback](cb))
proc `k_yd`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yD"))
proc `k_ye=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yE", cast[Icallback](cb))
proc `k_ye`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yE"))
proc `k_yf=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yF", cast[Icallback](cb))
proc `k_yf`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yF"))
proc `k_yg=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yG", cast[Icallback](cb))
proc `k_yg`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yG"))
proc `k_yh=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yH", cast[Icallback](cb))
proc `k_yh`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yH"))
proc `k_yi=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yI", cast[Icallback](cb))
proc `k_yi`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yI"))
proc `k_yj=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yJ", cast[Icallback](cb))
proc `k_yj`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yJ"))
proc `k_yk=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yK", cast[Icallback](cb))
proc `k_yk`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yK"))
proc `k_yl=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yL", cast[Icallback](cb))
proc `k_yl`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yL"))
proc `k_ym=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yM", cast[Icallback](cb))
proc `k_ym`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yM"))
proc `k_yn=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yN", cast[Icallback](cb))
proc `k_yn`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yN"))
proc `k_yo=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yO", cast[Icallback](cb))
proc `k_yo`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yO"))
proc `k_yp=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yP", cast[Icallback](cb))
proc `k_yp`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yP"))
proc `k_yq=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yQ", cast[Icallback](cb))
proc `k_yq`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yQ"))
proc `k_yr=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yR", cast[Icallback](cb))
proc `k_yr`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yR"))
proc `k_ys=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yS", cast[Icallback](cb))
proc `k_ys`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yS"))
proc `k_yt=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yT", cast[Icallback](cb))
proc `k_yt`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yT"))
proc `k_yu=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yU", cast[Icallback](cb))
proc `k_yu`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yU"))
proc `k_yv=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yV", cast[Icallback](cb))
proc `k_yv`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yV"))
proc `k_yw=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yW", cast[Icallback](cb))
proc `k_yw`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yW"))
proc `k_yx=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yX", cast[Icallback](cb))
proc `k_yx`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yX"))
proc `k_yy=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yY", cast[Icallback](cb))
proc `k_yy`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yY"))
proc `k_yz=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yZ", cast[Icallback](cb))
proc `k_yz`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yZ"))
proc `k_y1=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_y1", cast[Icallback](cb))
proc `k_y1`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_y1"))
proc `k_y2=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_y2", cast[Icallback](cb))
proc `k_y2`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_y2"))
proc `k_y3=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_y3", cast[Icallback](cb))
proc `k_y3`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_y3"))
proc `k_y4=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_y4", cast[Icallback](cb))
proc `k_y4`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_y4"))
proc `k_y5=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_y5", cast[Icallback](cb))
proc `k_y5`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_y5"))
proc `k_y6=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_y6", cast[Icallback](cb))
proc `k_y6`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_y6"))
proc `k_y7=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_y7", cast[Icallback](cb))
proc `k_y7`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_y7"))
proc `k_y8=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_y8", cast[Icallback](cb))
proc `k_y8`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_y8"))
proc `k_y9=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_y9", cast[Icallback](cb))
proc `k_y9`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_y9"))
proc `k_y0=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_y0", cast[Icallback](cb))
proc `k_y0`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_y0"))
proc `k_yplus=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yPlus", cast[Icallback](cb))
proc `k_yplus`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yPlus"))
proc `k_ycomma=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yComma", cast[Icallback](cb))
proc `k_ycomma`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yComma"))
proc `k_yminus=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yMinus", cast[Icallback](cb))
proc `k_yminus`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yMinus"))
proc `k_yperiod=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yPeriod", cast[Icallback](cb))
proc `k_yperiod`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yPeriod"))
proc `k_yslash=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_ySlash", cast[Icallback](cb))
proc `k_yslash`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_ySlash"))
proc `k_ysemicolon=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_ySemicolon", cast[Icallback](cb))
proc `k_ysemicolon`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_ySemicolon"))
proc `k_yequal=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yEqual", cast[Icallback](cb))
proc `k_yequal`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yEqual"))
proc `k_ybracketleft=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yBracketleft", cast[Icallback](cb))
proc `k_ybracketleft`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yBracketleft"))
proc `k_ybracketright=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yBracketright", cast[Icallback](cb))
proc `k_ybracketright`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yBracketright"))
proc `k_ybackslash=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yBackslash", cast[Icallback](cb))
proc `k_ybackslash`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yBackslash"))
proc `k_yasterisk=`*(control: IUPhandle_t, cb: proc (ih: PIhandle, c: cint): cint {.cdecl.}) =
  niupc.SetCallback(cast[PIhandle](control), "K_yAsterisk", cast[Icallback](cb))
proc `k_yasterisk`*(control: IUPhandle_t): proc (ih: PIhandle, c: cint): Icallback {.cdecl.} =
  return cast[proc (ih: PIhandle, c: cint): cint {.cdecl.}](GetCallback(cast[PIhandle](control), "K_yAsterisk"))
